<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chess Game</title>
</head>

    <!--CSS Part Start-->
    <style>
        .chess_board {
            width: 500px;
            height: 500px;
            margin: auto;
            background-color: cyan;
            display: flex;
            flex-wrap: wrap;
        }

        .chess_board div {
            width: 12.5%;
            height: 12.5%;
            box-sizing: border-box;
        }

        img {
            width: 100%;
            height: 100%;
            box-sizing: border-box;
        }

        .checked {
            width: 50%;
            margin: auto;
        }
        h1 {
            width: 50%;
            margin: auto;
            text-align: center;
            opacity: 0;
        }
    </style>
    <!--CSS Part End-->

    <!--JavaScript Part Start-->
    <script defer>
        document.addEventListener("DOMContentLoaded", function() {

            // Classes ////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            // Pawn class start
            class Pawn {
                constructor (pawnPosition, blackUp, color) {
                    this.firstMove = true;
                    this.position = pawnPosition;
                    this.blackUp = blackUp;
                    this.color = color;
                    this.numberOfMoves = 0;
                    this.enPassant = true;
                }

                
                possibleMove(xAxisValue, yAxisValue, prediction, newxAxisValue, newyAxisValue) {
                    let possibleMovements = [];
                    let leftPiece;
                    let rightPiece;
                    let leftImagePiece;
                    let rightImagePiece;
                    let foundIdx;

                    if (this.firstMove === true && this.numberOfMoves === 0) {
                        // prediction is not real movement of pawn
                        if (prediction) {
                            this.firstMove = true;
                        } else {
                            this.firstMove = false;
                            this.numberOfMoves++;
                        }
                        

                        if ((this.blackUp && this.color === "black") || (!this.blackUp && this.color === "white")) {
                            possibleMovements.push(`.cell_${parseInt(xAxisValue)+1}_${yAxisValue}`);
                            possibleMovements.push(`.cell_${parseInt(xAxisValue)+2}_${yAxisValue}`);
                        }

                        if ((!this.blackUp && this.color === "black") || (this.blackUp && this.color === "white")) {
                            possibleMovements.push(`.cell_${parseInt(xAxisValue)-1}_${yAxisValue}`);
                            possibleMovements.push(`.cell_${parseInt(xAxisValue)-2}_${yAxisValue}`);
                        }

                    } else {
                        if ((this.blackUp && this.color === "black") || (!this.blackUp && this.color === "white")) {
                            if (parseInt(yAxisValue) <= 8) {
                                
                                // if the current xAxisValue equals 5
                                if (parseInt(xAxisValue) === 5) {
                                    // check if there is left piece
                                    if (parseInt(yAxisValue) > 1) {
                                        leftPiece = document.querySelector(`.cell_${parseInt(xAxisValue)}_${parseInt(yAxisValue)-1}`);
                                        if (leftPiece.querySelector("img")) {
                                            leftImagePiece = leftPiece.querySelector("img");
                                        }
                                    }

                                    // check if there is right piece
                                    if (parseInt(yAxisValue) < 8) {
                                        rightPiece = document.querySelector(`.cell_${parseInt(xAxisValue)}_${parseInt(yAxisValue)+1}`);
                                        if (rightPiece.querySelector("img")) {
                                            rightImagePiece = rightPiece.querySelector("img");    
                                        }
                                    }

                                    // check left image
                                    if (leftImagePiece !== undefined && leftImagePiece.getAttribute('alt').includes("blackPawn") && this.color === "white") {
                                        foundIdx = blackPawnPieces.findIndex((eachClass) => {return eachClass.position === `.cell_${parseInt(xAxisValue)}_${parseInt(yAxisValue)-1}`});
                                        if (blackPawnPieces[foundIdx].numberOfMoves == 1) {
                                            if (this.enPassant) {
                                                possibleMovements = this.eatingPossibility(xAxisValue, yAxisValue, true);
                                                this.enPassant = false;
                                            }
                                            
                                        }
                                    } else if (leftImagePiece !== undefined && leftImagePiece.getAttribute('alt').includes("whitePawn") && this.color === "black") {
                                        foundIdx = whitePawnPieces.findIndex((eachClass) => {return eachClass.position === `.cell_${parseInt(xAxisValue)}_${parseInt(yAxisValue)-1}`});
                                        if (whitePawnPieces[foundIdx].numberOfMoves == 1) {
                                            if (this.enPassant) {
                                                possibleMovements = this.eatingPossibility(xAxisValue, yAxisValue, true);
                                                this.enPassant = false;
                                            }
                                            
                                        }
                                    }

                                    // check right image
                                    if (rightImagePiece !== undefined && rightImagePiece.getAttribute('alt').includes("blackPawn") && this.color === "white") {
                                        foundIdx = blackPawnPieces.findIndex((eachClass) => {return eachClass.position === `.cell_${parseInt(xAxisValue)}_${parseInt(yAxisValue)+1}`});
                                        if (blackPawnPieces[foundIdx].numberOfMoves == 1) {
                                            if (this.enPassant) {
                                                possibleMovements = this.eatingPossibility(xAxisValue, yAxisValue, true);
                                                this.enPassant = false;
                                            }
                                            
                                        }
                                    } else if (rightImagePiece !== undefined && rightImagePiece.getAttribute('alt').includes("whitePawn") && this.color === "black") {
                                        foundIdx = whitePawnPieces.findIndex((eachClass) => {return eachClass.position === `.cell_${parseInt(xAxisValue)}_${parseInt(yAxisValue)+1}`});
                                        if (whitePawnPieces[foundIdx].numberOfMoves == 1) {
                                            possibleMovements = this.eatingPossibility(xAxisValue, yAxisValue, true);
                                            this.enPassant = false;
                                        }
                                    }


                                } // it has to be the fifth row

                                possibleMovements.push(`.cell_${parseInt(xAxisValue) + 1}_${yAxisValue}`);
                            }
                        }

                        if ((!this.blackUp && this.color === "black") || (this.blackUp && this.color === "white")) {
                            if (parseInt(yAxisValue) >= 1) {
                                // if the current yAxisValue equals 4
                                if (parseInt(xAxisValue) === 4) {
                                    // check if there is left piece
                                    if (parseInt(yAxisValue) > 1) {
                                        leftPiece = document.querySelector(`.cell_${parseInt(xAxisValue)}_${parseInt(yAxisValue)-1}`);
                                        if (leftPiece.querySelector("img")) {
                                            leftImagePiece = leftPiece.querySelector("img");
                                        }
                                    }

                                    // check if there is right piece
                                    if (parseInt(yAxisValue) < 8) {
                                        rightPiece = document.querySelector(`.cell_${parseInt(xAxisValue)}_${parseInt(yAxisValue)+1}`);
                                        if (rightPiece.querySelector("img")) {
                                            rightImagePiece = rightPiece.querySelector("img");    
                                        }
                                    }

                                    // check left image
                                    if (leftImagePiece !== undefined && leftImagePiece.getAttribute('alt').includes("blackPawn") && this.color === "white") {
                                        foundIdx = blackPawnPieces.findIndex((eachClass) => {return eachClass.position === `.cell_${parseInt(xAxisValue)}_${parseInt(yAxisValue)-1}`});
                                        if (blackPawnPieces[foundIdx].numberOfMoves == 1) {
                                            if (this.enPassant) {
                                                possibleMovements = this.eatingPossibility(xAxisValue, yAxisValue, true);
                                                this.enPassant = false;
                                            }
                                            
                                        }
                                    } else if (leftImagePiece !== undefined && leftImagePiece.getAttribute('alt').includes("whitePawn") && this.color === "black") {
                                        foundIdx = whitePawnPieces.findIndex((eachClass) => {return eachClass.position === `.cell_${parseInt(xAxisValue)}_${parseInt(yAxisValue)-1}`});
                                        if (whitePawnPieces[foundIdx].numberOfMoves == 1) {
                                            if (this.enPassant) {
                                                possibleMovements = this.eatingPossibility(xAxisValue, yAxisValue, true);
                                                this.enPassant = false;
                                            }
                                            
                                        }
                                    }

                                    // check right image
                                    if (rightImagePiece !== undefined && rightImagePiece.getAttribute('alt').includes("blackPawn") && this.color === "white") {
                                        foundIdx = blackPawnPieces.findIndex((eachClass) => {return eachClass.position === `.cell_${parseInt(xAxisValue)}_${parseInt(yAxisValue)+1}`});
                                        if (blackPawnPieces[foundIdx].numberOfMoves == 1) {
                                            if (this.enPassant) {
                                                possibleMovements = this.eatingPossibility(xAxisValue, yAxisValue, true);
                                                this.enPassant = false;
                                            }
                                            
                                        }
                                    } else if (rightImagePiece !== undefined && rightImagePiece.getAttribute('alt').includes("whitePawn") && this.color === "black") {
                                        foundIdx = whitePawnPieces.findIndex((eachClass) => {return eachClass.position === `.cell_${parseInt(xAxisValue)}_${parseInt(yAxisValue)+1}`});
                                        if (whitePawnPieces[foundIdx].numberOfMoves == 1) {
                                            if (this.enPassant) {
                                                possibleMovements = this.eatingPossibility(xAxisValue, yAxisValue, true);
                                                this.enPassant = false;
                                            }
                                            
                                        }
                                    }
                                } // it has to be the fifth row


                                possibleMovements.push(`.cell_${parseInt(xAxisValue) - 1}_${yAxisValue}`);
                            }
                        }

                        if (!prediction) {
                            this.numberOfMoves++;
                        } 

                    }
                    
                    return possibleMovements;
                }

                updatePosition(newCoordinates) {
                    this.position = newCoordinates;
                }

                eatingPossibility(xAxisValue, yAxisValue, prediction) {
                    let possibleMovements = [];

                    
                    if (this.blackUp && this.color === "black") {
                        if (parseInt(yAxisValue) <= 8) {
                            possibleMovements.push(`.cell_${parseInt(xAxisValue) + 1}_${parseInt(yAxisValue) + 1}`);
                            possibleMovements.push(`.cell_${parseInt(xAxisValue) + 1}_${parseInt(yAxisValue) - 1}`);
                        }
                    }

                    if (!this.blackUp && this.color === "black") {
                        if (parseInt(yAxisValue) >= 1) {
                            possibleMovements.push(`.cell_${parseInt(xAxisValue) - 1}_${parseInt(yAxisValue) + 1}`);
                            possibleMovements.push(`.cell_${parseInt(xAxisValue) - 1}_${parseInt(yAxisValue) - 1}`);
                        }
                    }

                    if (this.blackUp && this.color === "white") {
                        if (parseInt(yAxisValue) <= 8) {
                            possibleMovements.push(`.cell_${parseInt(xAxisValue) - 1}_${parseInt(yAxisValue) + 1}`);
                            possibleMovements.push(`.cell_${parseInt(xAxisValue) - 1}_${parseInt(yAxisValue) - 1}`);
                        }
                    }

                    if (!this.blackUp && this.color === "white") {
                        if (parseInt(yAxisValue) <= 8) {
                            possibleMovements.push(`.cell_${parseInt(xAxisValue) + 1}_${parseInt(yAxisValue) + 1}`);
                            possibleMovements.push(`.cell_${parseInt(xAxisValue) + 1}_${parseInt(yAxisValue) - 1}`);
                        }
                    }

                    if (!prediction) {
                        this.numberOfMoves++; 
                    }

                    return possibleMovements;
                }


            }
            // Pawn class end

            // Rook class start
            class Rook{
                constructor (rookPosition, blackUp, color) {
                    this.position = rookPosition;
                    this.blackUp = blackUp;
                    this.color = color;
                    this.numberOfMoves = 0;
                }

                possibleMove(xAxisValue, yAxisValue, newxAxisValue, newyAxisValue, prediction) {
                    let possibleMovements = [];

                    if(newxAxisValue == xAxisValue) {
                        if (yAxisValue < newyAxisValue) {
                            for(let i = yAxisValue; i < newyAxisValue; i++){
                                let blockingPiece = document.querySelector(`.cell_${newxAxisValue}_${parseInt(i) + 1}`);

                                // if blockingPiece is none then add
                                if (blockingPiece.innerHTML === ""){
                                    possibleMovements.push(`.cell_${newxAxisValue}_${parseInt(i) + 1}`);
                                } else {
                                    break;
                                }
                            } // end of for each statement
                        }

                        if (yAxisValue > newyAxisValue) {
                            for(let i = yAxisValue; i > newyAxisValue; i--){
                                let blockingPiece = document.querySelector(`.cell_${newxAxisValue}_${parseInt(i) - 1}`);

                                // if blockingPiece is none then add
                                if (blockingPiece.innerHTML === ""){
                                    possibleMovements.push(`.cell_${newxAxisValue}_${parseInt(i) - 1}`);
                                } else {
                                    break;
                                }
                            } // end of for each statement
                        }
                    } // end of if newxAxisValue == xAxisValue statement


                    if(newyAxisValue == yAxisValue) {
                        if (xAxisValue < newxAxisValue) {
                            for(let i = xAxisValue; i < newxAxisValue; i++){
                                let blockingPiece = document.querySelector(`.cell_${parseInt(i) + 1}_${newyAxisValue}`);

                                // if blockingPiece is none then add
                                if (blockingPiece.innerHTML === ""){
                                    possibleMovements.push(`.cell_${parseInt(i) + 1}_${newyAxisValue}`);
                                } else {
                                    break;
                                }
                            } // end of for each statement
                        }

                        if (xAxisValue > newxAxisValue) {
                            for(let i = xAxisValue; i > newxAxisValue; i--){
                                let blockingPiece = document.querySelector(`.cell_${parseInt(i) - 1}_${newyAxisValue}`);

                                // if blockingPiece is none then add
                                if (blockingPiece.innerHTML === ""){
                                    possibleMovements.push(`.cell_${parseInt(i) - 1}_${newyAxisValue}`);
                                } else {
                                    break;
                                }
                            } // end of for each statement
                        }
                    } // end of if newyAxisValue == yAxisValue statement

                    if (!prediction) {
                        this.numberOfMoves++;
                    }
                
                    return possibleMovements;   
                }

                updatePosition(newCoordinates) {
                    this.position = newCoordinates;
                }

                // eating possibilities
                eatingPossibility(xAxisValue, yAxisValue, newxAxisValue, newyAxisValue, prediction) {
                    let possibleMovements = [];
                    let recNumber = 0;

                    // start of if newxAxisValue == xAxisValue statement
                    if(newxAxisValue == xAxisValue) {
                        if (yAxisValue < newyAxisValue) {
                            let yAxisValuePlusOne = parseInt(yAxisValue)+1;
                            recNumber = yAxisValuePlusOne;

                            for(let i = yAxisValuePlusOne; i < newyAxisValue; i++){
                                let blockingPiece = document.querySelector(`.cell_${newxAxisValue}_${i}`);

                                // if blockingPiece is none then add
                                if (blockingPiece.innerHTML === ""){
                                    possibleMovements.push(`.cell_${newxAxisValue}_${i}`);
                                } else {
                                    break;
                                }
                                recNumber++;
                            } // end of for each statement

                            if (recNumber == newyAxisValue) {
                                possibleMovements.push(`.cell_${newxAxisValue}_${recNumber}`);
                            }
                            
                        }

                        if (yAxisValue > newyAxisValue) {
                            let yAxisValueMinusOne = parseInt(yAxisValue)-1;
                            recNumber = yAxisValueMinusOne; 
                            for(let i = yAxisValueMinusOne; i > newyAxisValue; i--){
                                let blockingPiece = document.querySelector(`.cell_${newxAxisValue}_${i}`);

                                // if blockingPiece is none then add
                                if (blockingPiece.innerHTML === ""){
                                    possibleMovements.push(`.cell_${newxAxisValue}_${i}`);
                                } else {
                                    break;
                                }
                                recNumber--;
                            } // end of for each statement

                            if (recNumber == newyAxisValue) {
                                possibleMovements.push(`.cell_${newxAxisValue}_${recNumber}`);
                            }
                        }
                    } // end of if newxAxisValue == xAxisValue statement


                    // start of if newyAxisValue == yAxisValue statement
                    if(newyAxisValue == yAxisValue) {
                        if (xAxisValue < newxAxisValue) {
                            let xAxisValuePlusOne = parseInt(xAxisValue)+1;
                            recNumber = xAxisValuePlusOne;

                            for(let i = xAxisValuePlusOne; i < newxAxisValue; i++){
                                let blockingPiece = document.querySelector(`.cell_${i}_${newyAxisValue}`);

                                // if blockingPiece is none then add
                                if (blockingPiece.innerHTML === ""){
                                    possibleMovements.push(`.cell_${i}_${newyAxisValue}`);
                                } else {
                                    break;
                                }
                                recNumber++;
                            } // end of for each statement

                            if (recNumber == newxAxisValue) {
                                possibleMovements.push(`.cell_${recNumber}_${newyAxisValue}`);
                            }
                        }

                        if (xAxisValue > newxAxisValue) {
                            let xAxisValueMinusOne = parseInt(xAxisValue)-1;
                            recNumber = xAxisValueMinusOne;

                            for(let i = xAxisValueMinusOne; i > newxAxisValue; i--){
                                let blockingPiece = document.querySelector(`.cell_${i}_${newyAxisValue}`);

                                // if blockingPiece is none then add
                                if (blockingPiece.innerHTML === ""){
                                    possibleMovements.push(`.cell_${i}_${newyAxisValue}`);
                                } else {
                                    break;
                                }
                                recNumber--;
                            } // end of for each statement

                            if (recNumber == newxAxisValue) {
                                possibleMovements.push(`.cell_${recNumber}_${newyAxisValue}`);
                            }
                        }
                    } // end of if newyAxisValue == yAxisValue statement

                    if(!prediction) {
                        this.numberOfMoves++;
                    }

                    return possibleMovements;

                }

            }
            // Rook class end

            // Bishop class start
            class Bishop {
                constructor (bishopPosition, blackUp, color) {
                    this.position = bishopPosition;
                    this.blackUp = blackUp;
                    this.color = color;
                }

                possibleMove(xAxisValue, yAxisValue, newxAxisValue, newyAxisValue) {
                    let possibleMovements = [];
                    let diff_x_value = newxAxisValue - xAxisValue;
                    let diff_y_value = newyAxisValue - yAxisValue;
                    let abs_diff_x_value = Math.abs(diff_x_value);
                    let abs_diff_y_value = Math.abs(diff_y_value);

                    // absolute value has to be same for x value and y value
                    if(abs_diff_x_value == abs_diff_y_value) {
                        // down diagonally(down right)
                        if (diff_x_value > 0 && diff_y_value > 0) {
                            for(let i = 1; i <= abs_diff_x_value; i++){
                                let blockingPiece = document.querySelector(`.cell_${xAxisValue + i}_${yAxisValue + i}`);

                                // if blockingPiece is none then add
                                if (blockingPiece.innerHTML === ""){
                                    possibleMovements.push(`.cell_${xAxisValue + i}_${yAxisValue + i}`);
                                } else {
                                    break;
                                }
                            } // end of for each statement
                        }

                        // down diagonally(down left)
                        if (diff_x_value > 0 && diff_y_value < 0) {
                            for(let i = 1; i <= abs_diff_y_value; i++){
                                let blockingPiece = document.querySelector(`.cell_${xAxisValue + i}_${yAxisValue + (i * -1)}`);

                                // if blockingPiece is none then add
                                if (blockingPiece.innerHTML === ""){
                                    possibleMovements.push(`.cell_${xAxisValue + i}_${yAxisValue + (i * -1)}`);
                                } else {
                                    break;
                                }
                            } // end of for each statement
                        }

                        // up diagonally(up right)
                        if (diff_x_value < 0 && diff_y_value > 0) {
                            for(let i = 1; i <= abs_diff_y_value; i++){
                                let blockingPiece = document.querySelector(`.cell_${xAxisValue + (i * -1)}_${yAxisValue + i}`);

                                // if blockingPiece is none then add
                                if (blockingPiece.innerHTML === ""){
                                    possibleMovements.push(`.cell_${xAxisValue + (i * -1)}_${yAxisValue + i}`);
                                } else {
                                    break;
                                }
                            } // end of for each statement
                        }

                        // up diagonally(up left)
                        if (diff_x_value < 0 && diff_y_value < 0) {
                            for(let i = 1; i <= abs_diff_y_value; i++){
                                let blockingPiece = document.querySelector(`.cell_${xAxisValue + (i * -1)}_${yAxisValue + (i * -1)}`);

                                // if blockingPiece is none then add
                                if (blockingPiece.innerHTML === ""){
                                    possibleMovements.push(`.cell_${xAxisValue + (i * -1)}_${yAxisValue + (i * -1)}`);
                                } else {
                                    break;
                                }
                            } // end of for each statement
                        }

                    } // end of if newxAxisValue == xAxisValue statement
                
                    return possibleMovements;   
                }

                updatePosition(newCoordinates) {
                    this.position = newCoordinates;
                }

                // eating possibilities
                eatingPossibility(xAxisValue, yAxisValue, newxAxisValue, newyAxisValue) {
                    let possibleMovements = [];
                    let diff_x_value = newxAxisValue - xAxisValue;
                    let diff_y_value = newyAxisValue - yAxisValue;
                    let abs_diff_x_value = Math.abs(diff_x_value);
                    let abs_diff_y_value = Math.abs(diff_y_value);
                    let row_recNumber = 0;
                    let col_recNumber = 0;


                    if(abs_diff_x_value == abs_diff_y_value) {
                        // down diagonally(down right)
                        if (diff_x_value > 0 && diff_y_value > 0) {
                            for(let i = 1; i <= abs_diff_x_value; i++){
                                let blockingPiece = document.querySelector(`.cell_${xAxisValue + i}_${yAxisValue + i}`);
                                row_recNumber = xAxisValue + i;
                                col_recNumber = yAxisValue + i;

                                // if blockingPiece is none then add
                                if (blockingPiece.innerHTML === ""){
                                    possibleMovements.push(`.cell_${xAxisValue + i}_${yAxisValue + i}`);
                                } else {
                                    break;
                                }
                                
                            } // end of for each statement
                        }

                        // down diagonally(down left)
                        if (diff_x_value > 0 && diff_y_value < 0) {
                            for(let i = 1; i <= abs_diff_y_value; i++){
                                let blockingPiece = document.querySelector(`.cell_${xAxisValue + i}_${yAxisValue + (i * -1)}`);
                                row_recNumber = xAxisValue + i;
                                col_recNumber = yAxisValue + (i * -1);

                                // if blockingPiece is none then add
                                if (blockingPiece.innerHTML === ""){
                                    possibleMovements.push(`.cell_${xAxisValue + i}_${yAxisValue + (i * -1)}`);
                                    
                                } else {
                                    break;
                                }
                                
                            } // end of for each statement
                        }

                        // up diagonally(up right)
                        if (diff_x_value < 0 && diff_y_value > 0) {
                            for(let i = 1; i <= abs_diff_y_value; i++){
                                let blockingPiece = document.querySelector(`.cell_${xAxisValue + (i * -1)}_${yAxisValue + i}`);
                                row_recNumber = xAxisValue + (i * -1);
                                col_recNumber = yAxisValue + i;

                                // if blockingPiece is none then add
                                if (blockingPiece.innerHTML === ""){
                                    possibleMovements.push(`.cell_${xAxisValue + (i * -1)}_${yAxisValue + i}`);
                                    
                                } else {
                                    break;
                                }
                                
                            } // end of for each statement
                        }

                        // up diagonally(up left)
                        if (diff_x_value < 0 && diff_y_value < 0) {
                            for(let i = 1; i <= abs_diff_y_value; i++){
                                let blockingPiece = document.querySelector(`.cell_${xAxisValue + (i * -1)}_${yAxisValue + (i * -1)}`);
                                row_recNumber = xAxisValue + (i * -1);
                                col_recNumber = yAxisValue + (i * -1);

                                // if blockingPiece is none then add
                                if (blockingPiece.innerHTML === ""){
                                    possibleMovements.push(`.cell_${xAxisValue + (i * -1)}_${yAxisValue + (i * -1)}`);
                                    
                                } else {
                                    break;
                                }
                                
                            } // end of for each statement
                        }
                        if (row_recNumber == newxAxisValue && col_recNumber == newyAxisValue) {
                                possibleMovements.push(`.cell_${row_recNumber}_${col_recNumber}`);
                        }

                    }

                    return possibleMovements;

                }

            }
            // Bishop class end

            // Knight class start
            class Knight {
                constructor (knightPosition, blackUp, color) {
                    this.position = knightPosition;
                    this.blackUp = blackUp;
                    this.color = color;
                }

                possibleMove(xAxisValue, yAxisValue, newxAxisValue, newyAxisValue) {
                    let possibleMovements = [];
                    let diff_x_value = newxAxisValue - xAxisValue;
                    let diff_y_value = newyAxisValue - yAxisValue;
                    let abs_diff_x_value = Math.abs(diff_x_value);
                    let abs_diff_y_value = Math.abs(diff_y_value);
                    let abs_total_val = abs_diff_x_value + abs_diff_y_value;
                    let row_recNumber = 0;
                    let col_recNumber = 0;


                    if((abs_total_val == 3 && abs_diff_x_value !== 0) ||(abs_total_val == 3 && abs_diff_y_value !== 0)) {
                        // 2 down right and left
                        if (abs_diff_x_value == 2) {
                            possibleMovements.push(`.cell_${xAxisValue+2}_${yAxisValue+1}`);
                            possibleMovements.push(`.cell_${xAxisValue+2}_${yAxisValue-1}`);
                            possibleMovements.push(`.cell_${xAxisValue-2}_${yAxisValue+1}`);
                            possibleMovements.push(`.cell_${xAxisValue-2}_${yAxisValue-1}`);
                        } else if (abs_diff_x_value == 1) {
                            possibleMovements.push(`.cell_${xAxisValue+1}_${yAxisValue+2}`);
                            possibleMovements.push(`.cell_${xAxisValue+1}_${yAxisValue-2}`);
                            possibleMovements.push(`.cell_${xAxisValue-1}_${yAxisValue+2}`);
                            possibleMovements.push(`.cell_${xAxisValue-1}_${yAxisValue-2}`);
                        }
                    }

                    return possibleMovements;
                }

                updatePosition(newCoordinates) {
                    this.position = newCoordinates;
                }

                
            }
            // Knight class end

            // Queen class start
            class Queen {
                constructor (queenPosition, blackUp, color) {
                    this.position = queenPosition;
                    this.blackUp = blackUp;
                    this.color = color;
                }

                possibleMove(xAxisValue, yAxisValue, newxAxisValue, newyAxisValue) {
                    let possibleMovements = [];
                    let diff_x_value = newxAxisValue - xAxisValue;
                    let diff_y_value = newyAxisValue - yAxisValue;
                    let abs_diff_x_value = Math.abs(diff_x_value);
                    let abs_diff_y_value = Math.abs(diff_y_value);
                    let abs_total_val = abs_diff_x_value + abs_diff_y_value;
                    let row_recNumber = 0;
                    let col_recNumber = 0;

                    // It has Rookmovements start
                    if(newxAxisValue == xAxisValue) {
                        if (yAxisValue < newyAxisValue) {
                            for(let i = yAxisValue; i < newyAxisValue; i++){
                                let blockingPiece = document.querySelector(`.cell_${newxAxisValue}_${parseInt(i) + 1}`);

                                // if blockingPiece is none then add
                                if (blockingPiece.innerHTML === ""){
                                    possibleMovements.push(`.cell_${newxAxisValue}_${parseInt(i) + 1}`);
                                } else {
                                    break;
                                }
                            } // end of for each statement
                        }

                        if (yAxisValue > newyAxisValue) {
                            for(let i = yAxisValue; i > newyAxisValue; i--){
                                let blockingPiece = document.querySelector(`.cell_${newxAxisValue}_${parseInt(i) - 1}`);

                                // if blockingPiece is none then add
                                if (blockingPiece.innerHTML === ""){
                                    possibleMovements.push(`.cell_${newxAxisValue}_${parseInt(i) - 1}`);
                                } else {
                                    break;
                                }
                            } // end of for each statement
                        }
                    } // end of if newxAxisValue == xAxisValue statement


                    if(newyAxisValue == yAxisValue) {
                        if (xAxisValue < newxAxisValue) {
                            for(let i = xAxisValue; i < newxAxisValue; i++){
                                let blockingPiece = document.querySelector(`.cell_${parseInt(i) + 1}_${newyAxisValue}`);

                                // if blockingPiece is none then add
                                if (blockingPiece.innerHTML === ""){
                                    possibleMovements.push(`.cell_${parseInt(i) + 1}_${newyAxisValue}`);
                                } else {
                                    break;
                                }
                            } // end of for each statement
                        }

                        if (xAxisValue > newxAxisValue) {
                            for(let i = xAxisValue; i > newxAxisValue; i--){
                                let blockingPiece = document.querySelector(`.cell_${parseInt(i) - 1}_${newyAxisValue}`);

                                // if blockingPiece is none then add
                                if (blockingPiece.innerHTML === ""){
                                    possibleMovements.push(`.cell_${parseInt(i) - 1}_${newyAxisValue}`);
                                } else {
                                    break;
                                }
                            } // end of for each statement
                        }
                    } // end of if newyAxisValue == yAxisValue statement
                    // Rook movement end

                    // It has Bishop Movements
                    // absolute value has to be same for x value and y value
                    if(abs_diff_x_value == abs_diff_y_value) {
                        // down diagonally(down right)
                        if (diff_x_value > 0 && diff_y_value > 0) {
                            for(let i = 1; i <= abs_diff_x_value; i++){
                                let blockingPiece = document.querySelector(`.cell_${xAxisValue + i}_${yAxisValue + i}`);

                                // if blockingPiece is none then add
                                if (blockingPiece.innerHTML === ""){
                                    possibleMovements.push(`.cell_${xAxisValue + i}_${yAxisValue + i}`);
                                } else {
                                    break;
                                }
                            } // end of for each statement
                        }

                        // down diagonally(down left)
                        if (diff_x_value > 0 && diff_y_value < 0) {
                            for(let i = 1; i <= abs_diff_y_value; i++){
                                let blockingPiece = document.querySelector(`.cell_${xAxisValue + i}_${yAxisValue + (i * -1)}`);

                                // if blockingPiece is none then add
                                if (blockingPiece.innerHTML === ""){
                                    possibleMovements.push(`.cell_${xAxisValue + i}_${yAxisValue + (i * -1)}`);
                                } else {
                                    break;
                                }
                            } // end of for each statement
                        }

                        // up diagonally(up right)
                        if (diff_x_value < 0 && diff_y_value > 0) {
                            for(let i = 1; i <= abs_diff_y_value; i++){
                                let blockingPiece = document.querySelector(`.cell_${xAxisValue + (i * -1)}_${yAxisValue + i}`);

                                // if blockingPiece is none then add
                                if (blockingPiece.innerHTML === ""){
                                    possibleMovements.push(`.cell_${xAxisValue + (i * -1)}_${yAxisValue + i}`);
                                } else {
                                    break;
                                }
                            } // end of for each statement
                        }

                        // up diagonally(up left)
                        if (diff_x_value < 0 && diff_y_value < 0) {
                            for(let i = 1; i <= abs_diff_y_value; i++){
                                let blockingPiece = document.querySelector(`.cell_${xAxisValue + (i * -1)}_${yAxisValue + (i * -1)}`);

                                // if blockingPiece is none then add
                                if (blockingPiece.innerHTML === ""){
                                    possibleMovements.push(`.cell_${xAxisValue + (i * -1)}_${yAxisValue + (i * -1)}`);
                                } else {
                                    break;
                                }
                            } // end of for each statement
                        }

                    } // end of if newxAxisValue == xAxisValue statement
                    // end of Bishop movement


                
                    return possibleMovements;   
                }

                updatePosition(newCoordinates) {
                    this.position = newCoordinates;
                }

                // eating possibilities
                eatingPossibility(xAxisValue, yAxisValue, newxAxisValue, newyAxisValue) {
                    let possibleMovements = [];
                    let diff_x_value = newxAxisValue - xAxisValue;
                    let diff_y_value = newyAxisValue - yAxisValue;
                    let abs_diff_x_value = Math.abs(diff_x_value);
                    let abs_diff_y_value = Math.abs(diff_y_value);
                    let row_recNumber = 0;
                    let col_recNumber = 0;
                    let recNumber = 0;

                    // start of if newxAxisValue == xAxisValue statement
                    if(newxAxisValue == xAxisValue) {
                        if (yAxisValue < newyAxisValue) {
                            let yAxisValuePlusOne = parseInt(yAxisValue)+1;
                            recNumber = yAxisValuePlusOne;

                            for(let i = yAxisValuePlusOne; i < newyAxisValue; i++){
                                let blockingPiece = document.querySelector(`.cell_${newxAxisValue}_${i}`);

                                // if blockingPiece is none then add
                                if (blockingPiece.innerHTML === ""){
                                    possibleMovements.push(`.cell_${newxAxisValue}_${i}`);
                                } else {
                                    break;
                                }
                                recNumber++;
                            } // end of for each statement

                            if (recNumber == newyAxisValue) {
                                possibleMovements.push(`.cell_${newxAxisValue}_${recNumber}`);
                            }
                            
                        }

                        if (yAxisValue > newyAxisValue) {
                            let yAxisValueMinusOne = parseInt(yAxisValue)-1;
                            recNumber = yAxisValueMinusOne; 
                            for(let i = yAxisValueMinusOne; i > newyAxisValue; i--){
                                let blockingPiece = document.querySelector(`.cell_${newxAxisValue}_${i}`);

                                // if blockingPiece is none then add
                                if (blockingPiece.innerHTML === ""){
                                    possibleMovements.push(`.cell_${newxAxisValue}_${i}`);
                                } else {
                                    break;
                                }
                                recNumber--;
                            } // end of for each statement

                            if (recNumber == newyAxisValue) {
                                possibleMovements.push(`.cell_${newxAxisValue}_${recNumber}`);
                            }
                        }
                    } // end of if newxAxisValue == xAxisValue statement


                    // start of if newyAxisValue == yAxisValue statement
                    if(newyAxisValue == yAxisValue) {
                        if (xAxisValue < newxAxisValue) {
                            let xAxisValuePlusOne = parseInt(xAxisValue)+1;
                            recNumber = xAxisValuePlusOne;

                            for(let i = xAxisValuePlusOne; i < newxAxisValue; i++){
                                let blockingPiece = document.querySelector(`.cell_${i}_${newyAxisValue}`);

                                // if blockingPiece is none then add
                                if (blockingPiece.innerHTML === ""){
                                    possibleMovements.push(`.cell_${i}_${newyAxisValue}`);
                                } else {
                                    break;
                                }
                                recNumber++;
                            } // end of for each statement

                            if (recNumber == newxAxisValue) {
                                possibleMovements.push(`.cell_${recNumber}_${newyAxisValue}`);
                            }
                        }

                        if (xAxisValue > newxAxisValue) {
                            let xAxisValueMinusOne = parseInt(xAxisValue)-1;
                            recNumber = xAxisValueMinusOne;

                            for(let i = xAxisValueMinusOne; i > newxAxisValue; i--){
                                let blockingPiece = document.querySelector(`.cell_${i}_${newyAxisValue}`);

                                // if blockingPiece is none then add
                                if (blockingPiece.innerHTML === ""){
                                    possibleMovements.push(`.cell_${i}_${newyAxisValue}`);
                                } else {
                                    break;
                                }
                                recNumber--;
                            } // end of for each statement

                            if (recNumber == newxAxisValue) {
                                possibleMovements.push(`.cell_${recNumber}_${newyAxisValue}`);
                            }
                        }
                    } // end of if newyAxisValue == yAxisValue statement

                    if(abs_diff_x_value == abs_diff_y_value) {
                        // down diagonally(down right)
                        if (diff_x_value > 0 && diff_y_value > 0) {
                            for(let i = 1; i <= abs_diff_x_value; i++){
                                let blockingPiece = document.querySelector(`.cell_${xAxisValue + i}_${yAxisValue + i}`);
                                row_recNumber = xAxisValue + i;
                                col_recNumber = yAxisValue + i;

                                // if blockingPiece is none then add
                                if (blockingPiece.innerHTML === ""){
                                    possibleMovements.push(`.cell_${xAxisValue + i}_${yAxisValue + i}`);
                                } else {
                                    break;
                                }
                                
                            } // end of for each statement
                        }

                        // down diagonally(down left)
                        if (diff_x_value > 0 && diff_y_value < 0) {
                            for(let i = 1; i <= abs_diff_y_value; i++){
                                let blockingPiece = document.querySelector(`.cell_${xAxisValue + i}_${yAxisValue + (i * -1)}`);
                                row_recNumber = xAxisValue + i;
                                col_recNumber = yAxisValue + (i * -1);

                                // if blockingPiece is none then add
                                if (blockingPiece.innerHTML === ""){
                                    possibleMovements.push(`.cell_${xAxisValue + i}_${yAxisValue + (i * -1)}`);
                                    
                                } else {
                                    break;
                                }
                                
                            } // end of for each statement
                        }

                        // up diagonally(up right)
                        if (diff_x_value < 0 && diff_y_value > 0) {
                            for(let i = 1; i <= abs_diff_y_value; i++){
                                let blockingPiece = document.querySelector(`.cell_${xAxisValue + (i * -1)}_${yAxisValue + i}`);
                                row_recNumber = xAxisValue + (i * -1);
                                col_recNumber = yAxisValue + i;

                                // if blockingPiece is none then add
                                if (blockingPiece.innerHTML === ""){
                                    possibleMovements.push(`.cell_${xAxisValue + (i * -1)}_${yAxisValue + i}`);
                                    
                                } else {
                                    break;
                                }
                                
                            } // end of for each statement
                        }

                        // up diagonally(up left)
                        if (diff_x_value < 0 && diff_y_value < 0) {
                            for(let i = 1; i <= abs_diff_y_value; i++){
                                let blockingPiece = document.querySelector(`.cell_${xAxisValue + (i * -1)}_${yAxisValue + (i * -1)}`);
                                row_recNumber = xAxisValue + (i * -1);
                                col_recNumber = yAxisValue + (i * -1);

                                // if blockingPiece is none then add
                                if (blockingPiece.innerHTML === ""){
                                    possibleMovements.push(`.cell_${xAxisValue + (i * -1)}_${yAxisValue + (i * -1)}`);
                                    
                                } else {
                                    break;
                                }
                                
                            } // end of for each statement
                        }
                        if (row_recNumber == newxAxisValue && col_recNumber == newyAxisValue) {
                                possibleMovements.push(`.cell_${row_recNumber}_${col_recNumber}`);
                        }

                    }

                    return possibleMovements;

                }

                
            }
            // Queen Class end

            // King Class start
            class King {
                constructor (kingPosition, blackUp, color) {
                    this.position = kingPosition;
                    this.blackUp = blackUp;
                    this.color = color;
                    this.numberOfMoves = 0;
                }

                possibleMove(xAxisValue, yAxisValue, prediction) {
                    let possibleMovements = [];
                    let arr_col_recNumber = [];
                    let castlingCheck;
                    arr_col_recNumber.push(yAxisValue);
                    arr_col_recNumber.push(yAxisValue+1);
                    arr_col_recNumber.push(yAxisValue-1);

                    let i = 1;
                    
                    arr_col_recNumber.forEach((yAxisElement) => {
                        switch (i) {
                            case 1:
                                possibleMovements.push(`.cell_${xAxisValue+i}_${yAxisElement}`);
                            case 2:
                                possibleMovements.push(`.cell_${xAxisValue-1}_${yAxisElement}`);
                        }
                    });

                    possibleMovements.push(`.cell_${xAxisValue}_${yAxisValue+1}`);
                    possibleMovements.push(`.cell_${xAxisValue}_${yAxisValue-1}`);

                    if(this.numberOfMoves === 0) {
                        for (let i = 1; i < 3; i++) {
                            let leftPiece = document.querySelector(`.cell_${xAxisValue}_${yAxisValue-i}`);
                            let foundIdx = 0;
                            let numberOfMovedRook = 1;
                            // check left piece
                            if (!leftPiece.querySelector("img")){
                                // check out top
                                if ((this.blackUp  && this.color === "black") || (!this.blackUp  && this.color === "white")) {
                                    switch (this.color) {
                                        case "black":
                                            foundIdx = blackRookPieces.findIndex((rookClass) => {return rookClass.position === `.cell_${1}_${1}`});
                                            if (foundIdx !== -1) {
                                                numberOfMovedRook = blackRookPieces[foundIdx].numberOfMoves;
                                            }
                                            break;
                                        case "white":
                                            foundIdx = whiteRookPieces.findIndex((rookClass) => {return rookClass.position === `.cell_${1}_${1}`});
                                            if (foundIdx !== -1) {
                                                numberOfMovedRook = whiteRookPieces[foundIdx].numberOfMoves;
                                            }
                                            break;
                                    } // end of switch case
                                    
                                }

                                // check out down
                                if ((this.blackUp  && this.color === "white") || (!this.blackUp  && this.color === "black")) {
                                    switch (this.color) {
                                        case "black":
                                            foundIdx = blackRookPieces.findIndex((rookClass) => {return rookClass.position === `.cell_${8}_${1}`});
                                            if (foundIdx !== -1) {
                                                numberOfMovedRook = blackRookPieces[foundIdx].numberOfMoves;
                                            }
                                            break;
                                        case "white":
                                            foundIdx = whiteRookPieces.findIndex((rookClass) => {return rookClass.position === `.cell_${8}_${1}`});
                                            if (foundIdx !== -1) {
                                                numberOfMovedRook = whiteRookPieces[foundIdx].numberOfMoves;
                                            }
                                            break;
                                    } // end of switch case
                                    
                                }

                                castlingCheck = this.castlingVerification(xAxisValue, yAxisValue-i);
                                if (!castlingCheck && numberOfMovedRook === 0 && i === 2) {
                                    possibleMovements.push( `.cell_${xAxisValue}_${yAxisValue-i}`)
                                } // king is not in danger check

                                if (castlingCheck) {
                                    break;
                                }
                            } else {// check if left piece has an image
                                break;
                            }
                        
                        } // left piece done

                        // right piece check
                        for (let i = 1; i < 3; i++) {
                            let rightPiece = document.querySelector(`.cell_${xAxisValue}_${yAxisValue+i}`);
                            let foundIdx = 0;
                            let numberOfMovedRook = 1;
                            // check for right piece
                            if (!rightPiece.querySelector("img")){
                                // check out top
                                if ((this.blackUp  && this.color === "black") || (!this.blackUp  && this.color === "white")) {
                                    switch (this.color) {
                                        case "black":
                                            foundIdx = blackRookPieces.findIndex((rookClass) => {return rookClass.position === `.cell_${1}_${8}`});
                                            if (foundIdx !== -1) {
                                                numberOfMovedRook = blackRookPieces[foundIdx].numberOfMoves;
                                            }
                                            break;
                                        case "white":
                                            foundIdx = whiteRookPieces.findIndex((rookClass) => {return rookClass.position === `.cell_${1}_${8}`});
                                            if (foundIdx !== -1) {
                                                numberOfMovedRook = whiteRookPieces[foundIdx].numberOfMoves;
                                            }
                                            break;
                                    } // end of switch case
                                    
                                }

                                // check out down
                                if ((this.blackUp  && this.color === "white") || (!this.blackUp  && this.color === "black")) {
                                    switch (this.color) {
                                        case "black":
                                            foundIdx = blackRookPieces.findIndex((rookClass) => {return rookClass.position === `.cell_${8}_${8}`});
                                            if (foundIdx !== -1) {
                                                numberOfMovedRook = blackRookPieces[foundIdx].numberOfMoves;
                                            }
                                            break;
                                        case "white":
                                            foundIdx = whiteRookPieces.findIndex((rookClass) => {return rookClass.position === `.cell_${8}_${8}`});
                                            if (foundIdx !== -1) {
                                                numberOfMovedRook = whiteRookPieces[foundIdx].numberOfMoves;
                                            }
                                            break;
                                    } // end of switch case
                                    
                                }

                                castlingCheck = this.castlingVerification(xAxisValue, yAxisValue+i);
                                if (!castlingCheck && numberOfMovedRook === 0 && i === 2) {
                                    possibleMovements.push( `.cell_${xAxisValue}_${yAxisValue+i}`)
                                } // castling check
                                if (castlingCheck) {
                                    break;
                                }
                            } else { // check if right piece has an image  
                                break;
                            }
                        } // check for statement right piece

                    } // if number of king's move is 0

                    if (!prediction) {
                        this.numberOfMoves++;
                    }

                    return possibleMovements;
                } // end of possibleMove function

                // update position
                updatePosition(newCoordinates) {
                    this.position = newCoordinates;
                }

                checked(attackerPiece, attackerCoordinate, turn, attackerOriginalCoordinate) {
                    // variables
                    let attacker_xAxisValue = parseInt(attackerCoordinate.substr(6, 1));
                    let attacker_yAxisValue = parseInt(attackerCoordinate.substr(attackerCoordinate.length -1, 1));
                    let king_xAxisValue = parseInt(this.position.substr(6, 1));
                    let king_yAxisValue = parseInt(this.position.substr(this.position.length - 1, 1))
                    let attackerPieceName = attackerPiece.getAttribute('alt');
                    let diff_x_value = king_xAxisValue - attacker_xAxisValue;
                    let diff_y_value = king_yAxisValue - attacker_yAxisValue;
                    let abs_diff_x_value = Math.abs(diff_x_value);
                    let abs_diff_y_value = Math.abs(diff_y_value);
                    let abs_total_val = abs_diff_x_value + abs_diff_y_value;
                    let row_recNumber = 0;
                    let col_recNumber = 0;
                    let recNumber = 0;
                    let possibleMovements = [];
                    let isChecked = false;
                    let isCheckMate = false;

                    
                    // It Rook or Queen attack movement
                    if(attackerPieceName.includes("Rook") || attackerPieceName.includes("Queen")) {
                        if(attacker_xAxisValue == king_xAxisValue) {
                            if (attacker_yAxisValue < king_yAxisValue) {
                                let yAxisValuePlusOne = parseInt(attacker_yAxisValue)+1;
                                recNumber = yAxisValuePlusOne;

                                for(let i = yAxisValuePlusOne; i < king_yAxisValue; i++){
                                    let blockingPiece = document.querySelector(`.cell_${attacker_xAxisValue}_${i}`);

                                    // if blockingPiece is none then add
                                    if (blockingPiece.innerHTML === ""){
                                        possibleMovements.push(`.cell_${attacker_xAxisValue}_${i}`);
                                    } else {
                                        break;
                                    }
                                    recNumber++;
                                } // end of for each statement

                                if (recNumber == king_yAxisValue) {
                                    possibleMovements.push(`.cell_${attacker_xAxisValue}_${recNumber}`);
                                }
                                
                            }

                            if (attacker_yAxisValue > king_yAxisValue) {
                                let yAxisValueMinusOne = parseInt(attacker_yAxisValue)-1;
                                recNumber = yAxisValueMinusOne; 
                                for(let i = yAxisValueMinusOne; i > king_yAxisValue; i--){
                                    let blockingPiece = document.querySelector(`.cell_${attacker_xAxisValue}_${i}`);

                                    // if blockingPiece is none then add
                                    if (blockingPiece.innerHTML === ""){
                                        possibleMovements.push(`.cell_${attacker_xAxisValue}_${i}`);
                                    } else {
                                        break;
                                    }
                                    recNumber--;
                                } // end of for each statement

                                if (recNumber == king_yAxisValue) {
                                    possibleMovements.push(`.cell_${attacker_xAxisValue}_${recNumber}`);
                                }
                            }
                        } // end of if newxAxisValue == xAxisValue statement


                        // start of if newyAxisValue == yAxisValue statement
                        if(attacker_yAxisValue == king_yAxisValue) {
                            if (attacker_xAxisValue < king_xAxisValue) {
                                let xAxisValuePlusOne = parseInt(attacker_xAxisValue)+1;
                                recNumber = xAxisValuePlusOne;

                                for(let i = xAxisValuePlusOne; i < king_xAxisValue; i++){
                                    let blockingPiece = document.querySelector(`.cell_${i}_${attacker_yAxisValue}`);

                                    // if blockingPiece is none then add
                                    if (blockingPiece.innerHTML === ""){
                                        possibleMovements.push(`.cell_${i}_${attacker_yAxisValue}`);
                                    } else {
                                        break;
                                    }
                                    recNumber++;
                                } // end of for each statement

                                if (recNumber == king_xAxisValue) {
                                    possibleMovements.push(`.cell_${recNumber}_${attacker_yAxisValue}`);
                                }
                            }

                            if (attacker_xAxisValue > king_xAxisValue) {
                                let xAxisValueMinusOne = parseInt(attacker_xAxisValue)-1;
                                recNumber = xAxisValueMinusOne;

                                for(let i = xAxisValueMinusOne; i > king_xAxisValue; i--){
                                    let blockingPiece = document.querySelector(`.cell_${i}_${attacker_yAxisValue}`);

                                    // if blockingPiece is none then add
                                    if (blockingPiece.innerHTML === ""){
                                        possibleMovements.push(`.cell_${i}_${attacker_yAxisValue}`);
                                    } else {
                                        break;
                                    }
                                    recNumber--;
                                } // end of for each statement

                                if (recNumber == king_xAxisValue) {
                                    possibleMovements.push(`.cell_${recNumber}_${attacker_yAxisValue}`);
                                }
                            }
                        } // end of if newyAxisValue == yAxisValue statement
                       
                    } 

                    // Bishop or Queen Attacking Movement 
                    if (attackerPieceName.includes("Bishop") || attackerPieceName.includes("Queen")) {
                        if(abs_diff_x_value == abs_diff_y_value) {
                            // down diagonally(down right)
                            if (diff_x_value > 0 && diff_y_value > 0) {
                                for(let i = 1; i <= abs_diff_x_value; i++){
                                    let blockingPiece = document.querySelector(`.cell_${attacker_xAxisValue + i}_${attacker_yAxisValue + i}`);
                                    row_recNumber = attacker_xAxisValue + i;
                                    col_recNumber = attacker_yAxisValue + i;

                                    // if blockingPiece is none then add
                                    if (blockingPiece.innerHTML === ""){
                                        possibleMovements.push(`.cell_${attacker_xAxisValue + i}_${attacker_yAxisValue + i}`);
                                    } else {
                                        break;
                                    }
                                    
                                } // end of for each statement
                            }

                            // down diagonally(down left)
                            if (diff_x_value > 0 && diff_y_value < 0) {
                                for(let i = 1; i <= abs_diff_y_value; i++){
                                    let blockingPiece = document.querySelector(`.cell_${attacker_xAxisValue + i}_${attacker_yAxisValue + (i * -1)}`);
                                    row_recNumber = attacker_xAxisValue + i;
                                    col_recNumber = attacker_yAxisValue + (i * -1);

                                    // if blockingPiece is none then add
                                    if (blockingPiece.innerHTML === ""){
                                        possibleMovements.push(`.cell_${attacker_xAxisValue + i}_${attacker_yAxisValue + (i * -1)}`);
                                        
                                    } else {
                                        break;
                                    }
                                    
                                } // end of for each statement
                            }

                            // up diagonally(up right)
                            if (diff_x_value < 0 && diff_y_value > 0) {
                                for(let i = 1; i <= abs_diff_y_value; i++){
                                    let blockingPiece = document.querySelector(`.cell_${attacker_xAxisValue + (i * -1)}_${attacker_yAxisValue + i}`);
                                    row_recNumber = attacker_xAxisValue + (i * -1);
                                    col_recNumber = attacker_yAxisValue + i;

                                    // if blockingPiece is none then add
                                    if (blockingPiece.innerHTML === ""){
                                        possibleMovements.push(`.cell_${attacker_xAxisValue + (i * -1)}_${attacker_yAxisValue + i}`);
                                        
                                    } else {
                                        break;
                                    }
                                    
                                } // end of for each statement
                            }

                            // up diagonally(up left)
                            if (diff_x_value < 0 && diff_y_value < 0) {
                                for(let i = 1; i <= abs_diff_y_value; i++){
                                    let blockingPiece = document.querySelector(`.cell_${attacker_xAxisValue + (i * -1)}_${attacker_yAxisValue + (i * -1)}`);
                                    row_recNumber = attacker_xAxisValue + (i * -1);
                                    col_recNumber = attacker_yAxisValue + (i * -1);

                                    // if blockingPiece is none then add
                                    if (blockingPiece.innerHTML === ""){
                                        possibleMovements.push(`.cell_${attacker_xAxisValue + (i * -1)}_${attacker_yAxisValue + (i * -1)}`);
                                        
                                    } else {
                                        break;
                                    }
                                    
                                } // end of for each statement
                            }
                            if (row_recNumber == king_xAxisValue && col_recNumber == king_yAxisValue) {
                                    possibleMovements.push(`.cell_${row_recNumber}_${col_recNumber}`);
                            }

                        }
                    
                    }
                    // Knight attacking Movement 
                    if(attackerPieceName.includes("Knight")) {
                        if((abs_total_val == 3 && abs_diff_x_value !== 0) ||(abs_total_val == 3 && abs_diff_y_value !== 0)) {
                        // 2 down right and left
                            if (abs_diff_x_value == 2) {
                                possibleMovements.push(`.cell_${attacker_xAxisValue+2}_${attacker_yAxisValue+1}`);
                                possibleMovements.push(`.cell_${attacker_xAxisValue+2}_${attacker_yAxisValue-1}`);
                                possibleMovements.push(`.cell_${attacker_xAxisValue-2}_${attacker_yAxisValue+1}`);
                                possibleMovements.push(`.cell_${attacker_xAxisValue-2}_${attacker_yAxisValue-1}`);
                            } else if (abs_diff_x_value == 1) {
                                possibleMovements.push(`.cell_${attacker_xAxisValue+1}_${attacker_yAxisValue+2}`);
                                possibleMovements.push(`.cell_${attacker_xAxisValue+1}_${attacker_yAxisValue-2}`);
                                possibleMovements.push(`.cell_${attacker_xAxisValue-1}_${attacker_yAxisValue+2}`);
                                possibleMovements.push(`.cell_${attacker_xAxisValue-1}_${attacker_yAxisValue-2}`);
                            }
                        }
                    } 

                    // Pawn possible attacking movements
                    if(attackerPieceName.includes("Pawn")) {
                        if ((this.blackUp && attackerPieceName.includes("black")) || (!this.blackUp && attackerPieceName.includes("white"))) {
                            if (parseInt(attacker_yAxisValue) <= 8) {
                                possibleMovements.push(`.cell_${attacker_xAxisValue + 1}_${attacker_yAxisValue + 1}`);
                                possibleMovements.push(`.cell_${attacker_xAxisValue + 1}_${attacker_yAxisValue - 1}`);
                            }
                        }

                        if ((!this.blackUp && attackerPieceName.includes("black")) || (this.blackUp && attackerPieceName.includes("white"))) {
                            if (parseInt(attacker_yAxisValue) >= 1) {
                                possibleMovements.push(`.cell_${attacker_xAxisValue - 1}_${attacker_yAxisValue + 1}`);
                                possibleMovements.push(`.cell_${attacker_xAxisValue - 1}_${attacker_yAxisValue - 1}`);
                            }
                        }
                    // King attacking possible movements
                    } else if(attackerPieceName.includes("King")) {
                        possibleMovements = this.possibleMove(attacker_xAxisValue, attacker_yAxisValue, true);
                    }

                    possibleMovements.some((attackCoordinate) => {
                        if (attackCoordinate === this.position) {
                            isChecked = true;
                            isCheckMate = this.checkMate(king_xAxisValue, king_yAxisValue, attackerPiece, attackerCoordinate, attackerOriginalCoordinate);
                            return true;
                        } else {
                            return false;
                        }
                    });

                    if (isCheckMate) {
                        if(attackerPieceName.includes("white")) {
                            alert("CHECKMATE! White Won!");
                        } else if (attackerPieceName.includes("black")) {
                            alert("CHECKMATE! Black Won!");
                        }
                        
                        // Game Over start over
                        location.reload;
                    }

                    return isChecked;

                }

                checkMate(king_xAxisValue, king_yAxisValue, attackerPiece, attackerCoordinate, attackerOriginalCoordinate) {
                    let kingPossibleMovement = [];
                    let gettingEatenMovements = [];
                    kingPossibleMovement = this.possibleMove(king_xAxisValue, king_yAxisValue, true);
                    let originLength = kingPossibleMovement.length;
                    let foundIndex = 0;
                    let isCheckMate = true;
                    let counter = 0;
                    let attacker_xAxisValue = parseInt(attackerCoordinate.substr(6, 1));
                    let attacker_yAxisValue = parseInt(attackerCoordinate.substr(attackerCoordinate.length -1, 1));
                    let attackerPieceName = attackerPiece.getAttribute('alt');
                    let attackerOriginalCoordinate_xAxisValue = parseInt(attackerOriginalCoordinate.substr(6, 1));
                    let attackerOriginalCoordinate_yAxisValue = parseInt(attackerOriginalCoordinate.substr(attackerOriginalCoordinate.length - 1, 1));
                
                    // filtering out unnecessary movements
                    let j = 0;
                    while(j < originLength){
                        let xAxisValue = parseInt(kingPossibleMovement[j].substr(6, 1));
                        let yAxisValue = parseInt(kingPossibleMovement[j].substr(kingPossibleMovement[j].length - 1, 1));

                        if (xAxisValue == 0 || yAxisValue == 0 || xAxisValue == 9 || yAxisValue == 9){
                            kingPossibleMovement.splice(j, 1)
                            j--;
                            originLength = kingPossibleMovement.length;
                        }
                        j++;
                    }

                    // if there is same color next to it, filter out as well
                    j = 0;
                    while(j < originLength){
                        let xAxisValue = parseInt(kingPossibleMovement[j].substr(6, 1));
                        let yAxisValue = parseInt(kingPossibleMovement[j].substr(kingPossibleMovement[j].length - 1, 1));
                        let cell = document.querySelector(`.cell_${xAxisValue}_${yAxisValue}`);
                        if (cell.querySelector("img")){
                            let imageCell = cell.querySelector("img");
                            if ((imageCell.getAttribute('alt').includes("white") && this.color === "white") || (imageCell.getAttribute('alt').includes("black") && this.color === "black")) {
                                kingPossibleMovement.splice(j, 1);
                                j--;
                                originLength = kingPossibleMovement.length;
                            }
                        }
                        j++;
                    }

                    // Each king Movement
                    for(let i = 0; i < kingPossibleMovement.length; i++){
                        let eachMovement_xAxisValue = parseInt(kingPossibleMovement[i].substr(6, 1));
                        let eachMovement_yAxisValue = parseInt(kingPossibleMovement[i].substr(kingPossibleMovement[i].length -1, 1));
                        let isDangerous = false;
                        let needsBreak = false;

                        // check left start rook queen
                        if(eachMovement_yAxisValue == 1) {
                            
                        } else {
                            for(let i = eachMovement_yAxisValue - 1; i >= 1; i--) {
                                // if y axis value is one, then don't check left
                                let leftPiece = document.querySelector(`.cell_${eachMovement_xAxisValue}_${i}`)
                                
                                switch(i) {
                                    case eachMovement_yAxisValue - 1:
                                        if (leftPiece.querySelector("img")) {
                                            let leftImagePiece = leftPiece.querySelector("img");
                                            if((leftImagePiece.getAttribute('alt').includes("whiteRook") || leftImagePiece.getAttribute('alt').includes("whiteQueen") || leftImagePiece.getAttribute('alt').includes("whiteKing")) && (this.color === "black")) {
                                                gettingEatenMovements.push(true);
                                                needsBreak = true;
                                                isDangerous = true;
                                            } else if ((leftImagePiece.getAttribute('alt').includes("blackRook") || leftImagePiece.getAttribute('alt').includes("blackQueen") || leftImagePiece.getAttribute('alt').includes("blackKing")) && (this.color === "white")) {
                                                gettingEatenMovements.push(true);
                                                needsBreak = true;
                                                isDangerous = true;
                                            } else if ((leftImagePiece.getAttribute('alt').includes("black") && this.color === "black" && (!leftImagePiece.getAttribute('alt').includes("blackKing")) ) || (leftImagePiece.getAttribute('alt').includes("white") && this.color === "white" && (!leftImagePiece.getAttribute('alt').includes("whiteKing")))) {
                                                needsBreak = true;
                                                isDangerous = false;
                                            } else if (((!leftImagePiece.getAttribute('alt').includes("whiteRook")) && (!leftImagePiece.getAttribute('alt').includes("whiteQueen")) && (leftImagePiece.getAttribute('alt').includes("white")) && (this.color === "black")) || (((!leftImagePiece.getAttribute('alt').includes("blackRook")) && (!leftImagePiece.getAttribute('alt').includes("blackQueen")) && (leftImagePiece.getAttribute('alt').includes("black"))) && (this.color === "white"))) {  
                                                needsBreak = true;
                                                isDangerous = false;
                                            }
                                        } 
                                        break;
                                    default:
                                        if (leftPiece.querySelector("img")) {
                                            let leftImagePiece = leftPiece.querySelector("img");
                                            if((leftImagePiece.getAttribute('alt').includes("whiteRook") || leftImagePiece.getAttribute('alt').includes("whiteQueen")) && (this.color === "black")) {
                                                gettingEatenMovements.push(true);
                                                needsBreak = true;
                                                isDangerous = true;
                                            } else if ((leftImagePiece.getAttribute('alt').includes("blackRook") || leftImagePiece.getAttribute('alt').includes("blackQueen")) && (this.color === "white")) {
                                                gettingEatenMovements.push(true);
                                                needsBreak = true;
                                                isDangerous = true;
                                            } else if ((leftImagePiece.getAttribute('alt').includes("black") && this.color === "black" && (!leftImagePiece.getAttribute('alt').includes("blackKing")) ) || (leftImagePiece.getAttribute('alt').includes("white") && this.color === "white" && (!leftImagePiece.getAttribute('alt').includes("whiteKing")))) {
                                                needsBreak = true;
                                                isDangerous = false;
                                            } else if (((!leftImagePiece.getAttribute('alt').includes("whiteRook")) && (!leftImagePiece.getAttribute('alt').includes("whiteQueen")) && (leftImagePiece.getAttribute('alt').includes("white")) && (this.color === "black")) || (((!leftImagePiece.getAttribute('alt').includes("blackRook")) && (!leftImagePiece.getAttribute('alt').includes("blackQueen")) && (leftImagePiece.getAttribute('alt').includes("black"))) && (this.color === "white"))) {  
                                                needsBreak = true;
                                                isDangerous = false;
                                            }
                                        }
                                        
                                        break;
                                } // end of switch case

                                if (needsBreak) {
                                    break;
                                }
                                    
                            } // end of inner for each statement left side
                        } // check left finished

                        // if isDangerous is true then go to the next outer for each element of loop so continue
                        if (isDangerous) {
                            continue;
                        }
                        
                        // start over
                        needsBreak = false;
                        isDangerous = false;

                        // check right rook and queen
                        if(eachMovement_yAxisValue == 8) {
                            
                        } else {
                            for(let i = eachMovement_yAxisValue + 1; i <= 8; i++) {
                                let rightPiece = document.querySelector(`.cell_${eachMovement_xAxisValue}_${i}`)
                                
                                switch(i) {
                                    case eachMovement_yAxisValue + 1:
                                        if (rightPiece.querySelector("img")) {
                                            let rightImagePiece = rightPiece.querySelector("img");
                                            if((rightImagePiece.getAttribute('alt').includes("whiteRook") || rightImagePiece.getAttribute('alt').includes("whiteQueen") || rightImagePiece.getAttribute('alt').includes("whiteKing")) && (this.color === "black")) {
                                                gettingEatenMovements.push(true);
                                                needsBreak = true;
                                                isDangerous = true;
                                            } else if ((rightImagePiece.getAttribute('alt').includes("blackRook") || rightImagePiece.getAttribute('alt').includes("blackQueen") || rightImagePiece.getAttribute('alt').includes("blackKing")) && (this.color === "white")) {
                                                gettingEatenMovements.push(true);
                                                needsBreak = true;
                                                isDangerous = true;
                                            } else if ((rightImagePiece.getAttribute('alt').includes("black") && this.color === "black" && (!rightImagePiece.getAttribute('alt').includes("blackKing")) ) || (rightImagePiece.getAttribute('alt').includes("white") && this.color === "white" && (!rightImagePiece.getAttribute('alt').includes("whiteKing")))) {
                                                needsBreak = true;
                                                isDangerous = false;
                                            } else if (((!rightImagePiece.getAttribute('alt').includes("whiteRook")) && (!rightImagePiece.getAttribute('alt').includes("whiteQueen")) && (rightImagePiece.getAttribute('alt').includes("white")) && (this.color === "black")) || (((!rightImagePiece.getAttribute('alt').includes("blackRook")) && (!rightImagePiece.getAttribute('alt').includes("blackQueen")) && (rightImagePiece.getAttribute('alt').includes("black"))) && (this.color === "white"))) {  
                                                needsBreak = true;
                                                isDangerous = false;
                                            }
                                        } 
                                        break;
                                    default:
                                        if (rightPiece.querySelector("img")) {
                                            let rightImagePiece = rightPiece.querySelector("img");
                                            if((rightImagePiece.getAttribute('alt').includes("whiteRook") || rightImagePiece.getAttribute('alt').includes("whiteQueen")) && (this.color === "black")) {
                                                gettingEatenMovements.push(true);
                                                needsBreak = true;
                                                isDangerous = true;
                                            } else if ((rightImagePiece.getAttribute('alt').includes("blackRook") || rightImagePiece.getAttribute('alt').includes("blackQueen")) && (this.color === "white")) {
                                                gettingEatenMovements.push(true);
                                                needsBreak = true;
                                                isDangerous = true;
                                            } else if ((rightImagePiece.getAttribute('alt').includes("black") && this.color === "black" && (!rightImagePiece.getAttribute('alt').includes("blackKing")) ) || (rightImagePiece.getAttribute('alt').includes("white") && this.color === "white" && (!rightImagePiece.getAttribute('alt').includes("whiteKing")))) {
                                                needsBreak = true;
                                                isDangerous = false;
                                            } else if (((!rightImagePiece.getAttribute('alt').includes("whiteRook")) && (!rightImagePiece.getAttribute('alt').includes("whiteQueen")) && (rightImagePiece.getAttribute('alt').includes("white")) && (this.color === "black")) || (((!rightImagePiece.getAttribute('alt').includes("blackRook")) && (!rightImagePiece.getAttribute('alt').includes("blackQueen")) && (rightImagePiece.getAttribute('alt').includes("black"))) && (this.color === "white"))) {  
                                                needsBreak = true;
                                                isDangerous = false;
                                            }
                                        }
                                        
                                        break;
                                } // end of switch case

                                if (needsBreak) {
                                    break;
                                }

                            } // end of inner for each statement
                        } // End of checking right side statement

                        // if isDangerous is true then go to the next outer for each element of loop so continue
                        if (isDangerous) {
                            continue;
                        }
                        
                        // start over
                        needsBreak = false;
                        isDangerous = false;

                        // check up rook and queen
                        if(eachMovement_xAxisValue == 1) {
                            
                        } else {
                            for(let i = eachMovement_xAxisValue - 1; i >= 1; i--) {
                                let upPiece = document.querySelector(`.cell_${i}_${eachMovement_yAxisValue}`)
                                
                                switch(i) {
                                    case eachMovement_xAxisValue - 1:
                                        if (upPiece.querySelector("img")) {
                                            let upImagePiece = upPiece.querySelector("img");
                                            if((upImagePiece.getAttribute('alt').includes("whiteRook") || upImagePiece.getAttribute('alt').includes("whiteQueen") || upImagePiece.getAttribute('alt').includes("whiteKing")) && (this.color === "black")) {
                                                gettingEatenMovements.push(true);
                                                needsBreak = true;
                                                isDangerous = true;
                                            } else if ((upImagePiece.getAttribute('alt').includes("blackRook") || upImagePiece.getAttribute('alt').includes("blackQueen") || upImagePiece.getAttribute('alt').includes("blackKing")) && (this.color === "white")) {
                                                gettingEatenMovements.push(true);
                                                needsBreak = true;
                                                isDangerous = true;
                                            } else if ((upImagePiece.getAttribute('alt').includes("black") && this.color === "black" && (!upImagePiece.getAttribute('alt').includes("blackKing")) ) || (upImagePiece.getAttribute('alt').includes("white") && this.color === "white" && (!upImagePiece.getAttribute('alt').includes("whiteKing")))) {
                                                needsBreak = true;
                                                isDangerous = false;
                                            } else if (((!upImagePiece.getAttribute('alt').includes("whiteRook")) && (!upImagePiece.getAttribute('alt').includes("whiteQueen")) && (upImagePiece.getAttribute('alt').includes("white")) && (this.color === "black")) || (((!upImagePiece.getAttribute('alt').includes("blackRook")) && (!upImagePiece.getAttribute('alt').includes("blackQueen")) && (upImagePiece.getAttribute('alt').includes("black"))) && (this.color === "white"))) {  
                                                needsBreak = true;
                                                isDangerous = false;
                                            }
                                        } 
                                        break;
                                    default:
                                        if (upPiece.querySelector("img")) {
                                            let upImagePiece = upPiece.querySelector("img");
                                            if((upImagePiece.getAttribute('alt').includes("whiteRook") || upImagePiece.getAttribute('alt').includes("whiteQueen")) && (this.color === "black")) {
                                                gettingEatenMovements.push(true);
                                                needsBreak = true;
                                                isDangerous = true;
                                            } else if ((upImagePiece.getAttribute('alt').includes("blackRook") || upImagePiece.getAttribute('alt').includes("blackQueen")) && (this.color === "white")) {
                                                gettingEatenMovements.push(true);
                                                needsBreak = true;
                                                isDangerous = true;
                                            } else if ((upImagePiece.getAttribute('alt').includes("black") && this.color === "black" && (!upImagePiece.getAttribute('alt').includes("blackKing")) ) || (upImagePiece.getAttribute('alt').includes("white") && this.color === "white" && (!upImagePiece.getAttribute('alt').includes("whiteKing")))) {
                                                needsBreak = true;
                                                isDangerous = false;
                                            } else if (((!upImagePiece.getAttribute('alt').includes("whiteRook")) && (!upImagePiece.getAttribute('alt').includes("whiteQueen")) && (upImagePiece.getAttribute('alt').includes("white")) && (this.color === "black")) || (((!upImagePiece.getAttribute('alt').includes("blackRook")) && (!upImagePiece.getAttribute('alt').includes("blackQueen")) && (upImagePiece.getAttribute('alt').includes("black"))) && (this.color === "white"))) {  
                                                needsBreak = true;
                                                isDangerous = false;
                                            }
                                        }
                                        
                                        break;
                                } // end of switch case

                                if (needsBreak) {
                                    break;
                                }

                            } // end of for each statement
                        } // End of checking up side statement

                        // if isDangerous is true then go to the next outer for each element of loop so continue
                        if (isDangerous) {
                            continue;
                        }
                        
                        // start over
                        needsBreak = false;
                        isDangerous = false;

                        // check down side statement queen and rook
                        if(eachMovement_xAxisValue == 8) {
                            
                        } else {
                            for(let i = eachMovement_xAxisValue + 1; i <= 8; i++) {
                                let downPiece = document.querySelector(`.cell_${i}_${eachMovement_yAxisValue}`)
                                
                                switch(i) {
                                    case eachMovement_xAxisValue + 1:
                                        if (downPiece.querySelector("img")) {
                                            let downImagePiece = downPiece.querySelector("img");
                                            if((downImagePiece.getAttribute('alt').includes("whiteRook") || downImagePiece.getAttribute('alt').includes("whiteQueen") || downImagePiece.getAttribute('alt').includes("whiteKing")) && (this.color === "black")) {
                                                gettingEatenMovements.push(true);
                                                needsBreak = true;
                                                isDangerous = true;
                                            } else if ((downImagePiece.getAttribute('alt').includes("blackRook") || downImagePiece.getAttribute('alt').includes("blackQueen") || downImagePiece.getAttribute('alt').includes("blackKing")) && (this.color === "white")) {
                                                gettingEatenMovements.push(true);
                                                needsBreak = true;
                                                isDangerous = true;
                                            } else if ((downImagePiece.getAttribute('alt').includes("black") && this.color === "black" && (!downImagePiece.getAttribute('alt').includes("blackKing")) ) || (downImagePiece.getAttribute('alt').includes("white") && this.color === "white" && (!downImagePiece.getAttribute('alt').includes("whiteKing")))) {
                                                needsBreak = true;
                                                isDangerous = false;
                                            } else if (((!downImagePiece.getAttribute('alt').includes("whiteRook")) && (!downImagePiece.getAttribute('alt').includes("whiteQueen")) && (downImagePiece.getAttribute('alt').includes("white")) && (this.color === "black")) || (((!downImagePiece.getAttribute('alt').includes("blackRook")) && (!downImagePiece.getAttribute('alt').includes("blackQueen")) && (downImagePiece.getAttribute('alt').includes("black"))) && (this.color === "white"))) {  
                                                needsBreak = true;
                                                isDangerous = false;
                                            }
                                        } 
                                        break;
                                    default:
                                        if (downPiece.querySelector("img")) {
                                            let downImagePiece = downPiece.querySelector("img");
                                            if((downImagePiece.getAttribute('alt').includes("whiteRook") || downImagePiece.getAttribute('alt').includes("whiteQueen")) && (this.color === "black")) {
                                                gettingEatenMovements.push(true);
                                                needsBreak = true;
                                                isDangerous = true;
                                            } else if ((downImagePiece.getAttribute('alt').includes("blackRook") || downImagePiece.getAttribute('alt').includes("blackQueen")) && (this.color === "white")) {
                                                gettingEatenMovements.push(true);
                                                needsBreak = true;
                                                isDangerous = true;
                                            } else if ((downImagePiece.getAttribute('alt').includes("black") && this.color === "black" && (!downImagePiece.getAttribute('alt').includes("blackKing")) ) || (downImagePiece.getAttribute('alt').includes("white") && this.color === "white" && (!downImagePiece.getAttribute('alt').includes("whiteKing")))) {
                                                needsBreak = true;
                                                isDangerous = false;
                                            } else if (((!downImagePiece.getAttribute('alt').includes("whiteRook")) && (!downImagePiece.getAttribute('alt').includes("whiteQueen")) && (downImagePiece.getAttribute('alt').includes("white")) && (this.color === "black")) || (((!downImagePiece.getAttribute('alt').includes("blackRook")) && (!downImagePiece.getAttribute('alt').includes("blackQueen")) && (downImagePiece.getAttribute('alt').includes("black"))) && (this.color === "white"))) {  
                                                needsBreak = true;
                                                isDangerous = false;
                                            }
                                        }
                                        
                                        break;
                                } // end of switch case

                                if (needsBreak) {
                                    break;
                                }
                            } // end of for each statement
                        } // End of checking down side statement

                        // if isDangerous is true then go to the next outer for each element of loop so continue
                        if (isDangerous) {
                            continue;
                        }
                        
                        // start over
                        needsBreak = false;
                        isDangerous = false;

                        // Checking diagonally left down
                        if(eachMovement_yAxisValue == 1 || eachMovement_xAxisValue == 8) {
                           
                        } else {
                            for(let i = 1; i <= 8; i++) {
                                if (eachMovement_xAxisValue+i > 8 || eachMovement_yAxisValue-i < 1) {
                                    break;
                                }
                                let leftDownPiece = document.querySelector(`.cell_${eachMovement_xAxisValue+i}_${eachMovement_yAxisValue-i}`)
                                
                                switch(i) {
                                    case 1:
                                        if (leftDownPiece.querySelector("img")) {
                                            let leftDownImagePiece = leftDownPiece.querySelector("img");
                                            if((leftDownImagePiece.getAttribute('alt').includes("whiteBishop") || leftDownImagePiece.getAttribute('alt').includes("whiteQueen") || leftDownImagePiece.getAttribute('alt').includes("whiteKing")) && (this.color === "black")) {
                                                gettingEatenMovements.push(true);
                                                needsBreak = true;
                                                isDangerous = true;
                                            } else if ((leftDownImagePiece.getAttribute('alt').includes("blackBishop") || leftDownImagePiece.getAttribute('alt').includes("blackQueen") || leftDownImagePiece.getAttribute('alt').includes("blackKing")) && (this.color === "white")) {
                                                gettingEatenMovements.push(true);
                                                needsBreak = true;
                                                isDangerous = true;
                                            } else if (((leftDownImagePiece.getAttribute('alt').includes("blackPawn") && this.color === "white") && (!this.blackUp)) || ((leftDownImagePiece.getAttribute('alt').includes("whitePawn") && this.color === "black") && (this.blackUp))) {
                                                gettingEatenMovements.push(true);
                                                needsBreak = true;
                                                isDangerous = true;
                                            } else if ((leftDownImagePiece.getAttribute('alt').includes("black") && this.color === "black" && (!leftDownImagePiece.getAttribute('alt').includes("blackKing")) ) || (leftDownImagePiece.getAttribute('alt').includes("white") && this.color === "white" && (!leftDownImagePiece.getAttribute('alt').includes("whiteKing")))) {
                                                needsBreak = true;
                                                isDangerous = false;
                                            } else if (((!leftDownImagePiece.getAttribute('alt').includes("whiteBishop")) && (!leftDownImagePiece.getAttribute('alt').includes("whiteQueen")) && (leftDownImagePiece.getAttribute('alt').includes("white")) && (this.color === "black")) || (((!leftDownImagePiece.getAttribute('alt').includes("blackBishop")) && (!leftDownImagePiece.getAttribute('alt').includes("blackQueen")) && (leftDownImagePiece.getAttribute('alt').includes("black"))) && (this.color === "white"))) {  
                                                needsBreak = true;
                                                isDangerous = false;
                                            }

                                        } 
                                        break;
                                    default:
                                        if (leftDownPiece.querySelector("img")) {
                                            let leftDownImagePiece = leftDownPiece.querySelector("img");
                                            if((leftDownImagePiece.getAttribute('alt').includes("whiteBishop") || leftDownImagePiece.getAttribute('alt').includes("whiteQueen")) && (this.color === "black")) {
                                                gettingEatenMovements.push(true);
                                                needsBreak = true;
                                                isDangerous = true;
                                            } else if ((leftDownImagePiece.getAttribute('alt').includes("blackBishop") || leftDownImagePiece.getAttribute('alt').includes("blackQueen")) && (this.color === "white")) {
                                                gettingEatenMovements.push(true);
                                                needsBreak = true;
                                                isDangerous = true;
                                            } else if ((leftDownImagePiece.getAttribute('alt').includes("black") && this.color === "black" && (!leftDownImagePiece.getAttribute('alt').includes("blackKing")) ) || (leftDownImagePiece.getAttribute('alt').includes("white") && this.color === "white" && (!leftDownImagePiece.getAttribute('alt').includes("whiteKing")))) {
                                                needsBreak = true;
                                                isDangerous = false;
                                            } else if (((!leftDownImagePiece.getAttribute('alt').includes("whiteBishop")) && (!leftDownImagePiece.getAttribute('alt').includes("whiteQueen")) && (leftDownImagePiece.getAttribute('alt').includes("white")) && (this.color === "black")) || (((!leftDownImagePiece.getAttribute('alt').includes("blackBishop")) && (!leftDownImagePiece.getAttribute('alt').includes("blackQueen")) && (leftDownImagePiece.getAttribute('alt').includes("black"))) && (this.color === "white"))) {  
                                                needsBreak = true;
                                                isDangerous = false;
                                            }
                                        }
                                        break;
                                } // end of switch case
                                if (needsBreak) {
                                    break;
                                }    
                            } // diagonal left down for each statement
                        } // diagonal left down finished

                        if (isDangerous) {
                            continue;
                        }
                        
                        // start over
                        needsBreak = false;
                        isDangerous = false;

                        // checking diagonally right down
                        if(eachMovement_yAxisValue == 8 || eachMovement_xAxisValue == 8) {
                            
                        } else {
                            for(let i = 1; i <= 8; i++) {
                                if (eachMovement_xAxisValue+i > 8 || eachMovement_yAxisValue+i > 8) {
                                    break;
                                }

                                let rightDownPiece = document.querySelector(`.cell_${eachMovement_xAxisValue+i}_${eachMovement_yAxisValue+i}`)
                                
                                switch(i) {
                                    case 1:
                                        if (rightDownPiece.querySelector("img")) {
                                            let rightDownImagePiece = rightDownPiece.querySelector("img");
                                            if((rightDownImagePiece.getAttribute('alt').includes("whiteBishop") || rightDownImagePiece.getAttribute('alt').includes("whiteQueen") || rightDownImagePiece.getAttribute('alt').includes("whiteKing")) && (this.color === "black")) {
                                                gettingEatenMovements.push(true);
                                                needsBreak = true;
                                                isDangerous = true;
                                            } else if ((rightDownImagePiece.getAttribute('alt').includes("blackBishop") || rightDownImagePiece.getAttribute('alt').includes("blackQueen") || rightDownImagePiece.getAttribute('alt').includes("blackKing")) && (this.color === "white")) {
                                                gettingEatenMovements.push(true);
                                                needsBreak = true;
                                                isDangerous = true;
                                            } else if (((rightDownImagePiece.getAttribute('alt').includes("blackPawn") && this.color === "white") && (!this.blackUp)) || ((rightDownImagePiece.getAttribute('alt').includes("whitePawn") && this.color === "black") && (this.blackUp))) {
                                                gettingEatenMovements.push(true);
                                                needsBreak = true;
                                                isDangerous = true;
                                            } else if ((rightDownImagePiece.getAttribute('alt').includes("black") && this.color === "black" && (!rightDownImagePiece.getAttribute('alt').includes("blackKing")) ) || (rightDownImagePiece.getAttribute('alt').includes("white") && this.color === "white" && (!rightDownImagePiece.getAttribute('alt').includes("whiteKing")))) {
                                                needsBreak = true;
                                                isDangerous = false;
                                            } else if (((!rightDownImagePiece.getAttribute('alt').includes("whiteBishop")) && (!rightDownImagePiece.getAttribute('alt').includes("whiteQueen")) && (rightDownImagePiece.getAttribute('alt').includes("white")) && (this.color === "black")) || (((!rightDownImagePiece.getAttribute('alt').includes("blackBishop")) && (!rightDownImagePiece.getAttribute('alt').includes("blackQueen")) && (rightDownImagePiece.getAttribute('alt').includes("black"))) && (this.color === "white"))) {  
                                                needsBreak = true;
                                                isDangerous = false;
                                            }
                                        } 
                                        break;
                                    default:
                                        if (rightDownPiece.querySelector("img")) {
                                            let rightDownImagePiece = rightDownPiece.querySelector("img");
                                            if((rightDownImagePiece.getAttribute('alt').includes("whiteBishop") || rightDownImagePiece.getAttribute('alt').includes("whiteQueen")) && (this.color === "black")) {
                                                gettingEatenMovements.push(true);
                                                needsBreak = true;
                                                isDangerous = true;
                                            } else if ((rightDownImagePiece.getAttribute('alt').includes("blackBishop") || rightDownImagePiece.getAttribute('alt').includes("blackQueen")) && (this.color === "white")) {
                                                gettingEatenMovements.push(true);
                                                needsBreak = true;
                                                isDangerous = true;
                                            } else if ((rightDownImagePiece.getAttribute('alt').includes("black") && this.color === "black" && (!rightDownImagePiece.getAttribute('alt').includes("blackKing")) ) || (rightDownImagePiece.getAttribute('alt').includes("white") && this.color === "white" && (!rightDownImagePiece.getAttribute('alt').includes("whiteKing")))) {
                                                needsBreak = true;
                                                isDangerous = false;
                                            } else if (((!rightDownImagePiece.getAttribute('alt').includes("whiteBishop")) && (!rightDownImagePiece.getAttribute('alt').includes("whiteQueen")) && (rightDownImagePiece.getAttribute('alt').includes("white")) && (this.color === "black")) || (((!rightDownImagePiece.getAttribute('alt').includes("blackBishop")) && (!rightDownImagePiece.getAttribute('alt').includes("blackQueen")) && (rightDownImagePiece.getAttribute('alt').includes("black"))) && (this.color === "white"))) {  
                                                needsBreak = true;
                                                isDangerous = false;
                                            }
                                        }
                                        
                                        break;
                                } // end of switch case

                                if (needsBreak) {
                                    break;
                                }
                            } // end of for each statement
                        } // End of checking diagonally right down side statement

                        if (isDangerous) {
                            continue;
                        }
                        
                        // start over
                        needsBreak = false;
                        isDangerous = false;


                        // diagonal up left checking
                        if(eachMovement_yAxisValue == 1 || eachMovement_xAxisValue == 1) {
                            
                        } else {
                            for(let i = 1; i <= 8; i++) {
                                if (eachMovement_xAxisValue-i < 1 || eachMovement_yAxisValue-i < 1) {
                                    break;
                                }

                                let upLeftPiece = document.querySelector(`.cell_${eachMovement_xAxisValue-i}_${eachMovement_yAxisValue-i}`)
                                
                                switch(i) {
                                    case 1:
                                        if (upLeftPiece.querySelector("img")) {
                                            let upLeftImagePiece = upLeftPiece.querySelector("img");
                                            if((upLeftImagePiece.getAttribute('alt').includes("whiteBishop") || upLeftImagePiece.getAttribute('alt').includes("whiteQueen") || upLeftImagePiece.getAttribute('alt').includes("whiteKing")) && (this.color === "black")) {
                                                gettingEatenMovements.push(true);
                                                needsBreak = true;
                                                isDangerous = true;
                                            } else if ((upLeftImagePiece.getAttribute('alt').includes("blackBishop") || upLeftImagePiece.getAttribute('alt').includes("blackQueen") || upLeftImagePiece.getAttribute('alt').includes("blackKing")) && (this.color === "white")) {
                                                gettingEatenMovements.push(true);
                                                needsBreak = true;
                                                isDangerous = true;
                                            } else if (((upLeftImagePiece.getAttribute('alt').includes("blackPawn") && this.color === "white") && (this.blackUp)) || ((upLeftImagePiece.getAttribute('alt').includes("whitePawn") && this.color === "black") && (!this.blackUp))) {
                                                gettingEatenMovements.push(true);
                                                needsBreak = true;
                                                isDangerous = true;
                                            } else if ((upLeftImagePiece.getAttribute('alt').includes("black") && this.color === "black" && (!upLeftImagePiece.getAttribute('alt').includes("blackKing")) ) || (upLeftImagePiece.getAttribute('alt').includes("white") && this.color === "white" && (!upLeftImagePiece.getAttribute('alt').includes("whiteKing")))) {
                                                needsBreak = true;
                                                isDangerous = false;
                                            } else if (((!upLeftImagePiece.getAttribute('alt').includes("whiteBishop")) && (!upLeftImagePiece.getAttribute('alt').includes("whiteQueen")) && (upLeftImagePiece.getAttribute('alt').includes("white")) && (this.color === "black")) || (((!upLeftImagePiece.getAttribute('alt').includes("blackBishop")) && (!upLeftImagePiece.getAttribute('alt').includes("blackQueen")) && (upLeftImagePiece.getAttribute('alt').includes("black"))) && (this.color === "white"))) {  
                                                needsBreak = true;
                                                isDangerous = false;
                                            }
                                        } 
                                        break;
                                    default:
                                        if (upLeftPiece.querySelector("img")) {
                                            let upLeftImagePiece = upLeftPiece.querySelector("img");
                                            if((upLeftImagePiece.getAttribute('alt').includes("whiteBishop") || upLeftImagePiece.getAttribute('alt').includes("whiteQueen")) && (this.color === "black")) {
                                                gettingEatenMovements.push(true);
                                                needsBreak = true;
                                                isDangerous = true;
                                            } else if ((upLeftImagePiece.getAttribute('alt').includes("blackBishop") || upLeftImagePiece.getAttribute('alt').includes("blackQueen")) && (this.color === "white")) {
                                                gettingEatenMovements.push(true);
                                                needsBreak = true;
                                                isDangerous = true;
                                            } else if ((upLeftImagePiece.getAttribute('alt').includes("black") && this.color === "black" && (!upLeftImagePiece.getAttribute('alt').includes("blackKing")) ) || (upLeftImagePiece.getAttribute('alt').includes("white") && this.color === "white" && (!upLeftImagePiece.getAttribute('alt').includes("whiteKing")))) {
                                                needsBreak = true;
                                                isDangerous = false;
                                            } else if (((!upLeftImagePiece.getAttribute('alt').includes("whiteBishop")) && (!upLeftImagePiece.getAttribute('alt').includes("whiteQueen")) && (upLeftImagePiece.getAttribute('alt').includes("white")) && (this.color === "black")) || (((!upLeftImagePiece.getAttribute('alt').includes("blackBishop")) && (!upLeftImagePiece.getAttribute('alt').includes("blackQueen")) && (upLeftImagePiece.getAttribute('alt').includes("black"))) && (this.color === "white"))) {  
                                                needsBreak = true;
                                                isDangerous = false;
                                            }
                                        }
                                        
                                        break;
                                } // end of switch case

                                if (needsBreak) {
                                    break;
                                }

                            } // end of for each statement
                        } // End of checking diagonally up left side statement

                        if (isDangerous) {
                            continue;
                        }
                        
                        // start over
                        needsBreak = false;
                        isDangerous = false;

                        // check diagonally up right
                        if(eachMovement_yAxisValue == 8 || eachMovement_xAxisValue == 1) {
                            
                        } else {
                            for(let i = 1; i <= 8; i++) {
                                if (eachMovement_xAxisValue-i < 1 || eachMovement_yAxisValue+i > 8) {
                                    break;
                                }

                                let upRightPiece = document.querySelector(`.cell_${eachMovement_xAxisValue-i}_${eachMovement_yAxisValue+i}`)
                                
                                switch(i) {
                                    case 1:
                                        if (upRightPiece.querySelector("img")) {
                                            let upRightImagePiece = upRightPiece.querySelector("img");
                                            if((upRightImagePiece.getAttribute('alt').includes("whiteBishop") || upRightImagePiece.getAttribute('alt').includes("whiteQueen") || upRightImagePiece.getAttribute('alt').includes("whiteKing")) && (this.color === "black")) {
                                                gettingEatenMovements.push(true);
                                                needsBreak = true;
                                                isDangerous = true;
                                            } else if ((upRightImagePiece.getAttribute('alt').includes("blackBishop") || upRightImagePiece.getAttribute('alt').includes("blackQueen") || upRightImagePiece.getAttribute('alt').includes("blackKing")) && (this.color === "white")) {
                                                gettingEatenMovements.push(true);
                                                needsBreak = true;
                                                isDangerous = true;
                                            } else if (((upRightImagePiece.getAttribute('alt').includes("blackPawn") && this.color === "white") && (this.blackUp)) || ((upRightImagePiece.getAttribute('alt').includes("whitePawn") && this.color === "black") && (!this.blackUp))) {
                                                gettingEatenMovements.push(true);
                                                needsBreak = true;
                                                isDangerous = true;
                                            } else if ((upRightImagePiece.getAttribute('alt').includes("black") && this.color === "black" && (!upRightImagePiece.getAttribute('alt').includes("blackKing")) ) || (upRightImagePiece.getAttribute('alt').includes("white") && this.color === "white" && (!upRightImagePiece.getAttribute('alt').includes("whiteKing")))) {
                                                needsBreak = true;
                                                isDangerous = false;
                                            } else if (((!upRightImagePiece.getAttribute('alt').includes("whiteBishop")) && (!upRightImagePiece.getAttribute('alt').includes("whiteQueen")) && (upRightImagePiece.getAttribute('alt').includes("white")) && (this.color === "black")) || (((!upRightImagePiece.getAttribute('alt').includes("blackBishop")) && (!upRightImagePiece.getAttribute('alt').includes("blackQueen")) && (upRightImagePiece.getAttribute('alt').includes("black"))) && (this.color === "white"))) {  
                                                needsBreak = true;
                                                isDangerous = false;
                                            }
                                        } 
                                        break;
                                    default:
                                        if (upRightPiece.querySelector("img")) {
                                            let upRightImagePiece = upRightPiece.querySelector("img");
                                            if((upRightImagePiece.getAttribute('alt').includes("whiteBishop") || upRightImagePiece.getAttribute('alt').includes("whiteQueen")) && (this.color === "black")) {
                                                gettingEatenMovements.push(true);
                                                needsBreak = true;
                                                isDangerous = true;
                                            } else if ((upRightImagePiece.getAttribute('alt').includes("blackBishop") || upRightImagePiece.getAttribute('alt').includes("blackQueen")) && (this.color === "white")) {
                                                gettingEatenMovements.push(true);
                                                needsBreak = true;
                                                isDangerous = true;
                                            } else if ((upRightImagePiece.getAttribute('alt').includes("black") && this.color === "black" && (!upRightImagePiece.getAttribute('alt').includes("blackKing")) ) || (upRightImagePiece.getAttribute('alt').includes("white") && this.color === "white" && (!upRightImagePiece.getAttribute('alt').includes("whiteKing")))) {
                                                needsBreak = true;
                                                isDangerous = false;
                                            } else if (((!upRightImagePiece.getAttribute('alt').includes("whiteBishop")) && (!upRightImagePiece.getAttribute('alt').includes("whiteQueen")) && (upRightImagePiece.getAttribute('alt').includes("white")) && (this.color === "black")) || (((!upRightImagePiece.getAttribute('alt').includes("blackBishop")) && (!upRightImagePiece.getAttribute('alt').includes("blackQueen")) && (upRightImagePiece.getAttribute('alt').includes("black"))) && (this.color === "white"))) {  
                                                needsBreak = true;
                                                isDangerous = false;
                                            }
                                        }
                                        
                                        break;
                                } // end of switch case

                                if (needsBreak) {
                                    break;
                                }
                            } // end of for each statement
                        } // End of checking diagonally up left side statement

                        if (isDangerous) {
                            continue;
                        }
                        
                        // start over
                        needsBreak = false;
                        isDangerous = false;

                        // Check left side if enemy Knight is there
                        if(eachMovement_xAxisValue-1 >= 1 && eachMovement_yAxisValue-2 >= 1 ){
                            let knightPiecePossibleStance = document.querySelector(`.cell_${eachMovement_xAxisValue-1}_${eachMovement_yAxisValue-2}`);
                            if (knightPiecePossibleStance.querySelector("img")) {
                                let imagePiece = knightPiecePossibleStance.querySelector("img");
                                if((imagePiece.getAttribute('alt').includes("whiteKnight")) && (this.color === "black")) {
                                    gettingEatenMovements.push(true);
                                    isDangerous = true;
                                } else if ((imagePiece.getAttribute('alt').includes("blackKnight")) && (this.color === "white")) {
                                    gettingEatenMovements.push(true);
                                    isDangerous = true;
                                } else if ((imagePiece.getAttribute('alt').includes("black") && this.color === "black") || (imagePiece.getAttribute('alt').includes("white") && this.color === "white")) {
                                    isDangerous = false;
                                }
                            }
                        }

                        if (isDangerous) {
                            continue;
                        }
                        
                        // start over
                        needsBreak = false;
                        isDangerous = false;

                        if(eachMovement_xAxisValue-2 >= 1 && eachMovement_yAxisValue-1 >= 1 ){
                            let knightPiecePossibleStance = document.querySelector(`.cell_${eachMovement_xAxisValue-2}_${eachMovement_yAxisValue-1}`);
                            if (knightPiecePossibleStance.querySelector("img")) {
                                let imagePiece = knightPiecePossibleStance.querySelector("img");
                                if((imagePiece.getAttribute('alt').includes("whiteKnight")) && (this.color === "black")) {
                                    gettingEatenMovements.push(true);
                                    isDangerous = true;
                                } else if ((imagePiece.getAttribute('alt').includes("blackKnight")) && (this.color === "white")) {
                                    gettingEatenMovements.push(true);
                                    isDangerous = true;
                                } else if ((imagePiece.getAttribute('alt').includes("black") && this.color === "black") || (imagePiece.getAttribute('alt').includes("white") && this.color === "white")) {
                                    isDangerous = false;
                                }
                            }
                        }

                        if (isDangerous) {
                            continue;
                        }
                        
                        // start over
                        needsBreak = false;
                        isDangerous = false;

                        if(eachMovement_xAxisValue+1 <= 8 && eachMovement_yAxisValue-2 >= 1 ){
                            let knightPiecePossibleStance = document.querySelector(`.cell_${eachMovement_xAxisValue+1}_${eachMovement_yAxisValue-2}`);
                            if (knightPiecePossibleStance.querySelector("img")) {
                                let imagePiece = knightPiecePossibleStance.querySelector("img");
                                if((imagePiece.getAttribute('alt').includes("whiteKnight")) && (this.color === "black")) {
                                    gettingEatenMovements.push(true);
                                    isDangerous = true;
                                } else if ((imagePiece.getAttribute('alt').includes("blackKnight")) && (this.color === "white")) {
                                    gettingEatenMovements.push(true);
                                    isDangerous = true;
                                } else if ((imagePiece.getAttribute('alt').includes("black") && this.color === "black") || (imagePiece.getAttribute('alt').includes("white") && this.color === "white")) {
                                    isDangerous = false;
                                }
                            }
                        }

                        if (isDangerous) {
                            continue;
                        }
                        
                        // start over
                        needsBreak = false;
                        isDangerous = false;

                        if(eachMovement_xAxisValue+2 <= 8 && eachMovement_yAxisValue-1 >= 1 ){
                            let knightPiecePossibleStance = document.querySelector(`.cell_${eachMovement_xAxisValue+2}_${eachMovement_yAxisValue-1}`);
                            if (knightPiecePossibleStance.querySelector("img")) {
                                let imagePiece = knightPiecePossibleStance.querySelector("img");
                                if((imagePiece.getAttribute('alt').includes("whiteKnight")) && (this.color === "black")) {
                                    gettingEatenMovements.push(true);
                                    isDangerous = true;
                                } else if ((imagePiece.getAttribute('alt').includes("blackKnight")) && (this.color === "white")) {
                                    gettingEatenMovements.push(true);
                                    isDangerous = true;
                                } else if ((imagePiece.getAttribute('alt').includes("black") && this.color === "black") || (imagePiece.getAttribute('alt').includes("white") && this.color === "white")) {
                                    isDangerous = false;
                                }
                            }
                        }

                        if (isDangerous) {
                            continue;
                        }
                        
                        // start over
                        needsBreak = false;
                        isDangerous = false;

                        // check right if knight is there
                        if(eachMovement_xAxisValue-1 >= 1 && eachMovement_yAxisValue+2 <= 8 ){
                            let knightPiecePossibleStance = document.querySelector(`.cell_${eachMovement_xAxisValue-1}_${eachMovement_yAxisValue+2}`);
                            if (knightPiecePossibleStance.querySelector("img")) {
                                let imagePiece = knightPiecePossibleStance.querySelector("img");
                                if((imagePiece.getAttribute('alt').includes("whiteKnight")) && (this.color === "black")) {
                                    gettingEatenMovements.push(true);
                                    isDangerous = true;
                                } else if ((imagePiece.getAttribute('alt').includes("blackKnight")) && (this.color === "white")) {
                                    gettingEatenMovements.push(true);
                                    isDangerous = true;
                                } else if ((imagePiece.getAttribute('alt').includes("black") && this.color === "black") || (imagePiece.getAttribute('alt').includes("white") && this.color === "white")) {
                                    isDangerous = false;
                                }
                            }
                        }

                        if (isDangerous) {
                            continue;
                        }
                        
                        // start over
                        needsBreak = false;
                        isDangerous = false;


                        if(eachMovement_xAxisValue-2 >= 1 && eachMovement_yAxisValue+1 <= 8 ){
                            let knightPiecePossibleStance = document.querySelector(`.cell_${eachMovement_xAxisValue-2}_${eachMovement_yAxisValue+1}`);
                            if (knightPiecePossibleStance.querySelector("img")) {
                                let imagePiece = knightPiecePossibleStance.querySelector("img");
                                if((imagePiece.getAttribute('alt').includes("whiteKnight")) && (this.color === "black")) {
                                    gettingEatenMovements.push(true);
                                    isDangerous = true;
                                } else if ((imagePiece.getAttribute('alt').includes("blackKnight")) && (this.color === "white")) {
                                    gettingEatenMovements.push(true);
                                    isDangerous = true;
                                } else if ((imagePiece.getAttribute('alt').includes("black") && this.color === "black") || (imagePiece.getAttribute('alt').includes("white") && this.color === "white")) {
                                    isDangerous = false;
                                }
                            }
                        }

                        if (isDangerous) {
                            continue;
                        }
                        
                        // start over
                        needsBreak = false;
                        isDangerous = false;

                        if(eachMovement_xAxisValue+1 <= 8 && eachMovement_yAxisValue+2 <= 8 ){
                            let knightPiecePossibleStance = document.querySelector(`.cell_${eachMovement_xAxisValue+1}_${eachMovement_yAxisValue+2}`);
                            if (knightPiecePossibleStance.querySelector("img")) {
                                let imagePiece = knightPiecePossibleStance.querySelector("img");
                                if((imagePiece.getAttribute('alt').includes("whiteKnight")) && (this.color === "black")) {
                                    gettingEatenMovements.push(true);
                                    isDangerous = false;
                                } else if ((imagePiece.getAttribute('alt').includes("blackKnight")) && (this.color === "white")) {
                                    gettingEatenMovements.push(true);
                                    isDangerous = false;
                                } else if ((imagePiece.getAttribute('alt').includes("black") && this.color === "black") || (imagePiece.getAttribute('alt').includes("white") && this.color === "white")) {
                                    isDangerous = false;
                                }
                            }
                        }

                        if (isDangerous) {
                            continue;
                        }
                        
                        // start over
                        needsBreak = false;
                        isDangerous = false;

                        if(eachMovement_xAxisValue+2 <= 8 && eachMovement_yAxisValue+1 <= 8 ){
                            let knightPiecePossibleStance = document.querySelector(`.cell_${eachMovement_xAxisValue+2}_${eachMovement_yAxisValue+1}`);
                            if (knightPiecePossibleStance.querySelector("img")) {
                                let imagePiece = knightPiecePossibleStance.querySelector("img");
                                if((imagePiece.getAttribute('alt').includes("whiteKnight")) && (this.color === "black")) {
                                    gettingEatenMovements.push(true);
                                    isDangerous = true;
                                } else if ((imagePiece.getAttribute('alt').includes("blackKnight")) && (this.color === "white")) {
                                    gettingEatenMovements.push(true);
                                    isDangerous = true;
                                } else if ((imagePiece.getAttribute('alt').includes("black") && this.color === "black") || (imagePiece.getAttribute('alt').includes("white") && this.color === "white")) {
                                    isDangerous = false;
                                }
                            }
                        }
                        
                        // last element
                        if (isDangerous) {
                            continue;
                        } else {
                            gettingEatenMovements.push(false);
                        }
                       

                    } // End of outer for each statement for king movements

                        
                    // check gettingEatenMovements condition
                    for(let i = 0; i < gettingEatenMovements.length; i++){
                        if (gettingEatenMovements[i] !== true) {
                            isCheckMate = false;
                            break;
                        }
                    }

                    // `.cell_${attacker_xAxisValue}_${attacker_yAxisValue}`
                    // if is possible to eat the opponent
                    if (isCheckMate) {
                        // if pawn can capture the attacker
                        if (attackerPieceName.includes("white")) {
                            // check if blackPawn can capture that thing
                            let piece_xAxisValue;
                            let piece_yAxisValue;
                            let eatingMoves;
                            let possibleMoves;

                            for(let i = 0; i < blackPawnPieces.length; i++) {
                                piece_xAxisValue = parseInt(blackPawnPieces[i].position.substr(6, 1));
                                piece_yAxisValue = parseInt(blackPawnPieces[i].position.substr(blackPawnPieces[i].position.length - 1, 1));
                                eatingMoves = blackPawnPieces[i].eatingPossibility(piece_xAxisValue, piece_yAxisValue, true);

                                for(let j = 0; j < eatingMoves.length; j++){
                                    if (eatingMoves[j] === attackerCoordinate) {
                                        isCheckMate = false;
                                        break;
                                    }
                                } // inner for each loop for pawn pieces possible moves(to eat the enemy)


                                if (isCheckMate === false){
                                    break;
                                }
                            } // blackPawn check complete for blocking and capturing

                            // if it is still checkmate, check blackbihop can capture or block it
                            if (isCheckMate === true){
                                // check if blackBishop can capture the attacker
                                for(let i = 0; i < blackBishopPieces.length; i++) {
                                    piece_xAxisValue = parseInt(blackBishopPieces[i].position.substr(6, 1));
                                    piece_yAxisValue = parseInt(blackBishopPieces[i].position.substr(blackBishopPieces[i].position.length - 1, 1));
                                    eatingMoves = blackBishopPieces[i].eatingPossibility(piece_xAxisValue, piece_yAxisValue, attacker_xAxisValue, attacker_yAxisValue);
                                    
                                    for(let j = 0; j < eatingMoves.length; j++){
                                        if (eatingMoves[j] === attackerCoordinate) {
                                            isCheckMate = false;
                                            break;
                                        }        
                                    } // inner for each loop

                                    if (isCheckMate === false){
                                        break;
                                    }

                                } // black bishop check complete
                            } // if check mate is true or not
                            

                            if (isCheckMate === true) {
                                // check if blackRook can capture the attacker
                                for(let i = 0; i < blackRookPieces.length; i++) {
                                    piece_xAxisValue = parseInt(blackRookPieces[i].position.substr(6, 1));
                                    piece_yAxisValue = parseInt(blackRookPieces[i].position.substr(blackRookPieces[i].position.length - 1, 1));
                                    eatingMoves = blackRookPieces[i].eatingPossibility(piece_xAxisValue, piece_yAxisValue, attacker_xAxisValue, attacker_yAxisValue, true);

                                    for(let j = 0; j < eatingMoves.length; j++){
                                        if (eatingMoves[j] === attackerCoordinate) {
                                            isCheckMate = false;
                                            break;
                                        }
                                    } // inner for each loop

                                    if (isCheckMate === false){
                                        break;
                                    }

                                } // black rook check complete
                            } // check if it is checkmate or not
                            
                            // if black queen can capture the enemy
                            if (isCheckMate === true) {
                                // check if blackQueen can capture the attacker
                                for(let i = 0; i < blackQueenPiece.length; i++) {
                                    piece_xAxisValue = parseInt(blackQueenPiece[i].position.substr(6, 1));
                                    piece_yAxisValue = parseInt(blackQueenPiece[i].position.substr(blackQueenPiece[i].position.length - 1, 1));
                                    eatingMoves = blackQueenPiece[i].eatingPossibility(piece_xAxisValue, piece_yAxisValue, attacker_xAxisValue, attacker_yAxisValue);

                                    for(let j = 0; j < eatingMoves.length; j++){
                                        if (eatingMoves[j] === attackerOriginalCoordinate) {
                                            isCheckMate = false;
                                            break;
                                        }
                                    } // inner for each loop

                                    if (isCheckMate === false){
                                        break;
                                    }

                                } // black queen check complete
                            } // check if it is checkmate or not
                            
                            if (isCheckMate === true) {
                                // check if blackKnight can capture the attacker
                                for(let i = 0; i < blackKnightPieces.length; i++) {
                                    piece_xAxisValue = parseInt(blackKnightPieces[i].position.substr(6, 1));
                                    piece_yAxisValue = parseInt(blackKnightPieces[i].position.substr(blackKnightPieces[i].position.length - 1, 1));
                                    eatingMoves = blackKnightPieces[i].possibleMove(piece_xAxisValue, piece_yAxisValue, attacker_xAxisValue, attacker_yAxisValue);

                                    for(let j = 0; j < eatingMoves.length; j++){
                                        if (eatingMoves[j] === attackerOriginalCoordinate) {
                                            isCheckMate = false;
                                            break;
                                        }
                                    } // inner for each loop

                                    if (isCheckMate === false){
                                        break;
                                    }

                                } // black Knight check complete
                            }


                            if (isCheckMate === true) {
                                // check if blackKing can capture the attacker
                                for(let i = 0; i < blackKingPiece.length; i++) {
                                    piece_xAxisValue = parseInt(blackKingPiece[i].position.substr(6, 1));
                                    piece_yAxisValue = parseInt(blackKingPiece[i].position.substr(blackKingPiece[i].position.length - 1, 1));
                                    eatingMoves = blackKingPiece[i].possibleMove(piece_xAxisValue, piece_yAxisValue, true);

                                    for(let j = 0; j < eatingMoves.length; j++){
                                        if (eatingMoves[j] === attackerOriginalCoordinate) {
                                            isCheckMate = false;
                                            break;
                                        }
                                    } // inner for each loop

                                    if (isCheckMate === false){
                                        break;
                                    }

                                } // black Knight check complete
                            }

                        } else if (attackerPieceName.includes("black")) {
                            // check if blackPawn can capture that thing
                            let piece_xAxisValue;
                            let piece_yAxisValue;
                            let eatingMoves;
                            let possibleMoves;

                            // check if whitePawn can capture the attacker
                            for(let i = 0; i < whitePawnPieces.length; i++) {
                                piece_xAxisValue = parseInt(whitePawnPieces[i].position.substr(6, 1));
                                piece_yAxisValue = parseInt(whitePawnPieces[i].position.substr(whitePawnPieces[i].position.length - 1, 1));
                                eatingMoves = whitePawnPieces[i].eatingPossibility(piece_xAxisValue, piece_yAxisValue, true);

                                for(let j = 0; j < eatingMoves.length; j++){
                                    if (eatingMoves[j] === attackerOriginalCoordinate) {
                                        isCheckMate = false;
                                        break;
                                    }
                                } // inner for each loop

                                if (isCheckMate === false){
                                    break;
                                }
                            } // whitePawn check complete for blocking and capturing

                            // if it is still checkmate, check blackbihop can capture or block it
                            if (isCheckMate === true){
                                // check if whiteBishop can capture the attacker
                                for(let i = 0; i < whiteBishopPieces.length; i++) {
                                    piece_xAxisValue = parseInt(whiteBishopPieces[i].position.substr(6, 1));
                                    piece_yAxisValue = parseInt(whiteBishopPieces[i].position.substr(whiteBishopPieces[i].position.length - 1, 1));
                                    eatingMoves = whiteBishopPieces[i].eatingPossibility(piece_xAxisValue, piece_yAxisValue, attacker_xAxisValue, attacker_yAxisValue);
                                    
                                    for(let j = 0; j < eatingMoves.length; j++){
                                        if (eatingMoves[j] === attackerCoordinate) {
                                            isCheckMate = false;
                                            break;
                                        }        
                                    } // inner for each loop

                                    if (isCheckMate === false){
                                        break;
                                    }
                                } // whiteBishop check complete
                            }

                            if (isCheckMate === true){
                                    // check if whiteRook can capture the attacker
                                for(let i = 0; i < whiteRookPieces.length; i++) {
                                    piece_xAxisValue = parseInt(whiteRookPieces[i].position.substr(6, 1));
                                    piece_yAxisValue = parseInt(whiteRookPieces[i].position.substr(whiteRookPieces[i].position.length - 1, 1));
                                    eatingMoves = whiteRookPieces[i].eatingPossibility(piece_xAxisValue, piece_yAxisValue, attacker_xAxisValue, attacker_yAxisValue, true);

                                    for(let j = 0; j < eatingMoves.length; j++){
                                        if (eatingMoves[j] === attackerOriginalCoordinate) {
                                            isCheckMate = false;
                                            break;
                                        }
                                    } // inner for each loop

                                    if (isCheckMate === false){
                                        break;
                                    }

                                } // white rook check complete
                            } // checking checkmate done

                            if (isCheckMate === true) {
                                    // check if whiteQueen can capture the attacker
                                for(let i = 0; i < whiteQueenPiece.length; i++) {
                                    piece_xAxisValue = parseInt(whiteQueenPiece[i].position.substr(6, 1));
                                    piece_yAxisValue = parseInt(whiteQueenPiece[i].position.substr(whiteQueenPiece[i].position.length - 1, 1));
                                    eatingMoves = whiteQueenPiece[i].eatingPossibility(piece_xAxisValue, piece_yAxisValue, attacker_xAxisValue, attacker_yAxisValue);

                                    for(let j = 0; j < eatingMoves.length; j++){
                                        if (eatingMoves[j] === attackerOriginalCoordinate) {
                                            isCheckMate = false;
                                            break;
                                        }
                                    } // inner for each loop

                                    if (isCheckMate === false){
                                        break;
                                    }

                                } // white queen check complete
                            } // checking checkmate done


                            if (isCheckMate) {
                                // check if whitekKnight can capture the attacker
                                for(let i = 0; i < whiteKnightPieces.length; i++) {
                                    piece_xAxisValue = parseInt(whiteKnightPieces[i].position.substr(6, 1));
                                    piece_yAxisValue = parseInt(whiteKnightPieces[i].position.substr(whiteKnightPieces[i].position.length - 1, 1));
                                    eatingMoves = whiteKnightPieces[i].possibleMove(piece_xAxisValue, piece_yAxisValue, attacker_xAxisValue, attacker_yAxisValue);

                                    for(let j = 0; j < eatingMoves.length; j++){
                                        if (eatingMoves[j] === attackerOriginalCoordinate) {
                                            isCheckMate = false;
                                            break;
                                        }
                                    } // inner for each loop

                                    if (isCheckMate === false){
                                        break;
                                    }

                                } // white Knight check complete
                            } // checking checkmate done

                            if (isCheckMate) {
                                // check if whitekKing can capture the attacker
                                for(let i = 0; i < whiteKingPiece.length; i++) {
                                    piece_xAxisValue = parseInt(whiteKingPiece[i].position.substr(6, 1));
                                    piece_yAxisValue = parseInt(whiteKingPiece[i].position.substr(whiteKingPiece[i].position.length - 1, 1));
                                    eatingMoves = whiteKingPiece[i].possibleMove(piece_xAxisValue, piece_yAxisValue, true);

                                    for(let j = 0; j < eatingMoves.length; j++){
                                        if (eatingMoves[j] === attackerOriginalCoordinate) {
                                            isCheckMate = false;
                                            break;
                                        }
                                    } // inner for each loop

                                    if (isCheckMate === false){
                                        break;
                                    }

                                } // white Knight check complete
                            } // checking checkmate done

                        }
  
                    }
                    
                    /////////// checking third one checkmate
                    if (isCheckMate) {
                        // Can protect the king code
                        ////// Can protect the king by blocking the enemy start
                        if (attackerPieceName.includes("whiteRook") || attackerPieceName.includes("whiteQueen")){
                            if(attacker_xAxisValue === king_xAxisValue) {   
                                let diff_yValue = attacker_yAxisValue - king_yAxisValue;
                                if (diff_yValue > 0){
                                    // positive value: king is at the left and rook is at the right
                                    // rook or queen movement infiltration
                                    for(let k = 1; k < diff_yValue; k++){

                                        // // if black pawn pieces can defend or block the enemy start
                                        for(let l = 0; l < blackPawnPieces.length; l++){
                                            let piece_xAxisValue = parseInt(blackPawnPieces[l].position.substr(6, 1));
                                            let piece_yAxisValue = parseInt(blackPawnPieces[l].position.substr(blackPawnPieces[l].position.length -1, 1));
                                            let possibleMoves = blackPawnPieces[l].possibleMove(piece_xAxisValue, piece_yAxisValue, true, attacker_xAxisValue, attacker_yAxisValue-k);

                                            for(let m = 0; m < possibleMoves.length; m++) {
                                                if (possibleMoves[m] === `.cell_${attacker_xAxisValue}_${attacker_yAxisValue-k}`){
                                                    isCheckMate = false;
                                                    break;
                                                }
                                            }

                                            if (isCheckMate === false) {
                                                break;
                                            }

                                        } // if black pawn pieces can defend or block the enemy end

                                        if (isCheckMate === false) {
                                            break;
                                        }

                                        // // if black knight pieces can defend or block the enemy start
                                        for(let l = 0; l < blackKnightPieces.length; l++){
                                            let piece_xAxisValue = parseInt(blackKnightPieces[l].position.substr(6, 1));
                                            let piece_yAxisValue = parseInt(blackKnightPieces[l].position.substr(blackKnightPieces[l].position.length -1, 1));
                                            let possibleMoves = blackKnightPieces[l].possibleMove(piece_xAxisValue, piece_yAxisValue, attacker_xAxisValue, attacker_yAxisValue-k);

                                            for(let m = 0; m < possibleMoves.length; m++) {
                                                if (possibleMoves[m] === `.cell_${attacker_xAxisValue}_${attacker_yAxisValue-k}`){
                                                    isCheckMate = false;
                                                    break;
                                                }
                                            }

                                            if (isCheckMate === false) {
                                                break;
                                            }

                                        } // if black knight pieces can defend or block the enemy end

                                        if (isCheckMate === false) {
                                            break;
                                        }

                                        // // if black bishop pieces can defend or block the enemy start
                                        for(let l = 0; l < blackBishopPieces.length; l++){
                                            let piece_xAxisValue = parseInt(blackBishopPieces[l].position.substr(6, 1));
                                            let piece_yAxisValue = parseInt(blackBishopPieces[l].position.substr(blackBishopPieces[l].position.length -1, 1));
                                            let possibleMoves = blackBishopPieces[l].possibleMove(piece_xAxisValue, piece_yAxisValue, attacker_xAxisValue, attacker_yAxisValue-k);

                                            for(let m = 0; m < possibleMoves.length; m++) {
                                                if (possibleMoves[m] === `.cell_${attacker_xAxisValue}_${attacker_yAxisValue-k}`){
                                                    isCheckMate = false;
                                                    break;
                                                }
                                            }

                                            if (isCheckMate === false) {
                                                break;
                                            }

                                        } // if black bishop pieces can defend or block the enemy end

                                        if (isCheckMate === false) {
                                            break;
                                        }
                                        
                                        // // if black rook piece can defend or block the enemy start
                                        for(let l = 0; l < blackRookPieces.length; l++){
                                            let piece_xAxisValue = parseInt(blackRookPieces[l].position.substr(6, 1));
                                            let piece_yAxisValue = parseInt(blackRookPieces[l].position.substr(blackRookPieces[l].position.length -1, 1));
                                            let possibleMoves = blackRookPieces[l].possibleMove(piece_xAxisValue, piece_yAxisValue, attacker_xAxisValue, attacker_yAxisValue-k, true);

                                            for(let m = 0; m < possibleMoves.length; m++) {
                                                if (possibleMoves[m] === `.cell_${attacker_xAxisValue}_${attacker_yAxisValue-k}`){
                                                    isCheckMate = false;
                                                    break;
                                                }
                                            }

                                            if (isCheckMate === false) {
                                                break;
                                            }

                                        } // if black rook piece can defend or block the enemy end

                                        if (isCheckMate === false) {
                                            break;
                                        }
                                        
                                        // // if black queen piece can defend or block the enemy start
                                        for(let l = 0; l < blackQueenPiece.length; l++){
                                            let piece_xAxisValue = parseInt(blackQueenPiece[l].position.substr(6, 1));
                                            let piece_yAxisValue = parseInt(blackQueenPiece[l].position.substr(blackQueenPiece[l].position.length -1, 1));
                                            let possibleMoves = blackQueenPiece[l].possibleMove(piece_xAxisValue, piece_yAxisValue, attacker_xAxisValue, attacker_yAxisValue-k);

                                            for(let m = 0; m < possibleMoves.length; m++) {
                                                if (possibleMoves[m] === `.cell_${attacker_xAxisValue}_${attacker_yAxisValue-k}`){
                                                    isCheckMate = false;
                                                    break;
                                                }
                                            }

                                            if (isCheckMate === false) {
                                                break;
                                            }

                                        } // if black queen piece can defend or block the enemy end

                                        if (isCheckMate === false) {
                                            break;
                                        }   
                                        // check diff yvalue is bigger than 0
                                    } // for loop of movement end

                                // king is at the right rook is at the left
                                } else if (diff_yValue < 0) {
                                    // rook or queen movement infiltration
                                    for(let k = 1; k < Math.abs(diff_yValue); k++){

                                        // // if black pawn pieces can defend or block the enemy start
                                        for(let l = 0; l < blackPawnPieces.length; l++){
                                            let piece_xAxisValue = parseInt(blackPawnPieces[l].position.substr(6, 1));
                                            let piece_yAxisValue = parseInt(blackPawnPieces[l].position.substr(blackPawnPieces[l].position.length -1, 1));
                                            let possibleMoves = blackPawnPieces[l].possibleMove(piece_xAxisValue, piece_yAxisValue, true, attacker_xAxisValue, attacker_yAxisValue+k);

                                            for(let m = 0; m < possibleMoves.length; m++) {
                                                if (possibleMoves[m] === `.cell_${attacker_xAxisValue}_${attacker_yAxisValue+k}`){
                                                    isCheckMate = false;
                                                    break;
                                                }
                                            }

                                            if (isCheckMate === false) {
                                                break;
                                            }

                                        } // if black pawn pieces can defend or block the enemy end

                                        if (isCheckMate === false) {
                                            break;
                                        }

                                        // // if black knight pieces can defend or block the enemy start
                                        for(let l = 0; l < blackKnightPieces.length; l++){
                                            let piece_xAxisValue = parseInt(blackKnightPieces[l].position.substr(6, 1));
                                            let piece_yAxisValue = parseInt(blackKnightPieces[l].position.substr(blackKnightPieces[l].position.length -1, 1));
                                            let possibleMoves = blackKnightPieces[l].possibleMove(piece_xAxisValue, piece_yAxisValue, attacker_xAxisValue, attacker_yAxisValue+k);

                                            for(let m = 0; m < possibleMoves.length; m++) {
                                                if (possibleMoves[m] === `.cell_${attacker_xAxisValue}_${attacker_yAxisValue+k}`){
                                                    isCheckMate = false;
                                                    break;
                                                }
                                            }

                                            if (isCheckMate === false) {
                                                break;
                                            }

                                        } // if black knight pieces can defend or block the enemy end

                                        if (isCheckMate === false) {
                                            break;
                                        }

                                        // // if black bishop pieces can defend or block the enemy start
                                        for(let l = 0; l < blackBishopPieces.length; l++){
                                            let piece_xAxisValue = parseInt(blackBishopPieces[l].position.substr(6, 1));
                                            let piece_yAxisValue = parseInt(blackBishopPieces[l].position.substr(blackBishopPieces[l].position.length -1, 1));
                                            let possibleMoves = blackBishopPieces[l].possibleMove(piece_xAxisValue, piece_yAxisValue, attacker_xAxisValue, attacker_yAxisValue+k);

                                            for(let m = 0; m < possibleMoves.length; m++) {
                                                if (possibleMoves[m] === `.cell_${attacker_xAxisValue}_${attacker_yAxisValue+k}`){
                                                    isCheckMate = false;
                                                    break;
                                                }
                                            }

                                            if (isCheckMate === false) {
                                                break;
                                            }

                                        } // if black bishop pieces can defend or block the enemy end

                                        if (isCheckMate === false) {
                                            break;
                                        }

                                        // // if black rook piece can defend or block the enemy start
                                        for(let l = 0; l < blackRookPieces.length; l++){
                                            let piece_xAxisValue = parseInt(blackRookPieces[l].position.substr(6, 1));
                                            let piece_yAxisValue = parseInt(blackRookPieces[l].position.substr(blackRookPieces[l].position.length -1, 1));
                                            let possibleMoves = blackRookPieces[l].possibleMove(piece_xAxisValue, piece_yAxisValue, attacker_xAxisValue, attacker_yAxisValue+k, true);

                                            for(let m = 0; m < possibleMoves.length; m++) {
                                                if (possibleMoves[m] === `.cell_${attacker_xAxisValue}_${attacker_yAxisValue+k}`){
                                                    isCheckMate = false;
                                                    break;
                                                }
                                            }

                                            if (isCheckMate === false) {
                                                break;
                                            }

                                        } // if black rook piece can defend or block the enemy end

                                        if (isCheckMate === false) {
                                            break;
                                        }

                                        // // if black queen piece can defend or block the enemy start
                                        for(let l = 0; l < blackQueenPiece.length; l++){
                                            let piece_xAxisValue = parseInt(blackQueenPiece[l].position.substr(6, 1));
                                            let piece_yAxisValue = parseInt(blackQueenPiece[l].position.substr(blackQueenPiece[l].position.length -1, 1));
                                            let possibleMoves = blackQueenPiece[l].possibleMove(piece_xAxisValue, piece_yAxisValue, attacker_xAxisValue, attacker_yAxisValue+k);

                                            for(let m = 0; m < possibleMoves.length; m++) {
                                                if (possibleMoves[m] === `.cell_${attacker_xAxisValue}_${attacker_yAxisValue+k}`){
                                                    isCheckMate = false;
                                                    break;
                                                }
                                            }

                                            if (isCheckMate === false) {
                                                break;
                                            }

                                        } // if black queen piece can defend or block the enemy end

                                        if (isCheckMate === false) {
                                            break;
                                        }   
                                        // check diff yvalue is bigger than 0
                                    } // for loop of movement end
                                }
                            } // check for left and right rook or queen


                            // check for up and down
                            if(attacker_yAxisValue === king_yAxisValue) {   
                                let diff_xValue = attacker_xAxisValue - king_xAxisValue;
                                if (diff_xValue > 0){
                                    // positive value: king is at the up and rook is at the down
                                    // rook or queen movement infiltration
                                    for(let k = 1; k < diff_xValue; k++){

                                        // // if black pawn pieces can defend or block the enemy start
                                        for(let l = 0; l < blackPawnPieces.length; l++){
                                            let piece_xAxisValue = parseInt(blackPawnPieces[l].position.substr(6, 1));
                                            let piece_yAxisValue = parseInt(blackPawnPieces[l].position.substr(blackPawnPieces[l].position.length -1, 1));
                                            let possibleMoves = blackPawnPieces[l].possibleMove(piece_xAxisValue, piece_yAxisValue, true, attacker_xAxisValue-k, attacker_yAxisValue);

                                            for(let m = 0; m < possibleMoves.length; m++) {
                                                if (possibleMoves[m] === `.cell_${attacker_xAxisValue-k}_${attacker_yAxisValue}`){
                                                    isCheckMate = false;
                                                    break;
                                                }
                                            }

                                            if (isCheckMate === false) {
                                                break;
                                            }

                                        } // if black pawn pieces can defend or block the enemy end

                                        if (isCheckMate === false) {
                                            break;
                                        }

                                        // // if black knight pieces can defend or block the enemy start
                                        for(let l = 0; l < blackKnightPieces.length; l++){
                                            let piece_xAxisValue = parseInt(blackKnightPieces[l].position.substr(6, 1));
                                            let piece_yAxisValue = parseInt(blackKnightPieces[l].position.substr(blackKnightPieces[l].position.length -1, 1));
                                            let possibleMoves = blackKnightPieces[l].possibleMove(piece_xAxisValue, piece_yAxisValue, attacker_xAxisValue-k, attacker_yAxisValue);

                                            for(let m = 0; m < possibleMoves.length; m++) {
                                                if (possibleMoves[m] === `.cell_${attacker_xAxisValue-k}_${attacker_yAxisValue}`){
                                                    isCheckMate = false;
                                                    break;
                                                }
                                            }

                                            if (isCheckMate === false) {
                                                break;
                                            }

                                        } // if black knight pieces can defend or block the enemy end

                                        if (isCheckMate === false) {
                                            break;
                                        }

                                        // // if black bishop pieces can defend or block the enemy start
                                        for(let l = 0; l < blackBishopPieces.length; l++){
                                            let piece_xAxisValue = parseInt(blackBishopPieces[l].position.substr(6, 1));
                                            let piece_yAxisValue = parseInt(blackBishopPieces[l].position.substr(blackBishopPieces[l].position.length -1, 1));
                                            let possibleMoves = blackBishopPieces[l].possibleMove(piece_xAxisValue, piece_yAxisValue, attacker_xAxisValue-k, attacker_yAxisValue);

                                            for(let m = 0; m < possibleMoves.length; m++) {
                                                if (possibleMoves[m] === `.cell_${attacker_xAxisValue-k}_${attacker_yAxisValue}`){
                                                    isCheckMate = false;
                                                    break;
                                                }
                                            }

                                            if (isCheckMate === false) {
                                                break;
                                            }

                                        } // if black bishop pieces can defend or block the enemy end

                                        if (isCheckMate === false) {
                                            break;
                                        }
                                        
                                        // // if black rook piece can defend or block the enemy start
                                        for(let l = 0; l < blackRookPieces.length; l++){
                                            let piece_xAxisValue = parseInt(blackRookPieces[l].position.substr(6, 1));
                                            let piece_yAxisValue = parseInt(blackRookPieces[l].position.substr(blackRookPieces[l].position.length -1, 1));
                                            let possibleMoves = blackRookPieces[l].possibleMove(piece_xAxisValue, piece_yAxisValue, attacker_xAxisValue-k, attacker_yAxisValue, true);

                                            for(let m = 0; m < possibleMoves.length; m++) {
                                                if (possibleMoves[m] === `.cell_${attacker_xAxisValue-k}_${attacker_yAxisValue}`){
                                                    isCheckMate = false;
                                                    break;
                                                }
                                            }

                                            if (isCheckMate === false) {
                                                break;
                                            }

                                        } // if black rook piece can defend or block the enemy end

                                        if (isCheckMate === false) {
                                            break;
                                        }
                                        
                                        // // if black queen piece can defend or block the enemy start
                                        for(let l = 0; l < blackQueenPiece.length; l++){
                                            let piece_xAxisValue = parseInt(blackQueenPiece[l].position.substr(6, 1));
                                            let piece_yAxisValue = parseInt(blackQueenPiece[l].position.substr(blackQueenPiece[l].position.length -1, 1));
                                            let possibleMoves = blackQueenPiece[l].possibleMove(piece_xAxisValue, piece_yAxisValue, attacker_xAxisValue-k, attacker_yAxisValue);

                                            for(let m = 0; m < possibleMoves.length; m++) {
                                                if (possibleMoves[m] === `.cell_${attacker_xAxisValue-k}_${attacker_yAxisValue}`){
                                                    isCheckMate = false;
                                                    break;
                                                }
                                            }

                                            if (isCheckMate === false) {
                                                break;
                                            }

                                        } // if black queen piece can defend or block the enemy end

                                        if (isCheckMate === false) {
                                            break;
                                        }   
                                        // check diff yvalue is bigger than 0
                                    } // for loop of movement end

                                // king is at the bottom rook is at the top
                                } else if (diff_xValue < 0) {
                                    // rook or queen movement infiltration
                                    for(let k = 1; k < Math.abs(diff_xValue); k++){

                                        // // if black pawn pieces can defend or block the enemy start
                                        for(let l = 0; l < blackPawnPieces.length; l++){
                                            let piece_xAxisValue = parseInt(blackPawnPieces[l].position.substr(6, 1));
                                            let piece_yAxisValue = parseInt(blackPawnPieces[l].position.substr(blackPawnPieces[l].position.length -1, 1));
                                            let possibleMoves = blackPawnPieces[l].possibleMove(piece_xAxisValue, piece_yAxisValue, true, attacker_xAxisValue+k, attacker_yAxisValue);

                                            for(let m = 0; m < possibleMoves.length; m++) {
                                                if (possibleMoves[m] === `.cell_${attacker_xAxisValue+k}_${attacker_yAxisValue}`){
                                                    isCheckMate = false;
                                                    break;
                                                }
                                            }

                                            if (isCheckMate === false) {
                                                break;
                                            }

                                        } // if black pawn pieces can defend or block the enemy end

                                        if (isCheckMate === false) {
                                            break;
                                        }

                                        // // if black knight pieces can defend or block the enemy start
                                        for(let l = 0; l < blackKnightPieces.length; l++){
                                            let piece_xAxisValue = parseInt(blackKnightPieces[l].position.substr(6, 1));
                                            let piece_yAxisValue = parseInt(blackKnightPieces[l].position.substr(blackKnightPieces[l].position.length -1, 1));
                                            let possibleMoves = blackKnightPieces[l].possibleMove(piece_xAxisValue, piece_yAxisValue, attacker_xAxisValue+k, attacker_yAxisValue);

                                            for(let m = 0; m < possibleMoves.length; m++) {
                                                if (possibleMoves[m] === `.cell_${attacker_xAxisValue+k}_${attacker_yAxisValue}`){
                                                    isCheckMate = false;
                                                    break;
                                                }
                                            }

                                            if (isCheckMate === false) {
                                                break;
                                            }

                                        } // if black knight pieces can defend or block the enemy end

                                        if (isCheckMate === false) {
                                            break;
                                        }

                                        // // if black bishop pieces can defend or block the enemy start
                                        for(let l = 0; l < blackBishopPieces.length; l++){
                                            let piece_xAxisValue = parseInt(blackBishopPieces[l].position.substr(6, 1));
                                            let piece_yAxisValue = parseInt(blackBishopPieces[l].position.substr(blackBishopPieces[l].position.length -1, 1));
                                            let possibleMoves = blackBishopPieces[l].possibleMove(piece_xAxisValue, piece_yAxisValue, attacker_xAxisValue+k, attacker_yAxisValue);

                                            for(let m = 0; m < possibleMoves.length; m++) {
                                                if (possibleMoves[m] === `.cell_${attacker_xAxisValue+k}_${attacker_yAxisValue}`){
                                                    isCheckMate = false;
                                                    break;
                                                }
                                            }

                                            if (isCheckMate === false) {
                                                break;
                                            }

                                        } // if black bishop pieces can defend or block the enemy end

                                        if (isCheckMate === false) {
                                            break;
                                        }

                                        // // if black rook piece can defend or block the enemy start
                                        for(let l = 0; l < blackRookPieces.length; l++){
                                            let piece_xAxisValue = parseInt(blackRookPieces[l].position.substr(6, 1));
                                            let piece_yAxisValue = parseInt(blackRookPieces[l].position.substr(blackRookPieces[l].position.length -1, 1));
                                            let possibleMoves = blackRookPieces[l].possibleMove(piece_xAxisValue, piece_yAxisValue, attacker_xAxisValue+k, attacker_yAxisValue, true);

                                            for(let m = 0; m < possibleMoves.length; m++) {
                                                if (possibleMoves[m] === `.cell_${attacker_xAxisValue+k}_${attacker_yAxisValue}`){
                                                    isCheckMate = false;
                                                    break;
                                                }
                                            }

                                            if (isCheckMate === false) {
                                                break;
                                            }

                                        } // if black rook piece can defend or block the enemy end

                                        if (isCheckMate === false) {
                                            break;
                                        }

                                        // // if black queen piece can defend or block the enemy start
                                        for(let l = 0; l < blackQueenPiece.length; l++){
                                            let piece_xAxisValue = parseInt(blackQueenPiece[l].position.substr(6, 1));
                                            let piece_yAxisValue = parseInt(blackQueenPiece[l].position.substr(blackQueenPiece[l].position.length -1, 1));
                                            let possibleMoves = blackQueenPiece[l].possibleMove(piece_xAxisValue, piece_yAxisValue, attacker_xAxisValue+k, attacker_yAxisValue);

                                            for(let m = 0; m < possibleMoves.length; m++) {
                                                if (possibleMoves[m] === `.cell_${attacker_xAxisValue+k}_${attacker_yAxisValue}`){
                                                    isCheckMate = false;
                                                    break;
                                                }
                                            }

                                            if (isCheckMate === false) {
                                                break;
                                            }

                                        } // if black queen piece can defend or block the enemy end

                                        if (isCheckMate === false) {
                                            break;
                                        }   
                                        // check diff yvalue is bigger than 0

                                    } // for loop of movement end
                                } // end of diff_xValue is negative

                            } // check for up and down rook or queen
                        } // check for all white rook and white queen
                        ///////////////////


                        // if attacker is whiteQueen or white bishop
                        if (attackerPieceName.includes("whiteQueen") || attackerPieceName.includes("whiteBishop")){
                            let diff_xValue = attacker_xAxisValue - king_xAxisValue;
                            let diff_yValue = attacker_yAxisValue - king_yAxisValue;

                            // it has to be diagonal
                            if(Math.abs(diff_xValue) === Math.abs(diff_yValue)) {
                                
                                // attacker is bottom right, king is top left
                                if(diff_xValue > 0 && diff_yValue > 0) {
                                    for (let k = 1; k < Math.abs(diff_xValue); k++) {

                                        // check if pawn pieces can block the attacker
                                        for(let l = 0; l < blackPawnPieces.length; l++){
                                            let piece_xAxisValue = parseInt(blackPawnPieces[l].position.substr(6, 1));
                                            let piece_yAxisValue = parseInt(blackPawnPieces[l].position.substr(blackPawnPieces[l].position.length -1, 1));
                                            let possibleMoves = blackPawnPieces[l].possibleMove(piece_xAxisValue, piece_yAxisValue, true, attacker_xAxisValue-k, attacker_yAxisValue-k);

                                            for(let m = 0; m < possibleMoves.length; m++) {
                                                if (possibleMoves[m] === `.cell_${attacker_xAxisValue-k}_${attacker_yAxisValue-k}`){
                                                    isCheckMate = false;
                                                    break;
                                                }
                                            }

                                            if (isCheckMate === false) {
                                                break;
                                            }

                                        } // if black pawn pieces can defend or block the enemy end

                                        if (isCheckMate === false) {
                                            break;
                                        } 
                                        
                                        // check if knight pieces can block the attacker
                                        for(let l = 0; l < blackKnightPieces.length; l++){
                                            let piece_xAxisValue = parseInt(blackKnightPieces[l].position.substr(6, 1));
                                            let piece_yAxisValue = parseInt(blackKnightPieces[l].position.substr(blackKnightPieces[l].position.length -1, 1));
                                            let possibleMoves = blackKnightPieces[l].possibleMove(piece_xAxisValue, piece_yAxisValue, attacker_xAxisValue-k, attacker_yAxisValue-k);

                                            for(let m = 0; m < possibleMoves.length; m++) {
                                                if (possibleMoves[m] === `.cell_${attacker_xAxisValue-k}_${attacker_yAxisValue-k}`){
                                                    isCheckMate = false;
                                                    break;
                                                }
                                            }

                                            if (isCheckMate === false) {
                                                break;
                                            }

                                        } // if black knight pieces can defend or block the enemy end

                                        if (isCheckMate === false) {
                                            break;
                                        } 

                                        // check if bishop pieces can block the attacker
                                        for(let l = 0; l < blackBishopPieces.length; l++){
                                            let piece_xAxisValue = parseInt(blackBishopPieces[l].position.substr(6, 1));
                                            let piece_yAxisValue = parseInt(blackBishopPieces[l].position.substr(blackBishopPieces[l].position.length -1, 1));
                                            let possibleMoves = blackBishopPieces[l].possibleMove(piece_xAxisValue, piece_yAxisValue, attacker_xAxisValue-k, attacker_yAxisValue-k);

                                            for(let m = 0; m < possibleMoves.length; m++) {
                                                if (possibleMoves[m] === `.cell_${attacker_xAxisValue-k}_${attacker_yAxisValue-k}`){
                                                    isCheckMate = false;
                                                    break;
                                                }
                                            }

                                            if (isCheckMate === false) {
                                                break;
                                            }

                                        } // if black knight pieces can defend or block the enemy end

                                        if (isCheckMate === false) {
                                            break;
                                        } 

                                        // check if rook pieces can block the attacker
                                        for(let l = 0; l < blackRookPieces.length; l++){
                                            let piece_xAxisValue = parseInt(blackRookPieces[l].position.substr(6, 1));
                                            let piece_yAxisValue = parseInt(blackRookPieces[l].position.substr(blackRookPieces[l].position.length -1, 1));
                                            let possibleMoves = blackRookPieces[l].possibleMove(piece_xAxisValue, piece_yAxisValue, attacker_xAxisValue-k, attacker_yAxisValue-k, true);

                                            for(let m = 0; m < possibleMoves.length; m++) {
                                                if (possibleMoves[m] === `.cell_${attacker_xAxisValue-k}_${attacker_yAxisValue-k}`){
                                                    isCheckMate = false;
                                                    break;
                                                }
                                            }

                                            if (isCheckMate === false) {
                                                break;
                                            }

                                        } // if black rook pieces can defend or block the enemy end

                                        if (isCheckMate === false) {
                                            break;
                                        } 

                                        // check if queen piece can block the attacker
                                        for(let l = 0; l < blackQueenPiece.length; l++){
                                            let piece_xAxisValue = parseInt(blackQueenPiece[l].position.substr(6, 1));
                                            let piece_yAxisValue = parseInt(blackQueenPiece[l].position.substr(blackQueenPiece[l].position.length -1, 1));
                                            let possibleMoves = blackQueenPiece[l].possibleMove(piece_xAxisValue, piece_yAxisValue, attacker_xAxisValue-k, attacker_yAxisValue-k);

                                            for(let m = 0; m < possibleMoves.length; m++) {
                                                if (possibleMoves[m] === `.cell_${attacker_xAxisValue-k}_${attacker_yAxisValue-k}`){
                                                    isCheckMate = false;
                                                    break;
                                                }
                                            }

                                            if (isCheckMate === false) {
                                                break;
                                            }

                                        } // if black queen piece can defend or block the enemy end

                                        if (isCheckMate === false) {
                                            break;
                                        } 

                                    } // looping done
                                } // attacker is bottom right, king is top left end


                                // attacker is bottom left, king is top right
                                if(diff_xValue > 0 && diff_yValue < 0) {
                                    for (let k = 1; k < Math.abs(diff_xValue); k++) {

                                        // check if pawn pieces can block the attacker
                                        for(let l = 0; l < blackPawnPieces.length; l++){
                                            let piece_xAxisValue = parseInt(blackPawnPieces[l].position.substr(6, 1));
                                            let piece_yAxisValue = parseInt(blackPawnPieces[l].position.substr(blackPawnPieces[l].position.length -1, 1));
                                            let possibleMoves = blackPawnPieces[l].possibleMove(piece_xAxisValue, piece_yAxisValue, true, attacker_xAxisValue-k, attacker_yAxisValue+k);

                                            for(let m = 0; m < possibleMoves.length; m++) {
                                                if (possibleMoves[m] === `.cell_${attacker_xAxisValue-k}_${attacker_yAxisValue+k}`){
                                                    isCheckMate = false;
                                                    break;
                                                }
                                            }

                                            if (isCheckMate === false) {
                                                break;
                                            }

                                        } // if black pawn pieces can defend or block the enemy end

                                        if (isCheckMate === false) {
                                            break;
                                        } 
                                        
                                        // check if knight pieces can block the attacker
                                        for(let l = 0; l < blackKnightPieces.length; l++){
                                            let piece_xAxisValue = parseInt(blackKnightPieces[l].position.substr(6, 1));
                                            let piece_yAxisValue = parseInt(blackKnightPieces[l].position.substr(blackKnightPieces[l].position.length -1, 1));
                                            let possibleMoves = blackKnightPieces[l].possibleMove(piece_xAxisValue, piece_yAxisValue, attacker_xAxisValue-k, attacker_yAxisValue+k);

                                            for(let m = 0; m < possibleMoves.length; m++) {
                                                if (possibleMoves[m] === `cell_${attacker_xAxisValue-k}_${attacker_yAxisValue+k}`){
                                                    isCheckMate = false;
                                                    break;
                                                }
                                            }

                                            if (isCheckMate === false) {
                                                break;
                                            }

                                        } // if black knight pieces can defend or block the enemy end

                                        if (isCheckMate === false) {
                                            break;
                                        } 

                                        // check if bishop pieces can block the attacker
                                        for(let l = 0; l < blackBishopPieces.length; l++){
                                            let piece_xAxisValue = parseInt(blackBishopPieces[l].position.substr(6, 1));
                                            let piece_yAxisValue = parseInt(blackBishopPieces[l].position.substr(blackBishopPieces[l].position.length -1, 1));
                                            let possibleMoves = blackBishopPieces[l].possibleMove(piece_xAxisValue, piece_yAxisValue, attacker_xAxisValue-k, attacker_yAxisValue+k);

                                            for(let m = 0; m < possibleMoves.length; m++) {
                                                if (possibleMoves[m] === `.cell_${attacker_xAxisValue-k}_${attacker_yAxisValue+k}`){
                                                    isCheckMate = false;
                                                    break;
                                                }
                                            }

                                            if (isCheckMate === false) {
                                                break;
                                            }

                                        } // if black knight pieces can defend or block the enemy end

                                        if (isCheckMate === false) {
                                            break;
                                        } 

                                        // check if rook pieces can block the attacker
                                        for(let l = 0; l < blackRookPieces.length; l++){
                                            let piece_xAxisValue = parseInt(blackRookPieces[l].position.substr(6, 1));
                                            let piece_yAxisValue = parseInt(blackRookPieces[l].position.substr(blackRookPieces[l].position.length -1, 1));
                                            let possibleMoves = blackRookPieces[l].possibleMove(piece_xAxisValue, piece_yAxisValue, attacker_xAxisValue-k, attacker_yAxisValue+k, true);

                                            for(let m = 0; m < possibleMoves.length; m++) {
                                                if (possibleMoves[m] === `.cell_${attacker_xAxisValue-k}_${attacker_yAxisValue+k}`){
                                                    isCheckMate = false;
                                                    break;
                                                }
                                            }

                                            if (isCheckMate === false) {
                                                break;
                                            }

                                        } // if black rook pieces can defend or block the enemy end

                                        if (isCheckMate === false) {
                                            break;
                                        } 

                                        // check if queen piece can block the attacker
                                        for(let l = 0; l < blackQueenPiece.length; l++){
                                            let piece_xAxisValue = parseInt(blackQueenPiece[l].position.substr(6, 1));
                                            let piece_yAxisValue = parseInt(blackQueenPiece[l].position.substr(blackQueenPiece[l].position.length -1, 1));
                                            let possibleMoves = blackQueenPiece[l].possibleMove(piece_xAxisValue, piece_yAxisValue, attacker_xAxisValue-k, attacker_yAxisValue+k);

                                            for(let m = 0; m < possibleMoves.length; m++) {
                                                if (possibleMoves[m] === `.cell_${attacker_xAxisValue-k}_${attacker_yAxisValue+k}`){
                                                    isCheckMate = false;
                                                    break;
                                                }
                                            }

                                            if (isCheckMate === false) {
                                                break;
                                            }

                                        } // if black queen piece can defend or block the enemy end

                                        if (isCheckMate === false) {
                                            break;
                                        } 

                                    } // looping done
                                } // attacker is bottom left, king is top right end


                                // attacker is top right, king is down left
                                if(diff_xValue < 0 && diff_yValue > 0) {
                                    for (let k = 1; k < Math.abs(diff_xValue); k++) {

                                        // check if pawn pieces can block the attacker
                                        for(let l = 0; l < blackPawnPieces.length; l++){
                                            let piece_xAxisValue = parseInt(blackPawnPieces[l].position.substr(6, 1));
                                            let piece_yAxisValue = parseInt(blackPawnPieces[l].position.substr(blackPawnPieces[l].position.length -1, 1));
                                            let possibleMoves = blackPawnPieces[l].possibleMove(piece_xAxisValue, piece_yAxisValue, true, attacker_xAxisValue+k, attacker_yAxisValue-k);

                                            for(let m = 0; m < possibleMoves.length; m++) {
                                                if (possibleMoves[m] === `.cell_${attacker_xAxisValue+k}_${attacker_yAxisValue-k}`){
                                                    isCheckMate = false;
                                                    break;
                                                }
                                            }

                                            if (isCheckMate === false) {
                                                break;
                                            }

                                        } // if black pawn pieces can defend or block the enemy end

                                        if (isCheckMate === false) {
                                            break;
                                        } 
                                        
                                        // check if knight pieces can block the attacker
                                        for(let l = 0; l < blackKnightPieces.length; l++){
                                            let piece_xAxisValue = parseInt(blackKnightPieces[l].position.substr(6, 1));
                                            let piece_yAxisValue = parseInt(blackKnightPieces[l].position.substr(blackKnightPieces[l].position.length -1, 1));
                                            let possibleMoves = blackKnightPieces[l].possibleMove(piece_xAxisValue, piece_yAxisValue, attacker_xAxisValue+k, attacker_yAxisValue-k);

                                            for(let m = 0; m < possibleMoves.length; m++) {
                                                if (possibleMoves[m] === `.cell_${attacker_xAxisValue+k}_${attacker_yAxisValue-k}`){
                                                    isCheckMate = false;
                                                    break;
                                                }
                                            }

                                            if (isCheckMate === false) {
                                                break;
                                            }

                                        } // if black knight pieces can defend or block the enemy end

                                        if (isCheckMate === false) {
                                            break;
                                        } 

                                        // check if bishop pieces can block the attacker
                                        for(let l = 0; l < blackBishopPieces.length; l++){
                                            let piece_xAxisValue = parseInt(blackBishopPieces[l].position.substr(6, 1));
                                            let piece_yAxisValue = parseInt(blackBishopPieces[l].position.substr(blackBishopPieces[l].position.length -1, 1));
                                            let possibleMoves = blackBishopPieces[l].possibleMove(piece_xAxisValue, piece_yAxisValue, attacker_xAxisValue+k, attacker_yAxisValue-k);

                                            for(let m = 0; m < possibleMoves.length; m++) {
                                                if (possibleMoves[m] === `.cell_${attacker_xAxisValue+k}_${attacker_yAxisValue-k}`){
                                                    isCheckMate = false;
                                                    break;
                                                }
                                            }

                                            if (isCheckMate === false) {
                                                break;
                                            }

                                        } // if black knight pieces can defend or block the enemy end

                                        if (isCheckMate === false) {
                                            break;
                                        } 

                                        // check if rook pieces can block the attacker
                                        for(let l = 0; l < blackRookPieces.length; l++){
                                            let piece_xAxisValue = parseInt(blackRookPieces[l].position.substr(6, 1));
                                            let piece_yAxisValue = parseInt(blackRookPieces[l].position.substr(blackRookPieces[l].position.length -1, 1));
                                            let possibleMoves = blackRookPieces[l].possibleMove(piece_xAxisValue, piece_yAxisValue, attacker_xAxisValue+k, attacker_yAxisValue-k, true);

                                            for(let m = 0; m < possibleMoves.length; m++) {
                                                if (possibleMoves[m] === `.cell_${attacker_xAxisValue+k}_${attacker_yAxisValue-k}`){
                                                    isCheckMate = false;
                                                    break;
                                                }
                                            }

                                            if (isCheckMate === false) {
                                                break;
                                            }

                                        } // if black rook pieces can defend or block the enemy end

                                        if (isCheckMate === false) {
                                            break;
                                        } 

                                        // check if queen piece can block the attacker
                                        for(let l = 0; l < blackQueenPiece.length; l++){
                                            let piece_xAxisValue = parseInt(blackQueenPiece[l].position.substr(6, 1));
                                            let piece_yAxisValue = parseInt(blackQueenPiece[l].position.substr(blackQueenPiece[l].position.length -1, 1));
                                            let possibleMoves = blackQueenPiece[l].possibleMove(piece_xAxisValue, piece_yAxisValue, attacker_xAxisValue+k, attacker_yAxisValue-k);

                                            for(let m = 0; m < possibleMoves.length; m++) {
                                                if (possibleMoves[m] === `.cell_${attacker_xAxisValue+k}_${attacker_yAxisValue-k}`){
                                                    isCheckMate = false;
                                                    break;
                                                }
                                            }

                                            if (isCheckMate === false) {
                                                break;
                                            }

                                        } // if black queen piece can defend or block the enemy end

                                        if (isCheckMate === false) {
                                            break;
                                        } 

                                    } // looping done
                                } // attacker is top right, king is bottom left end

                                // attacker is top right, king is bottom right start
                                if(diff_xValue < 0 && diff_yValue < 0) {
                                    for (let k = 1; k < Math.abs(diff_xValue); k++) {

                                        // check if pawn pieces can block the attacker
                                        for(let l = 0; l < blackPawnPieces.length; l++){
                                            let piece_xAxisValue = parseInt(blackPawnPieces[l].position.substr(6, 1));
                                            let piece_yAxisValue = parseInt(blackPawnPieces[l].position.substr(blackPawnPieces[l].position.length -1, 1));
                                            let possibleMoves = blackPawnPieces[l].possibleMove(piece_xAxisValue, piece_yAxisValue, true, attacker_xAxisValue+k, attacker_yAxisValue+k);

                                            for(let m = 0; m < possibleMoves.length; m++) {
                                                if (possibleMoves[m] === `.cell_${attacker_xAxisValue+k}_${attacker_yAxisValue+k}`){
                                                    isCheckMate = false;
                                                    break;
                                                }
                                            }

                                            if (isCheckMate === false) {
                                                break;
                                            }

                                        } // if black pawn pieces can defend or block the enemy end

                                        if (isCheckMate === false) {
                                            break;
                                        } 
                                        
                                        // check if knight pieces can block the attacker
                                        for(let l = 0; l < blackKnightPieces.length; l++){
                                            let piece_xAxisValue = parseInt(blackKnightPieces[l].position.substr(6, 1));
                                            let piece_yAxisValue = parseInt(blackKnightPieces[l].position.substr(blackKnightPieces[l].position.length -1, 1));
                                            let possibleMoves = blackKnightPieces[l].possibleMove(piece_xAxisValue, piece_yAxisValue, attacker_xAxisValue+k, attacker_yAxisValue+k);

                                            for(let m = 0; m < possibleMoves.length; m++) {
                                                if (possibleMoves[m] === `.cell_${attacker_xAxisValue+k}_${attacker_yAxisValue+k}`){
                                                    isCheckMate = false;
                                                    break;
                                                }
                                            }

                                            if (isCheckMate === false) {
                                                break;
                                            }

                                        } // if black knight pieces can defend or block the enemy end

                                        if (isCheckMate === false) {
                                            break;
                                        } 

                                        // check if bishop pieces can block the attacker
                                        for(let l = 0; l < blackBishopPieces.length; l++){
                                            let piece_xAxisValue = parseInt(blackBishopPieces[l].position.substr(6, 1));
                                            let piece_yAxisValue = parseInt(blackBishopPieces[l].position.substr(blackBishopPieces[l].position.length -1, 1));
                                            let possibleMoves = blackBishopPieces[l].possibleMove(piece_xAxisValue, piece_yAxisValue, attacker_xAxisValue+k, attacker_yAxisValue+k);

                                            for(let m = 0; m < possibleMoves.length; m++) {
                                                if (possibleMoves[m] === `.cell_${attacker_xAxisValue+k}_${attacker_yAxisValue+k}`){
                                                    isCheckMate = false;
                                                    break;
                                                }
                                            }

                                            if (isCheckMate === false) {
                                                break;
                                            }

                                        } // if black knight pieces can defend or block the enemy end

                                        if (isCheckMate === false) {
                                            break;
                                        } 

                                        // check if rook pieces can block the attacker
                                        for(let l = 0; l < blackRookPieces.length; l++){
                                            let piece_xAxisValue = parseInt(blackRookPieces[l].position.substr(6, 1));
                                            let piece_yAxisValue = parseInt(blackRookPieces[l].position.substr(blackRookPieces[l].position.length -1, 1));
                                            let possibleMoves = blackRookPieces[l].possibleMove(piece_xAxisValue, piece_yAxisValue, attacker_xAxisValue+k, attacker_yAxisValue+k, true);

                                            for(let m = 0; m < possibleMoves.length; m++) {
                                                if (possibleMoves[m] === `.cell_${attacker_xAxisValue+k}_${attacker_yAxisValue+k}`){
                                                    isCheckMate = false;
                                                    break;
                                                }
                                            }

                                            if (isCheckMate === false) {
                                                break;
                                            }

                                        } // if black rook pieces can defend or block the enemy end

                                        if (isCheckMate === false) {
                                            break;
                                        } 

                                        // check if queen piece can block the attacker
                                        for(let l = 0; l < blackQueenPiece.length; l++){
                                            let piece_xAxisValue = parseInt(blackQueenPiece[l].position.substr(6, 1));
                                            let piece_yAxisValue = parseInt(blackQueenPiece[l].position.substr(blackQueenPiece[l].position.length -1, 1));
                                            let possibleMoves = blackQueenPiece[l].possibleMove(piece_xAxisValue, piece_yAxisValue, attacker_xAxisValue+k, attacker_yAxisValue+k);

                                            for(let m = 0; m < possibleMoves.length; m++) {
                                                if (possibleMoves[m] === `.cell_${attacker_xAxisValue+k}_${attacker_yAxisValue+k}`){
                                                    isCheckMate = false;
                                                    break;
                                                }
                                            }

                                            if (isCheckMate === false) {
                                                break;
                                            }

                                        } // if black queen piece can defend or block the enemy end

                                        if (isCheckMate === false) {
                                            break;
                                        } 

                                    } // looping done
                                } // attacker is top right, king is bottom right end
                            }
                        } // checked if it is all white queen and white bishop


                        // if the attacker is black rook or black queen
                        if (attackerPieceName.includes("blackRook") || attackerPieceName.includes("blackQueen")){
                            if(attacker_xAxisValue === king_xAxisValue) {   
                                let diff_yValue = attacker_yAxisValue - king_yAxisValue;
                                if (diff_yValue > 0){
                                    // positive value: king is at the left and rook is at the right
                                    // rook or queen movement infiltration
                                    for(let k = 1; k < diff_yValue; k++){

                                        // // if white pawn pieces can defend or block the enemy start
                                        for(let l = 0; l < whitePawnPieces.length; l++){
                                            let piece_xAxisValue = parseInt(whitePawnPieces[l].position.substr(6, 1));
                                            let piece_yAxisValue = parseInt(whitePawnPieces[l].position.substr(whitePawnPieces[l].position.length -1, 1));
                                            let possibleMoves = whitePawnPieces[l].possibleMove(piece_xAxisValue, piece_yAxisValue, true, attacker_xAxisValue, attacker_yAxisValue-k);

                                            for(let m = 0; m < possibleMoves.length; m++) {
                                                if (possibleMoves[m] === `.cell_${attacker_xAxisValue}_${attacker_yAxisValue-k}`){
                                                    isCheckMate = false;
                                                    break;
                                                }
                                            }

                                            if (isCheckMate === false) {
                                                break;
                                            }

                                        } // if white pawn pieces can defend or block the enemy end

                                        if (isCheckMate === false) {
                                            break;
                                        }

                                        // // if white knight pieces can defend or block the enemy start
                                        for(let l = 0; l < whiteKnightPieces.length; l++){
                                            let piece_xAxisValue = parseInt(whiteKnightPieces[l].position.substr(6, 1));
                                            let piece_yAxisValue = parseInt(whiteKnightPieces[l].position.substr(whitekKnightPieces[l].position.length -1, 1));
                                            let possibleMoves = whitekKnightPieces[l].possibleMove(piece_xAxisValue, piece_yAxisValue, attacker_xAxisValue, attacker_yAxisValue-k);

                                            for(let m = 0; m < possibleMoves.length; m++) {
                                                if (possibleMoves[m] === `.cell_${attacker_xAxisValue}_${attacker_yAxisValue-k}`){
                                                    isCheckMate = false;
                                                    break;
                                                }
                                            }

                                            if (isCheckMate === false) {
                                                break;
                                            }

                                        } // if white knight pieces can defend or block the enemy end

                                        if (isCheckMate === false) {
                                            break;
                                        }

                                        // // if white bishop pieces can defend or block the enemy start
                                        for(let l = 0; l < whiteBishopPieces.length; l++){
                                            let piece_xAxisValue = parseInt(whiteBishopPieces[l].position.substr(6, 1));
                                            let piece_yAxisValue = parseInt(whiteBishopPieces[l].position.substr(whiteBishopPieces[l].position.length -1, 1));
                                            let possibleMoves = whiteBishopPieces[l].possibleMove(piece_xAxisValue, piece_yAxisValue, attacker_xAxisValue, attacker_yAxisValue-k);

                                            for(let m = 0; m < possibleMoves.length; m++) {
                                                if (possibleMoves[m] === `.cell_${attacker_xAxisValue}_${attacker_yAxisValue-k}`){
                                                    isCheckMate = false;
                                                    break;
                                                }
                                            }

                                            if (isCheckMate === false) {
                                                break;
                                            }

                                        } // if white bishop pieces can defend or block the enemy end

                                        if (isCheckMate === false) {
                                            break;
                                        }
                                        
                                        // // if white rook piece can defend or block the enemy start
                                        for(let l = 0; l < whiteRookPieces.length; l++){
                                            let piece_xAxisValue = parseInt(whiteRookPieces[l].position.substr(6, 1));
                                            let piece_yAxisValue = parseInt(whiteRookPieces[l].position.substr(whiteRookPieces[l].position.length -1, 1));
                                            let possibleMoves = whiteRookPieces[l].possibleMove(piece_xAxisValue, piece_yAxisValue, attacker_xAxisValue, attacker_yAxisValue-k, true);

                                            for(let m = 0; m < possibleMoves.length; m++) {
                                                if (possibleMoves[m] === `.cell_${attacker_xAxisValue}_${attacker_yAxisValue-k}`){
                                                    isCheckMate = false;
                                                    break;
                                                }
                                            }

                                            if (isCheckMate === false) {
                                                break;
                                            }

                                        } // if white rook piece can defend or block the enemy end

                                        if (isCheckMate === false) {
                                            break;
                                        }
                                        
                                        // // if white queen piece can defend or block the enemy start
                                        for(let l = 0; l < whiteQueenPiece.length; l++){
                                            let piece_xAxisValue = parseInt(whiteQueenPiece[l].position.substr(6, 1));
                                            let piece_yAxisValue = parseInt(whiteQueenPiece[l].position.substr(whiteQueenPiece[l].position.length -1, 1));
                                            let possibleMoves = whiteQueenPiece[l].possibleMove(piece_xAxisValue, piece_yAxisValue, attacker_xAxisValue, attacker_yAxisValue-k);

                                            for(let m = 0; m < possibleMoves.length; m++) {
                                                if (possibleMoves[m] === `.cell_${attacker_xAxisValue}_${attacker_yAxisValue-k}`){
                                                    isCheckMate = false;
                                                    break;
                                                }
                                            }

                                            if (isCheckMate === false) {
                                                break;
                                            }

                                        } // if white queen piece can defend or block the enemy end

                                        if (isCheckMate === false) {
                                            break;
                                        }   
                                        // check diff yvalue is bigger than 0
                                    } // for loop of movement end

                                // king is at the right rook is at the left
                                } else if (diff_yValue < 0) {
                                    // rook or queen movement infiltration
                                    for(let k = 1; k < Math.abs(diff_yValue); k++){

                                        // // if white pawn pieces can defend or block the enemy start
                                        for(let l = 0; l < whitePawnPieces.length; l++){
                                            let piece_xAxisValue = parseInt(whitePawnPieces[l].position.substr(6, 1));
                                            let piece_yAxisValue = parseInt(whitePawnPieces[l].position.substr(whitePawnPieces[l].position.length -1, 1));
                                            let possibleMoves = whitePawnPieces[l].possibleMove(piece_xAxisValue, piece_yAxisValue, true, attacker_xAxisValue, attacker_yAxisValue+k);

                                            for(let m = 0; m < possibleMoves.length; m++) {
                                                if (possibleMoves[m] === `.cell_${attacker_xAxisValue}_${attacker_yAxisValue+k}`){
                                                    isCheckMate = false;
                                                    break;
                                                }
                                            }

                                            if (isCheckMate === false) {
                                                break;
                                            }

                                        } // if white pawn pieces can defend or block the enemy end

                                        if (isCheckMate === false) {
                                            break;
                                        }

                                        // // if white knight pieces can defend or block the enemy start
                                        for(let l = 0; l < whiteKnightPieces.length; l++){
                                            let piece_xAxisValue = parseInt(whiteKnightPieces[l].position.substr(6, 1));
                                            let piece_yAxisValue = parseInt(whiteKnightPieces[l].position.substr(whiteKnightPieces[l].position.length -1, 1));
                                            let possibleMoves = whiteKnightPieces[l].possibleMove(piece_xAxisValue, piece_yAxisValue, attacker_xAxisValue, attacker_yAxisValue+k);

                                            for(let m = 0; m < possibleMoves.length; m++) {
                                                if (possibleMoves[m] === `.cell_${attacker_xAxisValue}_${attacker_yAxisValue+k}`){
                                                    isCheckMate = false;
                                                    break;
                                                }
                                            }

                                            if (isCheckMate === false) {
                                                break;
                                            }

                                        } // if white knight pieces can defend or block the enemy end

                                        if (isCheckMate === false) {
                                            break;
                                        }

                                        // // if white bishop pieces can defend or block the enemy start
                                        for(let l = 0; l < whiteBishopPieces.length; l++){
                                            let piece_xAxisValue = parseInt(whiteBishopPieces[l].position.substr(6, 1));
                                            let piece_yAxisValue = parseInt(whiteBishopPieces[l].position.substr(whiteBishopPieces[l].position.length -1, 1));
                                            let possibleMoves = whiteBishopPieces[l].possibleMove(piece_xAxisValue, piece_yAxisValue, attacker_xAxisValue, attacker_yAxisValue+k);

                                            for(let m = 0; m < possibleMoves.length; m++) {
                                                if (possibleMoves[m] === `.cell_${attacker_xAxisValue}_${attacker_yAxisValue+k}`){
                                                    isCheckMate = false;
                                                    break;
                                                }
                                            }

                                            if (isCheckMate === false) {
                                                break;
                                            }

                                        } // if white bishop pieces can defend or block the enemy end

                                        if (isCheckMate === false) {
                                            break;
                                        }

                                        // // if white rook piece can defend or block the enemy start
                                        for(let l = 0; l < whiteRookPieces.length; l++){
                                            let piece_xAxisValue = parseInt(whiteRookPieces[l].position.substr(6, 1));
                                            let piece_yAxisValue = parseInt(whiteRookPieces[l].position.substr(whiteRookPieces[l].position.length -1, 1));
                                            let possibleMoves = whiteRookPieces[l].possibleMove(piece_xAxisValue, piece_yAxisValue, attacker_xAxisValue, attacker_yAxisValue+k, true);

                                            for(let m = 0; m < possibleMoves.length; m++) {
                                                if (possibleMoves[m] === `.cell_${attacker_xAxisValue}_${attacker_yAxisValue+k}`){
                                                    isCheckMate = false;
                                                    break;
                                                }
                                            }

                                            if (isCheckMate === false) {
                                                break;
                                            }

                                        } // if white rook piece can defend or block the enemy end

                                        if (isCheckMate === false) {
                                            break;
                                        }

                                        // // if white queen piece can defend or block the enemy start
                                        for(let l = 0; l < whiteQueenPiece.length; l++){
                                            let piece_xAxisValue = parseInt(whiteQueenPiece[l].position.substr(6, 1));
                                            let piece_yAxisValue = parseInt(whiteQueenPiece[l].position.substr(whiteQueenPiece[l].position.length -1, 1));
                                            let possibleMoves = whiteQueenPiece[l].possibleMove(piece_xAxisValue, piece_yAxisValue, attacker_xAxisValue, attacker_yAxisValue+k);

                                            for(let m = 0; m < possibleMoves.length; m++) {
                                                if (possibleMoves[m] === `.cell_${attacker_xAxisValue}_${attacker_yAxisValue+k}`){
                                                    isCheckMate = false;
                                                    break;
                                                }
                                            }

                                            if (isCheckMate === false) {
                                                break;
                                            }

                                        } // if white queen piece can defend or block the enemy end

                                        if (isCheckMate === false) {
                                            break;
                                        }   
                                        // check diff yvalue is bigger than 0
                                    } // for loop of movement end
                                }
                            } // check for left and right rook or queen


                            // check for up and down
                            if(attacker_yAxisValue === king_yAxisValue) {   
                                let diff_xValue = attacker_xAxisValue - king_xAxisValue;
                                if (diff_xValue > 0){
                                    // positive value: king is at the up and rook is at the down
                                    // rook or queen movement infiltration
                                    for(let k = 1; k < diff_xValue; k++){

                                        // // if white pawn pieces can defend or block the enemy start
                                        for(let l = 0; l < whitePawnPieces.length; l++){
                                            let piece_xAxisValue = parseInt(whitePawnPieces[l].position.substr(6, 1));
                                            let piece_yAxisValue = parseInt(whitePawnPieces[l].position.substr(whitePawnPieces[l].position.length -1, 1));
                                            let possibleMoves = whitePawnPieces[l].possibleMove(piece_xAxisValue, piece_yAxisValue, true, attacker_xAxisValue-k, attacker_yAxisValue);

                                            for(let m = 0; m < possibleMoves.length; m++) {
                                                if (possibleMoves[m] === `.cell_${attacker_xAxisValue-k}_${attacker_yAxisValue}`){
                                                    isCheckMate = false;
                                                    break;
                                                }
                                            }

                                            if (isCheckMate === false) {
                                                break;
                                            }

                                        } // if white pawn pieces can defend or block the enemy end

                                        if (isCheckMate === false) {
                                            break;
                                        }

                                        // // if white knight pieces can defend or block the enemy start
                                        for(let l = 0; l < whiteKnightPieces.length; l++){
                                            let piece_xAxisValue = parseInt(whiteKnightPieces[l].position.substr(6, 1));
                                            let piece_yAxisValue = parseInt(whiteKnightPieces[l].position.substr(whiteKnightPieces[l].position.length -1, 1));
                                            let possibleMoves = whiteKnightPieces[l].possibleMove(piece_xAxisValue, piece_yAxisValue, attacker_xAxisValue-k, attacker_yAxisValue);

                                            for(let m = 0; m < possibleMoves.length; m++) {
                                                if (possibleMoves[m] === `.cell_${attacker_xAxisValue-k}_${attacker_yAxisValue}`){
                                                    isCheckMate = false;
                                                    break;
                                                }
                                            }

                                            if (isCheckMate === false) {
                                                break;
                                            }

                                        } // if white knight pieces can defend or block the enemy end

                                        if (isCheckMate === false) {
                                            break;
                                        }

                                        // // if white bishop pieces can defend or block the enemy start
                                        for(let l = 0; l < whiteBishopPieces.length; l++){
                                            let piece_xAxisValue = parseInt(whiteBishopPieces[l].position.substr(6, 1));
                                            let piece_yAxisValue = parseInt(whiteBishopPieces[l].position.substr(whiteBishopPieces[l].position.length -1, 1));
                                            let possibleMoves = whiteBishopPieces[l].possibleMove(piece_xAxisValue, piece_yAxisValue, attacker_xAxisValue-k, attacker_yAxisValue);

                                            for(let m = 0; m < possibleMoves.length; m++) {
                                                if (possibleMoves[m] === `.cell_${attacker_xAxisValue-k}_${attacker_yAxisValue}`){
                                                    isCheckMate = false;
                                                    break;
                                                }
                                            }

                                            if (isCheckMate === false) {
                                                break;
                                            }

                                        } // if white bishop pieces can defend or block the enemy end

                                        if (isCheckMate === false) {
                                            break;
                                        }
                                        
                                        // // if white rook piece can defend or block the enemy start
                                        for(let l = 0; l < whiteRookPieces.length; l++){
                                            let piece_xAxisValue = parseInt(whiteRookPieces[l].position.substr(6, 1));
                                            let piece_yAxisValue = parseInt(whiteRookPieces[l].position.substr(whiteRookPieces[l].position.length -1, 1));
                                            let possibleMoves = whiteRookPieces[l].possibleMove(piece_xAxisValue, piece_yAxisValue, attacker_xAxisValue-k, attacker_yAxisValue, true);

                                            for(let m = 0; m < possibleMoves.length; m++) {
                                                if (possibleMoves[m] === `.cell_${attacker_xAxisValue-k}_${attacker_yAxisValue}`){
                                                    isCheckMate = false;
                                                    break;
                                                }
                                            }

                                            if (isCheckMate === false) {
                                                break;
                                            }

                                        } // if white rook piece can defend or block the enemy end

                                        if (isCheckMate === false) {
                                            break;
                                        }
                                        
                                        // // if white queen piece can defend or block the enemy start
                                        for(let l = 0; l < whiteQueenPiece.length; l++){
                                            let piece_xAxisValue = parseInt(whiteQueenPiece[l].position.substr(6, 1));
                                            let piece_yAxisValue = parseInt(whiteQueenPiece[l].position.substr(whiteQueenPiece[l].position.length -1, 1));
                                            let possibleMoves = whiteQueenPiece[l].possibleMove(piece_xAxisValue, piece_yAxisValue, attacker_xAxisValue-k, attacker_yAxisValue);

                                            for(let m = 0; m < possibleMoves.length; m++) {
                                                if (possibleMoves[m] === `.cell_${attacker_xAxisValue-k}_${attacker_yAxisValue}`){
                                                    isCheckMate = false;
                                                    break;
                                                }
                                            }

                                            if (isCheckMate === false) {
                                                break;
                                            }

                                        } // if white queen piece can defend or block the enemy end

                                        if (isCheckMate === false) {
                                            break;
                                        }   
                                        // check diff yvalue is bigger than 0
                                    } // for loop of movement end

                                // king is at the bottom rook is at the top
                                } else if (diff_xValue < 0) {
                                    // rook or queen movement infiltration
                                    for(let k = 1; k < Math.abs(diff_xValue); k++){

                                        // // if white pawn pieces can defend or block the enemy start
                                        for(let l = 0; l < whitePawnPieces.length; l++){
                                            let piece_xAxisValue = parseInt(whitePawnPieces[l].position.substr(6, 1));
                                            let piece_yAxisValue = parseInt(whitePawnPieces[l].position.substr(whitePawnPieces[l].position.length -1, 1));
                                            let possibleMoves = whitePawnPieces[l].possibleMove(piece_xAxisValue, piece_yAxisValue, true, attacker_xAxisValue+k, attacker_yAxisValue);

                                            for(let m = 0; m < possibleMoves.length; m++) {
                                                if (possibleMoves[m] === `.cell_${attacker_xAxisValue+k}_${attacker_yAxisValue}`){
                                                    isCheckMate = false;
                                                    break;
                                                }
                                            }

                                            if (isCheckMate === false) {
                                                break;
                                            }

                                        } // if white pawn pieces can defend or block the enemy end

                                        if (isCheckMate === false) {
                                            break;
                                        }

                                        // // if white knight pieces can defend or block the enemy start
                                        for(let l = 0; l < whiteKnightPieces.length; l++){
                                            let piece_xAxisValue = parseInt(whiteKnightPieces[l].position.substr(6, 1));
                                            let piece_yAxisValue = parseInt(whiteKnightPieces[l].position.substr(whiteKnightPieces[l].position.length -1, 1));
                                            let possibleMoves = whiteKnightPieces[l].possibleMove(piece_xAxisValue, piece_yAxisValue, attacker_xAxisValue+k, attacker_yAxisValue);

                                            for(let m = 0; m < possibleMoves.length; m++) {
                                                if (possibleMoves[m] === `.cell_${attacker_xAxisValue+k}_${attacker_yAxisValue}`){
                                                    isCheckMate = false;
                                                    break;
                                                }
                                            }

                                            if (isCheckMate === false) {
                                                break;
                                            }

                                        } // if white knight pieces can defend or block the enemy end

                                        if (isCheckMate === false) {
                                            break;
                                        }

                                        // // if white bishop pieces can defend or block the enemy start
                                        for(let l = 0; l < whiteBishopPieces.length; l++){
                                            let piece_xAxisValue = parseInt(whiteBishopPieces[l].position.substr(6, 1));
                                            let piece_yAxisValue = parseInt(whiteBishopPieces[l].position.substr(whiteBishopPieces[l].position.length -1, 1));
                                            let possibleMoves = whiteBishopPieces[l].possibleMove(piece_xAxisValue, piece_yAxisValue, attacker_xAxisValue+k, attacker_yAxisValue);

                                            for(let m = 0; m < possibleMoves.length; m++) {
                                                if (possibleMoves[m] === `.cell_${attacker_xAxisValue+k}_${attacker_yAxisValue}`){
                                                    isCheckMate = false;
                                                    break;
                                                }
                                            }

                                            if (isCheckMate === false) {
                                                break;
                                            }

                                        } // if white bishop pieces can defend or block the enemy end

                                        if (isCheckMate === false) {
                                            break;
                                        }

                                        // // if white rook piece can defend or block the enemy start
                                        for(let l = 0; l < whiteRookPieces.length; l++){
                                            let piece_xAxisValue = parseInt(whiteRookPieces[l].position.substr(6, 1));
                                            let piece_yAxisValue = parseInt(whiteRookPieces[l].position.substr(whiteRookPieces[l].position.length -1, 1));
                                            let possibleMoves = whiteRookPieces[l].possibleMove(piece_xAxisValue, piece_yAxisValue, attacker_xAxisValue+k, attacker_yAxisValue, true);

                                            for(let m = 0; m < possibleMoves.length; m++) {
                                                if (possibleMoves[m] === `.cell_${attacker_xAxisValue+k}_${attacker_yAxisValue}`){
                                                    isCheckMate = false;
                                                    break;
                                                }
                                            }

                                            if (isCheckMate === false) {
                                                break;
                                            }

                                        } // if white rook piece can defend or block the enemy end

                                        if (isCheckMate === false) {
                                            break;
                                        }

                                        // // if white queen piece can defend or block the enemy start
                                        for(let l = 0; l < whiteQueenPiece.length; l++){
                                            let piece_xAxisValue = parseInt(whiteQueenPiece[l].position.substr(6, 1));
                                            let piece_yAxisValue = parseInt(whiteQueenPiece[l].position.substr(whiteQueenPiece[l].position.length -1, 1));
                                            let possibleMoves = whiteQueenPiece[l].possibleMove(piece_xAxisValue, piece_yAxisValue, attacker_xAxisValue+k, attacker_yAxisValue);

                                            for(let m = 0; m < possibleMoves.length; m++) {
                                                if (possibleMoves[m] === `.cell_${attacker_xAxisValue+k}_${attacker_yAxisValue}`){
                                                    isCheckMate = false;
                                                    break;
                                                }
                                            }

                                            if (isCheckMate === false) {
                                                break;
                                            }

                                        } // if white queen piece can defend or block the enemy end

                                        if (isCheckMate === false) {
                                            break;
                                        }   
                                        // check diff yvalue is bigger than 0

                                    } // for loop of movement end
                                } // end of diff_xValue is negative

                            } // check for up and down rook or queen
                        } // check for all white rook and white queen
                        ///////////////////

                        // if the attacker is black bishop or black queen
                        if (attackerPieceName.includes("blackQueen") || attackerPieceName.includes("blackBishop")){
                            let diff_xValue = attacker_xAxisValue - king_xAxisValue;
                            let diff_yValue = attacker_yAxisValue - king_yAxisValue;

                            // it has to be diagonal
                            if(Math.abs(diff_xValue) === Math.abs(diff_yValue)) {
                                
                                // attacker is bottom right, king is top left
                                if(diff_xValue > 0 && diff_yValue > 0) {
                                    for (let k = 1; k < Math.abs(diff_xValue); k++) {

                                        // check if pawn pieces can block the attacker
                                        for(let l = 0; l < whitePawnPieces.length; l++){
                                            let piece_xAxisValue = parseInt(whitePawnPieces[l].position.substr(6, 1));
                                            let piece_yAxisValue = parseInt(whitePawnPieces[l].position.substr(whitePawnPieces[l].position.length -1, 1));
                                            let possibleMoves = whitePawnPieces[l].possibleMove(piece_xAxisValue, piece_yAxisValue, true, attacker_xAxisValue-k, attacker_yAxisValue-k);

                                            for(let m = 0; m < possibleMoves.length; m++) {
                                                if (possibleMoves[m] === `.cell_${attacker_xAxisValue-k}_${attacker_yAxisValue-k}`){
                                                    isCheckMate = false;
                                                    break;
                                                }
                                            }

                                            if (isCheckMate === false) {
                                                break;
                                            }

                                        } // if white pawn pieces can defend or block the enemy end

                                        if (isCheckMate === false) {
                                            break;
                                        } 
                                        
                                        // check if knight pieces can block the attacker
                                        for(let l = 0; l < whiteKnightPieces.length; l++){
                                            let piece_xAxisValue = parseInt(whiteKnightPieces[l].position.substr(6, 1));
                                            let piece_yAxisValue = parseInt(whiteKnightPieces[l].position.substr(whiteKnightPieces[l].position.length -1, 1));
                                            let possibleMoves = whiteKnightPieces[l].possibleMove(piece_xAxisValue, piece_yAxisValue, attacker_xAxisValue-k, attacker_yAxisValue-k);

                                            for(let m = 0; m < possibleMoves.length; m++) {
                                                if (possibleMoves[m] === `.cell_${attacker_xAxisValue-k}_${attacker_yAxisValue-k}`){
                                                    isCheckMate = false;
                                                    break;
                                                }
                                            }

                                            if (isCheckMate === false) {
                                                break;
                                            }

                                        } // if white knight pieces can defend or block the enemy end

                                        if (isCheckMate === false) {
                                            break;
                                        } 

                                        // check if bishop pieces can block the attacker
                                        for(let l = 0; l < whiteBishopPieces.length; l++){
                                            let piece_xAxisValue = parseInt(whiteBishopPieces[l].position.substr(6, 1));
                                            let piece_yAxisValue = parseInt(whiteBishopPieces[l].position.substr(whiteBishopPieces[l].position.length -1, 1));
                                            let possibleMoves = whiteBishopPieces[l].possibleMove(piece_xAxisValue, piece_yAxisValue, attacker_xAxisValue-k, attacker_yAxisValue-k);

                                            for(let m = 0; m < possibleMoves.length; m++) {
                                                if (possibleMoves[m] === `.cell_${attacker_xAxisValue-k}_${attacker_yAxisValue-k}`){
                                                    isCheckMate = false;
                                                    break;
                                                }
                                            }

                                            if (isCheckMate === false) {
                                                break;
                                            }

                                        } // if white knight pieces can defend or block the enemy end

                                        if (isCheckMate === false) {
                                            break;
                                        } 

                                        // check if rook pieces can block the attacker
                                        for(let l = 0; l < whiteRookPieces.length; l++){
                                            let piece_xAxisValue = parseInt(whiteRookPieces[l].position.substr(6, 1));
                                            let piece_yAxisValue = parseInt(whiteRookPieces[l].position.substr(whiteRookPieces[l].position.length -1, 1));
                                            let possibleMoves = whiteRookPieces[l].possibleMove(piece_xAxisValue, piece_yAxisValue, attacker_xAxisValue-k, attacker_yAxisValue-k, true);

                                            for(let m = 0; m < possibleMoves.length; m++) {
                                                if (possibleMoves[m] === `.cell_${attacker_xAxisValue-k}_${attacker_yAxisValue-k}`){
                                                    isCheckMate = false;
                                                    break;
                                                }
                                            }

                                            if (isCheckMate === false) {
                                                break;
                                            }

                                        } // if white rook pieces can defend or block the enemy end

                                        if (isCheckMate === false) {
                                            break;
                                        } 

                                        // check if queen piece can block the attacker
                                        for(let l = 0; l < whiteQueenPiece.length; l++){
                                            let piece_xAxisValue = parseInt(whiteQueenPiece[l].position.substr(6, 1));
                                            let piece_yAxisValue = parseInt(whiteQueenPiece[l].position.substr(whiteQueenPiece[l].position.length -1, 1));
                                            let possibleMoves = whiteQueenPiece[l].possibleMove(piece_xAxisValue, piece_yAxisValue, attacker_xAxisValue-k, attacker_yAxisValue-k);

                                            for(let m = 0; m < possibleMoves.length; m++) {
                                                if (possibleMoves[m] === `.cell_${attacker_xAxisValue-k}_${attacker_yAxisValue-k}`){
                                                    isCheckMate = false;
                                                    break;
                                                }
                                            }

                                            if (isCheckMate === false) {
                                                break;
                                            }

                                        } // if white queen piece can defend or block the enemy end

                                        if (isCheckMate === false) {
                                            break;
                                        } 

                                    } // looping done
                                } // attacker is bottom right, king is top left end


                                // attacker is bottom left, king is top right
                                if(diff_xValue > 0 && diff_yValue < 0) {
                                    for (let k = 1; k < Math.abs(diff_xValue); k++) {

                                        // check if pawn pieces can block the attacker
                                        for(let l = 0; l < whitePawnPieces.length; l++){
                                            let piece_xAxisValue = parseInt(whitePawnPieces[l].position.substr(6, 1));
                                            let piece_yAxisValue = parseInt(whitePawnPieces[l].position.substr(whitePawnPieces[l].position.length -1, 1));
                                            let possibleMoves = whitePawnPieces[l].possibleMove(piece_xAxisValue, piece_yAxisValue, true, attacker_xAxisValue-k, attacker_yAxisValue+k);

                                            for(let m = 0; m < possibleMoves.length; m++) {
                                                if (possibleMoves[m] === `.cell_${attacker_xAxisValue-k}_${attacker_yAxisValue+k}`){
                                                    isCheckMate = false;
                                                    break;
                                                }
                                            }

                                            if (isCheckMate === false) {
                                                break;
                                            }

                                        } // if white pawn pieces can defend or block the enemy end

                                        if (isCheckMate === false) {
                                            break;
                                        } 
                                        
                                        // check if knight pieces can block the attacker
                                        for(let l = 0; l < whiteKnightPieces.length; l++){
                                            let piece_xAxisValue = parseInt(whiteKnightPieces[l].position.substr(6, 1));
                                            let piece_yAxisValue = parseInt(whiteKnightPieces[l].position.substr(whiteKnightPieces[l].position.length -1, 1));
                                            let possibleMoves = whiteKnightPieces[l].possibleMove(piece_xAxisValue, piece_yAxisValue, attacker_xAxisValue-k, attacker_yAxisValue+k);

                                            for(let m = 0; m < possibleMoves.length; m++) {
                                                if (possibleMoves[m] === `.cell_${attacker_xAxisValue-k}_${attacker_yAxisValue+k}`){
                                                    isCheckMate = false;
                                                    break;
                                                }
                                            }

                                            if (isCheckMate === false) {
                                                break;
                                            }

                                        } // if white knight pieces can defend or block the enemy end

                                        if (isCheckMate === false) {
                                            break;
                                        } 

                                        // check if bishop pieces can block the attacker
                                        for(let l = 0; l < whiteBishopPieces.length; l++){
                                            let piece_xAxisValue = parseInt(whiteBishopPieces[l].position.substr(6, 1));
                                            let piece_yAxisValue = parseInt(whiteBishopPieces[l].position.substr(whiteBishopPieces[l].position.length -1, 1));
                                            let possibleMoves = whiteBishopPieces[l].possibleMove(piece_xAxisValue, piece_yAxisValue, attacker_xAxisValue-k, attacker_yAxisValue+k);

                                            for(let m = 0; m < possibleMoves.length; m++) {
                                                if (possibleMoves[m] === `.cell_${attacker_xAxisValue-k}_${attacker_yAxisValue+k}`){
                                                    isCheckMate = false;
                                                    break;
                                                }
                                            }

                                            if (isCheckMate === false) {
                                                break;
                                            }

                                        } // if white bishop pieces can defend or block the enemy end

                                        if (isCheckMate === false) {
                                            break;
                                        } 

                                        // check if rook pieces can block the attacker
                                        for(let l = 0; l < whiteRookPieces.length; l++){
                                            let piece_xAxisValue = parseInt(whiteRookPieces[l].position.substr(6, 1));
                                            let piece_yAxisValue = parseInt(whiteRookPieces[l].position.substr(whiteRookPieces[l].position.length -1, 1));
                                            let possibleMoves = whiteRookPieces[l].possibleMove(piece_xAxisValue, piece_yAxisValue, attacker_xAxisValue-k, attacker_yAxisValue+k, true);

                                            for(let m = 0; m < possibleMoves.length; m++) {
                                                if (possibleMoves[m] === `.cell_${attacker_xAxisValue-k}_${attacker_yAxisValue+k}`){
                                                    isCheckMate = false;
                                                    break;
                                                }
                                            }

                                            if (isCheckMate === false) {
                                                break;
                                            }

                                        } // if white rook pieces can defend or block the enemy end

                                        if (isCheckMate === false) {
                                            break;
                                        } 

                                        // check if queen piece can block the attacker
                                        for(let l = 0; l < whiteQueenPiece.length; l++){
                                            let piece_xAxisValue = parseInt(whiteQueenPiece[l].position.substr(6, 1));
                                            let piece_yAxisValue = parseInt(whiteQueenPiece[l].position.substr(whiteQueenPiece[l].position.length -1, 1));
                                            let possibleMoves = whiteQueenPiece[l].possibleMove(piece_xAxisValue, piece_yAxisValue, attacker_xAxisValue-k, attacker_yAxisValue+k);

                                            for(let m = 0; m < possibleMoves.length; m++) {
                                                if (possibleMoves[m] === `.cell_${attacker_xAxisValue-k}_${attacker_yAxisValue+k}`){
                                                    isCheckMate = false;
                                                    break;
                                                }
                                            }

                                            if (isCheckMate === false) {
                                                break;
                                            }

                                        } // if white queen piece can defend or block the enemy end

                                        if (isCheckMate === false) {
                                            break;
                                        } 

                                    } // looping done
                                } // attacker is bottom left, king is top right end


                                // attacker is top right, king is down left
                                if(diff_xValue < 0 && diff_yValue > 0) {
                                    for (let k = 1; k < Math.abs(diff_xValue); k++) {

                                        // check if pawn pieces can block the attacker
                                        for(let l = 0; l < whitePawnPieces.length; l++){
                                            let piece_xAxisValue = parseInt(whitePawnPieces[l].position.substr(6, 1));
                                            let piece_yAxisValue = parseInt(whitePawnPieces[l].position.substr(whitePawnPieces[l].position.length -1, 1));
                                            let possibleMoves = whitePawnPieces[l].possibleMove(piece_xAxisValue, piece_yAxisValue, true, attacker_xAxisValue+k, attacker_yAxisValue-k);

                                            for(let m = 0; m < possibleMoves.length; m++) {
                                                if (possibleMoves[m] === `.cell_${attacker_xAxisValue+k}_${attacker_yAxisValue-k}`){
                                                    isCheckMate = false;
                                                    break;
                                                }
                                            }

                                            if (isCheckMate === false) {
                                                break;
                                            }

                                        } // if white pawn pieces can defend or block the enemy end

                                        if (isCheckMate === false) {
                                            break;
                                        } 
                                        
                                        // check if knight pieces can block the attacker
                                        for(let l = 0; l < whiteKnightPieces.length; l++){
                                            let piece_xAxisValue = parseInt(whiteKnightPieces[l].position.substr(6, 1));
                                            let piece_yAxisValue = parseInt(whiteKnightPieces[l].position.substr(whiteKnightPieces[l].position.length -1, 1));
                                            let possibleMoves = whiteKnightPieces[l].possibleMove(piece_xAxisValue, piece_yAxisValue, attacker_xAxisValue+k, attacker_yAxisValue-k);

                                            for(let m = 0; m < possibleMoves.length; m++) {
                                                if (possibleMoves[m] === `.cell_${attacker_xAxisValue+k}_${attacker_yAxisValue-k}`){
                                                    isCheckMate = false;
                                                    break;
                                                }
                                            }

                                            if (isCheckMate === false) {
                                                break;
                                            }

                                        } // if white knight pieces can defend or block the enemy end

                                        if (isCheckMate === false) {
                                            break;
                                        } 

                                        // check if bishop pieces can block the attacker
                                        for(let l = 0; l < whiteBishopPieces.length; l++){
                                            let piece_xAxisValue = parseInt(whiteBishopPieces[l].position.substr(6, 1));
                                            let piece_yAxisValue = parseInt(whiteBishopPieces[l].position.substr(whiteBishopPieces[l].position.length -1, 1));
                                            let possibleMoves = whiteBishopPieces[l].possibleMove(piece_xAxisValue, piece_yAxisValue, attacker_xAxisValue+k, attacker_yAxisValue-k);

                                            for(let m = 0; m < possibleMoves.length; m++) {
                                                if (possibleMoves[m] === `.cell_${attacker_xAxisValue+k}_${attacker_yAxisValue-k}`){
                                                    isCheckMate = false;
                                                    break;
                                                }
                                            }

                                            if (isCheckMate === false) {
                                                break;
                                            }

                                        } // if white bishop pieces can defend or block the enemy end

                                        if (isCheckMate === false) {
                                            break;
                                        } 

                                        // check if rook pieces can block the attacker
                                        for(let l = 0; l < whiteRookPieces.length; l++){
                                            let piece_xAxisValue = parseInt(whiteRookPieces[l].position.substr(6, 1));
                                            let piece_yAxisValue = parseInt(whiteRookPieces[l].position.substr(whiteRookPieces[l].position.length -1, 1));
                                            let possibleMoves = whiteRookPieces[l].possibleMove(piece_xAxisValue, piece_yAxisValue, attacker_xAxisValue+k, attacker_yAxisValue-k, true);

                                            for(let m = 0; m < possibleMoves.length; m++) {
                                                if (possibleMoves[m] === `.cell_${attacker_xAxisValue+k}_${attacker_yAxisValue-k}`){
                                                    isCheckMate = false;
                                                    break;
                                                }
                                            }

                                            if (isCheckMate === false) {
                                                break;
                                            }

                                        } // if white rook pieces can defend or block the enemy end

                                        if (isCheckMate === false) {
                                            break;
                                        } 

                                        // check if queen piece can block the attacker
                                        for(let l = 0; l < whiteQueenPiece.length; l++){
                                            let piece_xAxisValue = parseInt(whiteQueenPiece[l].position.substr(6, 1));
                                            let piece_yAxisValue = parseInt(whiteQueenPiece[l].position.substr(whiteQueenPiece[l].position.length -1, 1));
                                            let possibleMoves = whiteQueenPiece[l].possibleMove(piece_xAxisValue, piece_yAxisValue, attacker_xAxisValue+k, attacker_yAxisValue-k);

                                            for(let m = 0; m < possibleMoves.length; m++) {
                                                if (possibleMoves[m] === `.cell_${attacker_xAxisValue+k}_${attacker_yAxisValue-k}`){
                                                    isCheckMate = false;
                                                    break;
                                                }
                                            }

                                            if (isCheckMate === false) {
                                                break;
                                            }

                                        } // if white queen piece can defend or block the enemy end

                                        if (isCheckMate === false) {
                                            break;
                                        } 

                                    } // looping done
                                } // attacker is top right, king is bottom left end

                                // attacker is top right, king is bottom right start
                                if(diff_xValue < 0 && diff_yValue < 0) {
                                    for (let k = 1; k < Math.abs(diff_xValue); k++) {

                                        // check if pawn pieces can block the attacker
                                        for(let l = 0; l < whitePawnPieces.length; l++){
                                            let piece_xAxisValue = parseInt(whitePawnPieces[l].position.substr(6, 1));
                                            let piece_yAxisValue = parseInt(whitePawnPieces[l].position.substr(whitePawnPieces[l].position.length -1, 1));
                                            let possibleMoves = whitePawnPieces[l].possibleMove(piece_xAxisValue, piece_yAxisValue, true, attacker_xAxisValue+k, attacker_yAxisValue+k);

                                            for(let m = 0; m < possibleMoves.length; m++) {
                                                if (possibleMoves[m] === `.cell_${attacker_xAxisValue+k}_${attacker_yAxisValue+k}`){
                                                    isCheckMate = false;
                                                    break;
                                                }
                                            }

                                            if (isCheckMate === false) {
                                                break;
                                            }

                                        } // if white pawn pieces can defend or block the enemy end

                                        if (isCheckMate === false) {
                                            break;
                                        } 
                                        
                                        // check if knight pieces can block the attacker
                                        for(let l = 0; l < whiteKnightPieces.length; l++){
                                            let piece_xAxisValue = parseInt(whiteKnightPieces[l].position.substr(6, 1));
                                            let piece_yAxisValue = parseInt(whiteKnightPieces[l].position.substr(whiteKnightPieces[l].position.length -1, 1));
                                            let possibleMoves = whiteKnightPieces[l].possibleMove(piece_xAxisValue, piece_yAxisValue, attacker_xAxisValue+k, attacker_yAxisValue+k);

                                            for(let m = 0; m < possibleMoves.length; m++) {
                                                if (possibleMoves[m] === `.cell_${attacker_xAxisValue+k}_${attacker_yAxisValue+k}`){
                                                    isCheckMate = false;
                                                    break;
                                                }
                                            }

                                            if (isCheckMate === false) {
                                                break;
                                            }

                                        } // if white knight pieces can defend or block the enemy end

                                        if (isCheckMate === false) {
                                            break;
                                        } 

                                        // check if bishop pieces can block the attacker
                                        for(let l = 0; l < whiteBishopPieces.length; l++){
                                            let piece_xAxisValue = parseInt(whiteBishopPieces[l].position.substr(6, 1));
                                            let piece_yAxisValue = parseInt(whiteBishopPieces[l].position.substr(whiteBishopPieces[l].position.length -1, 1));
                                            let possibleMoves = whiteBishopPieces[l].possibleMove(piece_xAxisValue, piece_yAxisValue, attacker_xAxisValue+k, attacker_yAxisValue+k);

                                            for(let m = 0; m < possibleMoves.length; m++) {
                                                if (possibleMoves[m] === `.cell_${attacker_xAxisValue+k}_${attacker_yAxisValue+k}`){
                                                    isCheckMate = false;
                                                    break;
                                                }
                                            }

                                            if (isCheckMate === false) {
                                                break;
                                            }

                                        } // if white knight pieces can defend or block the enemy end

                                        if (isCheckMate === false) {
                                            break;
                                        } 

                                        // check if rook pieces can block the attacker
                                        for(let l = 0; l < whiteRookPieces.length; l++){
                                            let piece_xAxisValue = parseInt(whiteRookPieces[l].position.substr(6, 1));
                                            let piece_yAxisValue = parseInt(whiteRookPieces[l].position.substr(whiteRookPieces[l].position.length -1, 1));
                                            let possibleMoves = whiteRookPieces[l].possibleMove(piece_xAxisValue, piece_yAxisValue, attacker_xAxisValue+k, attacker_yAxisValue+k, true);

                                            for(let m = 0; m < possibleMoves.length; m++) {
                                                if (possibleMoves[m] === `.cell_${attacker_xAxisValue+k}_${attacker_yAxisValue+k}`){
                                                    isCheckMate = false;
                                                    break;
                                                }
                                            }

                                            if (isCheckMate === false) {
                                                break;
                                            }

                                        } // if white rook pieces can defend or block the enemy end

                                        if (isCheckMate === false) {
                                            break;
                                        } 

                                        // check if queen piece can block the attacker
                                        for(let l = 0; l < whiteQueenPiece.length; l++){
                                            let piece_xAxisValue = parseInt(whiteQueenPiece[l].position.substr(6, 1));
                                            let piece_yAxisValue = parseInt(whiteQueenPiece[l].position.substr(whiteQueenPiece[l].position.length -1, 1));
                                            let possibleMoves = whiteQueenPiece[l].possibleMove(piece_xAxisValue, piece_yAxisValue, attacker_xAxisValue+k, attacker_yAxisValue+k);

                                            for(let m = 0; m < possibleMoves.length; m++) {
                                                if (possibleMoves[m] === `.cell_${attacker_xAxisValue+k}_${attacker_yAxisValue+k}`){
                                                    isCheckMate = false;
                                                    break;
                                                }
                                            }

                                            if (isCheckMate === false) {
                                                break;
                                            }

                                        } // if white queen piece can defend or block the enemy end

                                        if (isCheckMate === false) {
                                            break;
                                        } 

                                    } // looping done
                                } // attacker is top right, king is bottom right end
                            }
                        } // checked if it is all black queen and black bishop




                    }

                    return isCheckMate
                
                } // end of checkmate function


                // defending Moves start
                defendingMoves(defenderPiece, defenderCoordinate, attackerPiece, attackerCoordinate, movementType) {
                    let defenderPieceName = defenderPiece.getAttribute('alt');
                    let attackerPieceName = attackerPiece.getAttribute('alt');
                    let defendingMovements = [];
                    let foundIdx = 0;
                    let attacker_xAxisValue = parseInt(attackerCoordinate.substr(6, 1));
                    let attacker_yAxisValue = parseInt(attackerCoordinate.substr(attackerCoordinate.length -1, 1));
                    let defender_xAxisValue = parseInt(defenderCoordinate.substr(6, 1));
                    let defender_yAxisValue = parseInt(defenderCoordinate.substr(defenderCoordinate.length - 1, 1));
                    let king_xAxisValue = parseInt(this.position.substr(6, 1));
                    let king_yAxisValue = parseInt(this.position.substr(this.position.length -1, 1));

                    switch (movementType) {
                        case "eat":
                            
                            // check if defender piece can capture attacker
                            let piece_xAxisValue;
                            let piece_yAxisValue;
                            let eatingMoves;
                            let possibleMoves;


                            switch (defenderPieceName) {
                                case "blackPawn":
                                    foundIdx =  blackPawnPieces.findIndex(function(eachPiece) {return eachPiece.position === defenderCoordinate});
                                    piece_xAxisValue = parseInt(blackPawnPieces[foundIdx].position.substr(6, 1));
                                    piece_yAxisValue = parseInt(blackPawnPieces[foundIdx].position.substr(blackPawnPieces[foundIdx].position.length - 1, 1));
                                    eatingMoves = blackPawnPieces[foundIdx].eatingPossibility(piece_xAxisValue, piece_yAxisValue, true);

                                    for(let j = 0; j < eatingMoves.length; j++){
                                        if (eatingMoves[j] === attackerCoordinate) {
                                            defendingMovements.push(eatingMoves[j]);
                                            break;
                                        }
                                    } // inner for each loop for pawn pieces possible moves(to eat the enemy)
                                    break;
                                
                                case "blackKnight":
                                    foundIdx =  blackKnightPieces.findIndex(function(eachPiece) {return eachPiece.position === defenderCoordinate});
                                    piece_xAxisValue = parseInt(blackKnightPieces[foundIdx].position.substr(6, 1));
                                    piece_yAxisValue = parseInt(blackKnightPieces[foundIdx].position.substr(blackKnightPieces[foundIdx].position.length - 1, 1));
                                    eatingMoves = blackKnightPieces[foundIdx].possibleMove(piece_xAxisValue, piece_yAxisValue, attacker_xAxisValue, attacker_yAxisValue);

                                    for(let j = 0; j < eatingMoves.length; j++){
                                        if (eatingMoves[j] === attackerCoordinate) {
                                            defendingMovements.push(eatingMoves[j]);
                                            break;
                                        }
                                    } // inner for each loop for pawn pieces possible moves(to eat the enemy)
                                    break;
                                
                                case "blackBishop":
                                    foundIdx =  blackBishopPieces.findIndex(function(eachPiece) {return eachPiece.position === defenderCoordinate});
                                    piece_xAxisValue = parseInt(blackBishopPieces[foundIdx].position.substr(6, 1));
                                    piece_yAxisValue = parseInt(blackBishopPieces[foundIdx].position.substr(blackBishopPieces[foundIdx].position.length - 1, 1));
                                    eatingMoves = blackBishopPieces[foundIdx].eatingPossibility(piece_xAxisValue, piece_yAxisValue, attacker_xAxisValue, attacker_yAxisValue);

                                    for(let j = 0; j < eatingMoves.length; j++){
                                        if (eatingMoves[j] === attackerCoordinate) {
                                            defendingMovements.push(eatingMoves[j]);
                                            break;
                                        }
                                    } // inner for each loop for pawn pieces possible moves(to eat the enemy)
                                    break;
                                
                                case "blackRook":
                                    foundIdx =  blackRookPieces.findIndex(function(eachPiece) {return eachPiece.position === defenderCoordinate});
                                    piece_xAxisValue = parseInt(blackRookPieces[foundIdx].position.substr(6, 1));
                                    piece_yAxisValue = parseInt(blackRookPieces[foundIdx].position.substr(blackRookPieces[foundIdx].position.length - 1, 1));
                                    eatingMoves = blackRookPieces[foundIdx].eatingPossibility(piece_xAxisValue, piece_yAxisValue, attacker_xAxisValue, attacker_yAxisValue, true);

                                    for(let j = 0; j < eatingMoves.length; j++){
                                        if (eatingMoves[j] === attackerCoordinate) {
                                            defendingMovements.push(eatingMoves[j]);
                                            break;
                                        }
                                    } // inner for each loop for pawn pieces possible moves(to eat the enemy)
                                    break;
                                
                                case "blackQueen":
                                    foundIdx =  blackQueenPiece.findIndex(function(eachPiece) {return eachPiece.position === defenderCoordinate});
                                    piece_xAxisValue = parseInt(blackQueenPiece[foundIdx].position.substr(6, 1));
                                    piece_yAxisValue = parseInt(blackQueenPiece[foundIdx].position.substr(blackQueenPiece[foundIdx].position.length - 1, 1));
                                    eatingMoves = blackQueenPiece[foundIdx].eatingPossibility(piece_xAxisValue, piece_yAxisValue, attacker_xAxisValue, attacker_yAxisValue);

                                    for(let j = 0; j < eatingMoves.length; j++){
                                        if (eatingMoves[j] === attackerCoordinate) {
                                            defendingMovements.push(eatingMoves[j]);
                                            break;
                                        }
                                    } // inner for each loop for pawn pieces possible moves(to eat the enemy)
                                    break;

                                case "blackKing":
                                    foundIdx =  blackKingPiece.findIndex(function(eachPiece) {return eachPiece.position === defenderCoordinate});
                                    piece_xAxisValue = parseInt(blackKingPiece[foundIdx].position.substr(6, 1));
                                    piece_yAxisValue = parseInt(blackKingPiece[foundIdx].position.substr(blackKingPiece[foundIdx].position.length - 1, 1));
                                    eatingMoves = blackKingPiece[foundIdx].possibleMove(piece_xAxisValue, piece_yAxisValue, true);

                                    for(let j = 0; j < eatingMoves.length; j++){
                                        if (eatingMoves[j] === attackerCoordinate) {
                                            defendingMovements.push(eatingMoves[j]);
                                            break;
                                        }
                                    } // inner for each loop for pawn pieces possible moves(to eat the enemy)
                                    break;

                                case "whitePawn":
                                    foundIdx =  whitePawnPieces.findIndex(function(eachPiece) {return eachPiece.position === defenderCoordinate});
                                    piece_xAxisValue = parseInt(whitePawnPieces[foundIdx].position.substr(6, 1));
                                    piece_yAxisValue = parseInt(whitePawnPieces[foundIdx].position.substr(whitePawnPieces[foundIdx].position.length - 1, 1));
                                    eatingMoves = whiteKnightPieces[foundIdx].eatingPossibility(piece_xAxisValue, piece_yAxisValue, true);

                                    for(let j = 0; j < eatingMoves.length; j++){
                                        if (eatingMoves[j] === attackerCoordinate) {
                                            defendingMovements.push(eatingMoves[j]);
                                            break;
                                        }
                                    } // inner for each loop for pawn pieces possible moves(to eat the enemy)
                                    break;

                                case "whiteKnight":
                                    foundIdx =  whiteKnightPieces.findIndex(function(eachPiece) {return eachPiece.position === defenderCoordinate});
                                    piece_xAxisValue = parseInt(whiteKnightPieces[foundIdx].position.substr(6, 1));
                                    piece_yAxisValue = parseInt(whiteKnightPieces[foundIdx].position.substr(whiteKnightPieces[foundIdx].position.length - 1, 1));
                                    eatingMoves = whiteKnightPieces[foundIdx].possibleMove(piece_xAxisValue, piece_yAxisValue, attacker_xAxisValue, attacker_yAxisValue);

                                    for(let j = 0; j < eatingMoves.length; j++){
                                        if (eatingMoves[j] === attackerCoordinate) {
                                            defendingMovements.push(eatingMoves[j]);
                                            break;
                                        }
                                    } // inner for each loop for pawn pieces possible moves(to eat the enemy)
                                    break;

                                case "whiteBishop":
                                    foundIdx =  whiteBishopPieces.findIndex(function(eachPiece) {return eachPiece.position === defenderCoordinate});
                                    piece_xAxisValue = parseInt(whiteBishopPieces[foundIdx].position.substr(6, 1));
                                    piece_yAxisValue = parseInt(whiteBishopPieces[foundIdx].position.substr(whiteBishopPieces[foundIdx].position.length - 1, 1));
                                    eatingMoves = whiteBishopPieces[foundIdx].eatingPossibility(piece_xAxisValue, piece_yAxisValue, attacker_xAxisValue, attacker_yAxisValue);

                                    for(let j = 0; j < eatingMoves.length; j++){
                                        if (eatingMoves[j] === attackerCoordinate) {
                                            defendingMovements.push(eatingMoves[j]);
                                            break;
                                        }
                                    } // inner for each loop for pawn pieces possible moves(to eat the enemy)
                                    break;

                                case "whiteRook":
                                    foundIdx =  whiteRookPieces.findIndex(function(eachPiece) {return eachPiece.position === defenderCoordinate});
                                    piece_xAxisValue = parseInt(whiteRookPieces[foundIdx].position.substr(6, 1));
                                    piece_yAxisValue = parseInt(whiteRookPieces[foundIdx].position.substr(whiteRookPieces[foundIdx].position.length - 1, 1));
                                    eatingMoves = whiteRookPieces[foundIdx].eatingPossibility(piece_xAxisValue, piece_yAxisValue, attacker_xAxisValue, attacker_yAxisValue, true);

                                    for(let j = 0; j < eatingMoves.length; j++){
                                        if (eatingMoves[j] === attackerCoordinate) {
                                            defendingMovements.push(eatingMoves[j]);
                                            break;
                                        }
                                    } // inner for each loop for pawn pieces possible moves(to eat the enemy)
                                    break;

                                case "whiteQueen":
                                    foundIdx =  whiteQueenPiece.findIndex(function(eachPiece) {return eachPiece.position === defenderCoordinate});
                                    piece_xAxisValue = parseInt(whiteQueenPiece[foundIdx].position.substr(6, 1));
                                    piece_yAxisValue = parseInt(whiteQueenPiece[foundIdx].position.substr(whiteQueenPiece[foundIdx].position.length - 1, 1));
                                    eatingMoves = whiteQueenPiece[foundIdx].eatingPossibility(piece_xAxisValue, piece_yAxisValue, attacker_xAxisValue, attacker_yAxisValue);

                                    for(let j = 0; j < eatingMoves.length; j++){
                                        if (eatingMoves[j] === attackerCoordinate) {
                                            defendingMovements.push(eatingMoves[j]);
                                            break;
                                        }
                                    } // inner for each loop for pawn pieces possible moves(to eat the enemy)
                                    break;

                                case "whiteKing":
                                    foundIdx =  whiteKingPiece.findIndex(function(eachPiece) {return eachPiece.position === defenderCoordinate});
                                    piece_xAxisValue = parseInt(whiteKingPiece[foundIdx].position.substr(6, 1));
                                    piece_yAxisValue = parseInt(whiteKingPiece[foundIdx].position.substr(whiteKingPiece[foundIdx].position.length - 1, 1));
                                    eatingMoves = whiteKingPiece[foundIdx].possibleMove(piece_xAxisValue, piece_yAxisValue, true);

                                    for(let j = 0; j < eatingMoves.length; j++){
                                        if (eatingMoves[j] === attackerCoordinate) {
                                            defendingMovements.push(eatingMoves[j]);
                                            break;
                                        }
                                    } // inner for each loop for pawn pieces possible moves(to eat the enemy)
                                    break;
    
                                } // end of switch case for defender PieceName

                            
                            // check if blackPawn can capture that thing
                            break;
                        case "block":
                            ///// if piece is king or other piece
                            if (defenderPieceName.includes("King")) {
                                // king's move case
                                let kingPossibleMovement;
                                if (defenderPieceName.includes("black")) {
                                    kingPossibleMovement = blackKingPiece[0].possibleMove(defender_xAxisValue, defender_yAxisValue, true);
                                }

                                if (defenderPieceName.includes("white")) {
                                    kingPossibleMovement = whiteKingPiece[0].possibleMove(defender_xAxisValue, defender_yAxisValue, true);
                                }

                                let originLength = kingPossibleMovement.length;

                                 // filtering out unnecessary movements
                                let j = 0;
                                while(j < originLength){
                                    let xAxisValue = parseInt(kingPossibleMovement[j].substr(6, 1));
                                    let yAxisValue = parseInt(kingPossibleMovement[j].substr(kingPossibleMovement[j].length - 1, 1));

                                    if (xAxisValue == 0 || yAxisValue == 0 || xAxisValue == 9 || yAxisValue == 9){
                                        kingPossibleMovement.splice(j, 1)
                                        j--;
                                        originLength = kingPossibleMovement.length;
                                    }
                                    j++;
                                }

                                // if there is same color next to it, filter out as well
                                j = 0;
                                while(j < originLength){
                                    let xAxisValue = parseInt(kingPossibleMovement[j].substr(6, 1));
                                    let yAxisValue = parseInt(kingPossibleMovement[j].substr(kingPossibleMovement[j].length - 1, 1));
                                    let cell = document.querySelector(`.cell_${xAxisValue}_${yAxisValue}`);
                                    if (cell.querySelector("img")){
                                        let imageCell = cell.querySelector("img");
                                        if ((imageCell.getAttribute('alt').includes("white") && this.color === "white") || (imageCell.getAttribute('alt').includes("black") && this.color === "black")) {
                                            kingPossibleMovement.splice(j, 1);
                                            j--;
                                            originLength = kingPossibleMovement.length;
                                        }
                                    }
                                    j++;
                                }

                                /////////////////////// check king's movements
                                // Each king Movement
                                for(let i = 0; i < kingPossibleMovement.length; i++){
                                    let eachMovement_xAxisValue = parseInt(kingPossibleMovement[i].substr(6, 1));
                                    let eachMovement_yAxisValue = parseInt(kingPossibleMovement[i].substr(kingPossibleMovement[i].length -1, 1));
                                    let isDangerous = false;
                                    let needsBreak = false;

                                    // check left start rook queen
                                    if(eachMovement_yAxisValue == 1) {
                                        
                                    } else {
                                        for(let i = eachMovement_yAxisValue - 1; i >= 1; i--) {
                                            // if y axis value is one, then don't check left
                                            let leftPiece = document.querySelector(`.cell_${eachMovement_xAxisValue}_${i}`)
                                            
                                            switch(i) {
                                                case eachMovement_yAxisValue - 1:
                                                    if (leftPiece.querySelector("img")) {
                                                        let leftImagePiece = leftPiece.querySelector("img");
                                                        if((leftImagePiece.getAttribute('alt').includes("whiteRook") || leftImagePiece.getAttribute('alt').includes("whiteQueen") || leftImagePiece.getAttribute('alt').includes("whiteKing")) && (this.color === "black")) {  
                                                            needsBreak = true;
                                                            isDangerous = true;
                                                        } else if ((leftImagePiece.getAttribute('alt').includes("blackRook") || leftImagePiece.getAttribute('alt').includes("blackQueen") || leftImagePiece.getAttribute('alt').includes("blackKing")) && (this.color === "white")) {
                                                            needsBreak = true;
                                                            isDangerous = true;
                                                        } else if ((leftImagePiece.getAttribute('alt').includes("black") && this.color === "black" && (!leftImagePiece.getAttribute('alt').includes("blackKing")) ) || (leftImagePiece.getAttribute('alt').includes("white") && this.color === "white" && (!leftImagePiece.getAttribute('alt').includes("whiteKing")))) {
                                                            needsBreak = true;
                                                            isDangerous = false;
                                                        } else if (((!leftImagePiece.getAttribute('alt').includes("whiteRook")) && (!leftImagePiece.getAttribute('alt').includes("whiteQueen")) && (leftImagePiece.getAttribute('alt').includes("white")) && (this.color === "black")) || (((!leftImagePiece.getAttribute('alt').includes("blackRook")) && (!leftImagePiece.getAttribute('alt').includes("blackQueen")) && (leftImagePiece.getAttribute('alt').includes("black"))) && (this.color === "white"))) {  
                                                            needsBreak = true;
                                                            isDangerous = false;
                                                        }
                                                    } 
                                                    break;
                                                default:
                                                    if (leftPiece.querySelector("img")) {
                                                        let leftImagePiece = leftPiece.querySelector("img");
                                                        if((leftImagePiece.getAttribute('alt').includes("whiteRook") || leftImagePiece.getAttribute('alt').includes("whiteQueen")) && (this.color === "black")) {
                                                            needsBreak = true;
                                                            isDangerous = true;
                                                        } else if ((leftImagePiece.getAttribute('alt').includes("blackRook") || leftImagePiece.getAttribute('alt').includes("blackQueen")) && (this.color === "white")) {
                                                            needsBreak = true;
                                                            isDangerous = true;
                                                        } else if ((leftImagePiece.getAttribute('alt').includes("black") && this.color === "black" && (!leftImagePiece.getAttribute('alt').includes("blackKing")) ) || (leftImagePiece.getAttribute('alt').includes("white") && this.color === "white" && (!leftImagePiece.getAttribute('alt').includes("whiteKing")))) {
                                                            needsBreak = true;
                                                            isDangerous = false;
                                                        } else if (((!leftImagePiece.getAttribute('alt').includes("whiteRook")) && (!leftImagePiece.getAttribute('alt').includes("whiteQueen")) && (leftImagePiece.getAttribute('alt').includes("white")) && (this.color === "black")) || (((!leftImagePiece.getAttribute('alt').includes("blackRook")) && (!leftImagePiece.getAttribute('alt').includes("blackQueen")) && (leftImagePiece.getAttribute('alt').includes("black"))) && (this.color === "white"))) {  
                                                            needsBreak = true;
                                                            isDangerous = false;
                                                        }
                                                    }
                                                    
                                                    break;
                                            } // end of switch case

                                            if (needsBreak) {
                                                break;
                                            }
                                                
                                        } // end of inner for each statement left side
                                    } // check left finished

                                    // if isDangerous is true then go to the next outer for each element of loop so continue
                                    if (isDangerous) {
                                        continue;
                                    }
                                    
                                    // start over
                                    needsBreak = false;
                                    isDangerous = false;

                                    // check right rook and queen
                                    if(eachMovement_yAxisValue == 8) {
                                        
                                    } else {
                                        for(let i = eachMovement_yAxisValue + 1; i <= 8; i++) {
                                            let rightPiece = document.querySelector(`.cell_${eachMovement_xAxisValue}_${i}`)
                                            
                                            switch(i) {
                                                case eachMovement_yAxisValue + 1:
                                                    if (rightPiece.querySelector("img")) {
                                                        let rightImagePiece = rightPiece.querySelector("img");
                                                        if((rightImagePiece.getAttribute('alt').includes("whiteRook") || rightImagePiece.getAttribute('alt').includes("whiteQueen") || rightImagePiece.getAttribute('alt').includes("whiteKing")) && (this.color === "black")) {
                                                            needsBreak = true;
                                                            isDangerous = true;
                                                        } else if ((rightImagePiece.getAttribute('alt').includes("blackRook") || rightImagePiece.getAttribute('alt').includes("blackQueen") || rightImagePiece.getAttribute('alt').includes("blackKing")) && (this.color === "white")) {
                                                            needsBreak = true;
                                                            isDangerous = true;
                                                        } else if ((rightImagePiece.getAttribute('alt').includes("black") && this.color === "black" && (!rightImagePiece.getAttribute('alt').includes("blackKing")) ) || (rightImagePiece.getAttribute('alt').includes("white") && this.color === "white" && (!rightImagePiece.getAttribute('alt').includes("whiteKing")))) {
                                                            needsBreak = true;
                                                            isDangerous = false;
                                                        } else if (((!rightImagePiece.getAttribute('alt').includes("whiteRook")) && (!rightImagePiece.getAttribute('alt').includes("whiteQueen")) && (rightImagePiece.getAttribute('alt').includes("white")) && (this.color === "black")) || (((!rightImagePiece.getAttribute('alt').includes("blackRook")) && (!rightImagePiece.getAttribute('alt').includes("blackQueen")) && (rightImagePiece.getAttribute('alt').includes("black"))) && (this.color === "white"))) {  
                                                            needsBreak = true;
                                                            isDangerous = false;
                                                        }
                                                    } 
                                                    break;
                                                default:
                                                    if (rightPiece.querySelector("img")) {
                                                        let rightImagePiece = rightPiece.querySelector("img");
                                                        if((rightImagePiece.getAttribute('alt').includes("whiteRook") || rightImagePiece.getAttribute('alt').includes("whiteQueen")) && (this.color === "black")) {
                                                            needsBreak = true;
                                                            isDangerous = true;
                                                        } else if ((rightImagePiece.getAttribute('alt').includes("blackRook") || rightImagePiece.getAttribute('alt').includes("blackQueen")) && (this.color === "white")) {
                                                            needsBreak = true;
                                                            isDangerous = true;
                                                        } else if ((rightImagePiece.getAttribute('alt').includes("black") && this.color === "black" && (!rightImagePiece.getAttribute('alt').includes("blackKing")) ) || (rightImagePiece.getAttribute('alt').includes("white") && this.color === "white" && (!rightImagePiece.getAttribute('alt').includes("whiteKing")))) {
                                                            needsBreak = true;
                                                            isDangerous = false;
                                                        } else if (((!rightImagePiece.getAttribute('alt').includes("whiteRook")) && (!rightImagePiece.getAttribute('alt').includes("whiteQueen")) && (rightImagePiece.getAttribute('alt').includes("white")) && (this.color === "black")) || (((!rightImagePiece.getAttribute('alt').includes("blackRook")) && (!rightImagePiece.getAttribute('alt').includes("blackQueen")) && (rightImagePiece.getAttribute('alt').includes("black"))) && (this.color === "white"))) {  
                                                            needsBreak = true;
                                                            isDangerous = false;
                                                        }
                                                    }
                                                    
                                                    break;
                                            } // end of switch case

                                            if (needsBreak) {
                                                break;
                                            }

                                        } // end of inner for each statement
                                    } // End of checking right side statement

                                    // if isDangerous is true then go to the next outer for each element of loop so continue
                                    if (isDangerous) {
                                        continue;
                                    }
                                    
                                    // start over
                                    needsBreak = false;
                                    isDangerous = false;

                                    // check up rook and queen
                                    if(eachMovement_xAxisValue == 1) {
                                        
                                    } else {
                                        for(let i = eachMovement_xAxisValue - 1; i >= 1; i--) {
                                            let upPiece = document.querySelector(`.cell_${i}_${eachMovement_yAxisValue}`)
                                            
                                            switch(i) {
                                                case eachMovement_xAxisValue - 1:
                                                    if (upPiece.querySelector("img")) {
                                                        let upImagePiece = upPiece.querySelector("img");
                                                        if((upImagePiece.getAttribute('alt').includes("whiteRook") || upImagePiece.getAttribute('alt').includes("whiteQueen") || upImagePiece.getAttribute('alt').includes("whiteKing")) && (this.color === "black")) {
                                                            needsBreak = true;
                                                            isDangerous = true;
                                                        } else if ((upImagePiece.getAttribute('alt').includes("blackRook") || upImagePiece.getAttribute('alt').includes("blackQueen") || upImagePiece.getAttribute('alt').includes("blackKing")) && (this.color === "white")) {
                                                            needsBreak = true;
                                                            isDangerous = true;
                                                        } else if ((upImagePiece.getAttribute('alt').includes("black") && this.color === "black" && (!upImagePiece.getAttribute('alt').includes("blackKing")) ) || (upImagePiece.getAttribute('alt').includes("white") && this.color === "white" && (!upImagePiece.getAttribute('alt').includes("whiteKing")))) {
                                                            needsBreak = true;
                                                            isDangerous = false;
                                                        } else if (((!upImagePiece.getAttribute('alt').includes("whiteRook")) && (!upImagePiece.getAttribute('alt').includes("whiteQueen")) && (upImagePiece.getAttribute('alt').includes("white")) && (this.color === "black")) || (((!upImagePiece.getAttribute('alt').includes("blackRook")) && (!upImagePiece.getAttribute('alt').includes("blackQueen")) && (upImagePiece.getAttribute('alt').includes("black"))) && (this.color === "white"))) {  
                                                            needsBreak = true;
                                                            isDangerous = false;
                                                        }
                                                    } 
                                                    break;
                                                default:
                                                    if (upPiece.querySelector("img")) {
                                                        let upImagePiece = upPiece.querySelector("img");
                                                        if((upImagePiece.getAttribute('alt').includes("whiteRook") || upImagePiece.getAttribute('alt').includes("whiteQueen")) && (this.color === "black")) {
                                                            needsBreak = true;
                                                            isDangerous = true;
                                                        } else if ((upImagePiece.getAttribute('alt').includes("blackRook") || upImagePiece.getAttribute('alt').includes("blackQueen")) && (this.color === "white")) {
                                                            needsBreak = true;
                                                            isDangerous = true;
                                                        } else if ((upImagePiece.getAttribute('alt').includes("black") && this.color === "black" && (!upImagePiece.getAttribute('alt').includes("blackKing")) ) || (upImagePiece.getAttribute('alt').includes("white") && this.color === "white" && (!upImagePiece.getAttribute('alt').includes("whiteKing")))) {
                                                            needsBreak = true;
                                                            isDangerous = false;
                                                        } else if (((!upImagePiece.getAttribute('alt').includes("whiteRook")) && (!upImagePiece.getAttribute('alt').includes("whiteQueen")) && (upImagePiece.getAttribute('alt').includes("white")) && (this.color === "black")) || (((!upImagePiece.getAttribute('alt').includes("blackRook")) && (!upImagePiece.getAttribute('alt').includes("blackQueen")) && (upImagePiece.getAttribute('alt').includes("black"))) && (this.color === "white"))) {  
                                                            needsBreak = true;
                                                            isDangerous = false;
                                                        }
                                                    }
                                                    
                                                    break;
                                            } // end of switch case

                                            if (needsBreak) {
                                                break;
                                            }

                                        } // end of for each statement
                                    } // End of checking up side statement

                                    // if isDangerous is true then go to the next outer for each element of loop so continue
                                    if (isDangerous) {
                                        continue;
                                    }
                                    
                                    // start over
                                    needsBreak = false;
                                    isDangerous = false;

                                    // check down side statement queen and rook
                                    if(eachMovement_xAxisValue == 8) {
                                        
                                    } else {
                                        for(let i = eachMovement_xAxisValue + 1; i <= 8; i++) {
                                            let downPiece = document.querySelector(`.cell_${i}_${eachMovement_yAxisValue}`)
                                            
                                            switch(i) {
                                                case eachMovement_xAxisValue + 1:
                                                    if (downPiece.querySelector("img")) {
                                                        let downImagePiece = downPiece.querySelector("img");
                                                        if((downImagePiece.getAttribute('alt').includes("whiteRook") || downImagePiece.getAttribute('alt').includes("whiteQueen") || downImagePiece.getAttribute('alt').includes("whiteKing")) && (this.color === "black")) {
                                                            needsBreak = true;
                                                            isDangerous = true;
                                                        } else if ((downImagePiece.getAttribute('alt').includes("blackRook") || downImagePiece.getAttribute('alt').includes("blackQueen") || downImagePiece.getAttribute('alt').includes("blackKing")) && (this.color === "white")) {
                                                            needsBreak = true;
                                                            isDangerous = true;
                                                        } else if ((downImagePiece.getAttribute('alt').includes("black") && this.color === "black" && (!downImagePiece.getAttribute('alt').includes("blackKing")) ) || (downImagePiece.getAttribute('alt').includes("white") && this.color === "white" && (!downImagePiece.getAttribute('alt').includes("whiteKing")))) {
                                                            needsBreak = true;
                                                            isDangerous = false;
                                                        } else if (((!downImagePiece.getAttribute('alt').includes("whiteRook")) && (!downImagePiece.getAttribute('alt').includes("whiteQueen")) && (downImagePiece.getAttribute('alt').includes("white")) && (this.color === "black")) || (((!downImagePiece.getAttribute('alt').includes("blackRook")) && (!downImagePiece.getAttribute('alt').includes("blackQueen")) && (downImagePiece.getAttribute('alt').includes("black"))) && (this.color === "white"))) {  
                                                            needsBreak = true;
                                                            isDangerous = false;
                                                        }
                                                    } 
                                                    break;
                                                default:
                                                    if (downPiece.querySelector("img")) {
                                                        let downImagePiece = downPiece.querySelector("img");
                                                        if((downImagePiece.getAttribute('alt').includes("whiteRook") || downImagePiece.getAttribute('alt').includes("whiteQueen")) && (this.color === "black")) {
                                                            needsBreak = true;
                                                            isDangerous = true;
                                                        } else if ((downImagePiece.getAttribute('alt').includes("blackRook") || downImagePiece.getAttribute('alt').includes("blackQueen")) && (this.color === "white")) {
                                                            needsBreak = true;
                                                            isDangerous = true;
                                                        } else if ((downImagePiece.getAttribute('alt').includes("black") && this.color === "black" && (!downImagePiece.getAttribute('alt').includes("blackKing")) ) || (downImagePiece.getAttribute('alt').includes("white") && this.color === "white" && (!downImagePiece.getAttribute('alt').includes("whiteKing")))) {
                                                            needsBreak = true;
                                                            isDangerous = false;
                                                        } else if (((!downImagePiece.getAttribute('alt').includes("whiteRook")) && (!downImagePiece.getAttribute('alt').includes("whiteQueen")) && (downImagePiece.getAttribute('alt').includes("white")) && (this.color === "black")) || (((!downImagePiece.getAttribute('alt').includes("blackRook")) && (!downImagePiece.getAttribute('alt').includes("blackQueen")) && (downImagePiece.getAttribute('alt').includes("black"))) && (this.color === "white"))) {  
                                                            needsBreak = true;
                                                            isDangerous = false;
                                                        }
                                                    }
                                                    
                                                    break;
                                            } // end of switch case

                                            if (needsBreak) {
                                                break;
                                            }
                                        } // end of for each statement
                                    } // End of checking down side statement

                                    // if isDangerous is true then go to the next outer for each element of loop so continue
                                    if (isDangerous) {
                                        continue;
                                    }
                                    
                                    // start over
                                    needsBreak = false;
                                    isDangerous = false;

                                    // Checking diagonally left down
                                    if(eachMovement_yAxisValue == 1 || eachMovement_xAxisValue == 8) {
                                    
                                    } else {
                                        for(let i = 1; i <= 8; i++) {
                                            if (eachMovement_xAxisValue+i > 8 || eachMovement_yAxisValue-i < 1) {
                                                break;
                                            }
                                            let leftDownPiece = document.querySelector(`.cell_${eachMovement_xAxisValue+i}_${eachMovement_yAxisValue-i}`)
                                            
                                            switch(i) {
                                                case 1:
                                                    if (leftDownPiece.querySelector("img")) {
                                                        let leftDownImagePiece = leftDownPiece.querySelector("img");
                                                        if((leftDownImagePiece.getAttribute('alt').includes("whiteBishop") || leftDownImagePiece.getAttribute('alt').includes("whiteQueen") || leftDownImagePiece.getAttribute('alt').includes("whiteKing")) && (this.color === "black")) {
                                                            needsBreak = true;
                                                            isDangerous = true;
                                                        } else if ((leftDownImagePiece.getAttribute('alt').includes("blackBishop") || leftDownImagePiece.getAttribute('alt').includes("blackQueen") || leftDownImagePiece.getAttribute('alt').includes("blackKing")) && (this.color === "white")) {
                                                            needsBreak = true;
                                                            isDangerous = true;
                                                        } else if (((leftDownImagePiece.getAttribute('alt').includes("blackPawn") && this.color === "white") && (!this.blackUp)) || ((leftDownImagePiece.getAttribute('alt').includes("whitePawn") && this.color === "black") && (this.blackUp))) {
                                                            needsBreak = true;
                                                            isDangerous = true;
                                                        } else if ((leftDownImagePiece.getAttribute('alt').includes("black") && this.color === "black" && (!leftDownImagePiece.getAttribute('alt').includes("blackKing")) ) || (leftDownImagePiece.getAttribute('alt').includes("white") && this.color === "white" && (!leftDownImagePiece.getAttribute('alt').includes("whiteKing")))) {
                                                            needsBreak = true;
                                                            isDangerous = false;
                                                        } else if (((!leftDownImagePiece.getAttribute('alt').includes("whiteBishop")) && (!leftDownImagePiece.getAttribute('alt').includes("whiteQueen")) && (leftDownImagePiece.getAttribute('alt').includes("white")) && (this.color === "black")) || (((!leftDownImagePiece.getAttribute('alt').includes("blackBishop")) && (!leftDownImagePiece.getAttribute('alt').includes("blackQueen")) && (leftDownImagePiece.getAttribute('alt').includes("black"))) && (this.color === "white"))) {  
                                                            needsBreak = true;
                                                            isDangerous = false;
                                                        }

                                                    } 
                                                    break;
                                                default:
                                                    if (leftDownPiece.querySelector("img")) {
                                                        let leftDownImagePiece = leftDownPiece.querySelector("img");
                                                        if((leftDownImagePiece.getAttribute('alt').includes("whiteBishop") || leftDownImagePiece.getAttribute('alt').includes("whiteQueen")) && (this.color === "black")) {
                                                            needsBreak = true;
                                                            isDangerous = true;
                                                        } else if ((leftDownImagePiece.getAttribute('alt').includes("blackBishop") || leftDownImagePiece.getAttribute('alt').includes("blackQueen")) && (this.color === "white")) {
                                                            needsBreak = true;
                                                            isDangerous = true;
                                                        } else if ((leftDownImagePiece.getAttribute('alt').includes("black") && this.color === "black" && (!leftDownImagePiece.getAttribute('alt').includes("blackKing")) ) || (leftDownImagePiece.getAttribute('alt').includes("white") && this.color === "white" && (!leftDownImagePiece.getAttribute('alt').includes("whiteKing")))) {
                                                            needsBreak = true;
                                                            isDangerous = false;
                                                        } else if (((!leftDownImagePiece.getAttribute('alt').includes("whiteBishop")) && (!leftDownImagePiece.getAttribute('alt').includes("whiteQueen")) && (leftDownImagePiece.getAttribute('alt').includes("white")) && (this.color === "black")) || (((!leftDownImagePiece.getAttribute('alt').includes("blackBishop")) && (!leftDownImagePiece.getAttribute('alt').includes("blackQueen")) && (leftDownImagePiece.getAttribute('alt').includes("black"))) && (this.color === "white"))) {  
                                                            needsBreak = true;
                                                            isDangerous = false;
                                                        }
                                                    }
                                                    break;
                                            } // end of switch case
                                            if (needsBreak) {
                                                break;
                                            }    
                                        } // diagonal left down for each statement
                                    } // diagonal left down finished

                                    if (isDangerous) {
                                        continue;
                                    }
                                    
                                    // start over
                                    needsBreak = false;
                                    isDangerous = false;

                                    // checking diagonally right down
                                    if(eachMovement_yAxisValue == 8 || eachMovement_xAxisValue == 8) {
                                        
                                    } else {
                                        for(let i = 1; i <= 8; i++) {
                                            if (eachMovement_xAxisValue+i > 8 || eachMovement_yAxisValue+i > 8) {
                                                break;
                                            }

                                            let rightDownPiece = document.querySelector(`.cell_${eachMovement_xAxisValue+i}_${eachMovement_yAxisValue+i}`)
                                            
                                            switch(i) {
                                                case 1:
                                                    if (rightDownPiece.querySelector("img")) {
                                                        let rightDownImagePiece = rightDownPiece.querySelector("img");
                                                        if((rightDownImagePiece.getAttribute('alt').includes("whiteBishop") || rightDownImagePiece.getAttribute('alt').includes("whiteQueen") || rightDownImagePiece.getAttribute('alt').includes("whiteKing")) && (this.color === "black")) {
                                                            needsBreak = true;
                                                            isDangerous = true;
                                                        } else if ((rightDownImagePiece.getAttribute('alt').includes("blackBishop") || rightDownImagePiece.getAttribute('alt').includes("blackQueen") || rightDownImagePiece.getAttribute('alt').includes("blackKing")) && (this.color === "white")) {
                                                            needsBreak = true;
                                                            isDangerous = true;
                                                        } else if (((rightDownImagePiece.getAttribute('alt').includes("blackPawn") && this.color === "white") && (!this.blackUp)) || ((rightDownImagePiece.getAttribute('alt').includes("whitePawn") && this.color === "black") && (this.blackUp))) {
                                                            needsBreak = true;
                                                            isDangerous = true;
                                                        } else if ((rightDownImagePiece.getAttribute('alt').includes("black") && this.color === "black" && (!rightDownImagePiece.getAttribute('alt').includes("blackKing")) ) || (rightDownImagePiece.getAttribute('alt').includes("white") && this.color === "white" && (!rightDownImagePiece.getAttribute('alt').includes("whiteKing")))) {
                                                            needsBreak = true;
                                                            isDangerous = false;
                                                        } else if (((!rightDownImagePiece.getAttribute('alt').includes("whiteBishop")) && (!rightDownImagePiece.getAttribute('alt').includes("whiteQueen")) && (rightDownImagePiece.getAttribute('alt').includes("white")) && (this.color === "black")) || (((!rightDownImagePiece.getAttribute('alt').includes("blackBishop")) && (!rightDownImagePiece.getAttribute('alt').includes("blackQueen")) && (rightDownImagePiece.getAttribute('alt').includes("black"))) && (this.color === "white"))) {  
                                                            needsBreak = true;
                                                            isDangerous = false;
                                                        }
                                                    } 
                                                    break;
                                                default:
                                                    if (rightDownPiece.querySelector("img")) {
                                                        let rightDownImagePiece = rightDownPiece.querySelector("img");
                                                        if((rightDownImagePiece.getAttribute('alt').includes("whiteBishop") || rightDownImagePiece.getAttribute('alt').includes("whiteQueen")) && (this.color === "black")) {
                                                            needsBreak = true;
                                                            isDangerous = true;
                                                        } else if ((rightDownImagePiece.getAttribute('alt').includes("blackBishop") || rightDownImagePiece.getAttribute('alt').includes("blackQueen")) && (this.color === "white")) {
                                                            needsBreak = true;
                                                            isDangerous = true;
                                                        } else if ((rightDownImagePiece.getAttribute('alt').includes("black") && this.color === "black" && (!rightDownImagePiece.getAttribute('alt').includes("blackKing")) ) || (rightDownImagePiece.getAttribute('alt').includes("white") && this.color === "white" && (!rightDownImagePiece.getAttribute('alt').includes("whiteKing")))) {
                                                            needsBreak = true;
                                                            isDangerous = false;
                                                        } else if (((!rightDownImagePiece.getAttribute('alt').includes("whiteBishop")) && (!rightDownImagePiece.getAttribute('alt').includes("whiteQueen")) && (rightDownImagePiece.getAttribute('alt').includes("white")) && (this.color === "black")) || (((!rightDownImagePiece.getAttribute('alt').includes("blackBishop")) && (!rightDownImagePiece.getAttribute('alt').includes("blackQueen")) && (rightDownImagePiece.getAttribute('alt').includes("black"))) && (this.color === "white"))) {  
                                                            needsBreak = true;
                                                            isDangerous = false;
                                                        }
                                                    }
                                                    
                                                    break;
                                            } // end of switch case

                                            if (needsBreak) {
                                                break;
                                            }
                                        } // end of for each statement
                                    } // End of checking diagonally right down side statement

                                    if (isDangerous) {
                                        continue;
                                    }
                                    
                                    // start over
                                    needsBreak = false;
                                    isDangerous = false;


                                    // diagonal up left checking
                                    if(eachMovement_yAxisValue == 1 || eachMovement_xAxisValue == 1) {
                                        
                                    } else {
                                        for(let i = 1; i <= 8; i++) {
                                            if (eachMovement_xAxisValue-i < 1 || eachMovement_yAxisValue-i < 1) {
                                                break;
                                            }

                                            let upLeftPiece = document.querySelector(`.cell_${eachMovement_xAxisValue-i}_${eachMovement_yAxisValue-i}`)
                                            
                                            switch(i) {
                                                case 1:
                                                    if (upLeftPiece.querySelector("img")) {
                                                        let upLeftImagePiece = upLeftPiece.querySelector("img");
                                                        if((upLeftImagePiece.getAttribute('alt').includes("whiteBishop") || upLeftImagePiece.getAttribute('alt').includes("whiteQueen") || upLeftImagePiece.getAttribute('alt').includes("whiteKing")) && (this.color === "black")) {
                                                            needsBreak = true;
                                                            isDangerous = true;
                                                        } else if ((upLeftImagePiece.getAttribute('alt').includes("blackBishop") || upLeftImagePiece.getAttribute('alt').includes("blackQueen") || upLeftImagePiece.getAttribute('alt').includes("blackKing")) && (this.color === "white")) {
                                                            needsBreak = true;
                                                            isDangerous = true;
                                                        } else if (((upLeftImagePiece.getAttribute('alt').includes("blackPawn") && this.color === "white") && (this.blackUp)) || ((upLeftImagePiece.getAttribute('alt').includes("whitePawn") && this.color === "black") && (!this.blackUp))) {
                                                            needsBreak = true;
                                                            isDangerous = true;
                                                        } else if ((upLeftImagePiece.getAttribute('alt').includes("black") && this.color === "black" && (!upLeftImagePiece.getAttribute('alt').includes("blackKing")) ) || (upLeftImagePiece.getAttribute('alt').includes("white") && this.color === "white" && (!upLeftImagePiece.getAttribute('alt').includes("whiteKing")))) {
                                                            needsBreak = true;
                                                            isDangerous = false;
                                                        } else if (((!upLeftImagePiece.getAttribute('alt').includes("whiteBishop")) && (!upLeftImagePiece.getAttribute('alt').includes("whiteQueen")) && (upLeftImagePiece.getAttribute('alt').includes("white")) && (this.color === "black")) || (((!upLeftImagePiece.getAttribute('alt').includes("blackBishop")) && (!upLeftImagePiece.getAttribute('alt').includes("blackQueen")) && (upLeftImagePiece.getAttribute('alt').includes("black"))) && (this.color === "white"))) {  
                                                            needsBreak = true;
                                                            isDangerous = false;
                                                        }
                                                    } 
                                                    break;
                                                default:
                                                    if (upLeftPiece.querySelector("img")) {
                                                        let upLeftImagePiece = upLeftPiece.querySelector("img");
                                                        if((upLeftImagePiece.getAttribute('alt').includes("whiteBishop") || upLeftImagePiece.getAttribute('alt').includes("whiteQueen")) && (this.color === "black")) {
                                                            needsBreak = true;
                                                            isDangerous = true;
                                                        } else if ((upLeftImagePiece.getAttribute('alt').includes("blackBishop") || upLeftImagePiece.getAttribute('alt').includes("blackQueen")) && (this.color === "white")) {
                                                            needsBreak = true;
                                                            isDangerous = true;
                                                        } else if ((upLeftImagePiece.getAttribute('alt').includes("black") && this.color === "black" && (!upLeftImagePiece.getAttribute('alt').includes("blackKing")) ) || (upLeftImagePiece.getAttribute('alt').includes("white") && this.color === "white" && (!upLeftImagePiece.getAttribute('alt').includes("whiteKing")))) {
                                                            needsBreak = true;
                                                            isDangerous = false;
                                                        } else if (((!upLeftImagePiece.getAttribute('alt').includes("whiteBishop")) && (!upLeftImagePiece.getAttribute('alt').includes("whiteQueen")) && (upLeftImagePiece.getAttribute('alt').includes("white")) && (this.color === "black")) || (((!upLeftImagePiece.getAttribute('alt').includes("blackBishop")) && (!upLeftImagePiece.getAttribute('alt').includes("blackQueen")) && (upLeftImagePiece.getAttribute('alt').includes("black"))) && (this.color === "white"))) {  
                                                            needsBreak = true;
                                                            isDangerous = false;
                                                        }
                                                    }
                                                    
                                                    break;
                                            } // end of switch case

                                            if (needsBreak) {
                                                break;
                                            }

                                        } // end of for each statement
                                    } // End of checking diagonally up left side statement

                                    if (isDangerous) {
                                        continue;
                                    }
                                    
                                    // start over
                                    needsBreak = false;
                                    isDangerous = false;

                                    // check diagonally up right
                                    if(eachMovement_yAxisValue == 8 || eachMovement_xAxisValue == 1) {
                                        
                                    } else {
                                        for(let i = 1; i <= 8; i++) {
                                            if (eachMovement_xAxisValue-i < 1 || eachMovement_yAxisValue+i > 8) {
                                                break;
                                            }

                                            let upRightPiece = document.querySelector(`.cell_${eachMovement_xAxisValue-i}_${eachMovement_yAxisValue+i}`)
                                            
                                            switch(i) {
                                                case 1:
                                                    if (upRightPiece.querySelector("img")) {
                                                        let upRightImagePiece = upRightPiece.querySelector("img");
                                                        if((upRightImagePiece.getAttribute('alt').includes("whiteBishop") || upRightImagePiece.getAttribute('alt').includes("whiteQueen") || upRightImagePiece.getAttribute('alt').includes("whiteKing")) && (this.color === "black")) {
                                                            needsBreak = true;
                                                            isDangerous = true;
                                                        } else if ((upRightImagePiece.getAttribute('alt').includes("blackBishop") || upRightImagePiece.getAttribute('alt').includes("blackQueen") || upRightImagePiece.getAttribute('alt').includes("blackKing")) && (this.color === "white")) {
                                                            needsBreak = true;
                                                            isDangerous = true;
                                                        } else if (((upRightImagePiece.getAttribute('alt').includes("blackPawn") && this.color === "white") && (this.blackUp)) || ((upRightImagePiece.getAttribute('alt').includes("whitePawn") && this.color === "black") && (!this.blackUp))) {
                                                            needsBreak = true;
                                                            isDangerous = true;
                                                        } else if ((upRightImagePiece.getAttribute('alt').includes("black") && this.color === "black" && (!upRightImagePiece.getAttribute('alt').includes("blackKing")) ) || (upRightImagePiece.getAttribute('alt').includes("white") && this.color === "white" && (!upRightImagePiece.getAttribute('alt').includes("whiteKing")))) {
                                                            needsBreak = true;
                                                            isDangerous = false;
                                                        } else if (((!upRightImagePiece.getAttribute('alt').includes("whiteBishop")) && (!upRightImagePiece.getAttribute('alt').includes("whiteQueen")) && (upRightImagePiece.getAttribute('alt').includes("white")) && (this.color === "black")) || (((!upRightImagePiece.getAttribute('alt').includes("blackBishop")) && (!upRightImagePiece.getAttribute('alt').includes("blackQueen")) && (upRightImagePiece.getAttribute('alt').includes("black"))) && (this.color === "white"))) {  
                                                            needsBreak = true;
                                                            isDangerous = false;
                                                        }
                                                    } 
                                                    break;
                                                default:
                                                    if (upRightPiece.querySelector("img")) {
                                                        let upRightImagePiece = upRightPiece.querySelector("img");
                                                        if((upRightImagePiece.getAttribute('alt').includes("whiteBishop") || upRightImagePiece.getAttribute('alt').includes("whiteQueen")) && (this.color === "black")) {
                                                            needsBreak = true;
                                                            isDangerous = true;
                                                        } else if ((upRightImagePiece.getAttribute('alt').includes("blackBishop") || upRightImagePiece.getAttribute('alt').includes("blackQueen")) && (this.color === "white")) {
                                                            needsBreak = true;
                                                            isDangerous = true;
                                                        } else if ((upRightImagePiece.getAttribute('alt').includes("black") && this.color === "black" && (!upRightImagePiece.getAttribute('alt').includes("blackKing")) ) || (upRightImagePiece.getAttribute('alt').includes("white") && this.color === "white" && (!upRightImagePiece.getAttribute('alt').includes("whiteKing")))) {
                                                            needsBreak = true;
                                                            isDangerous = false;
                                                        } else if (((!upRightImagePiece.getAttribute('alt').includes("whiteBishop")) && (!upRightImagePiece.getAttribute('alt').includes("whiteQueen")) && (upRightImagePiece.getAttribute('alt').includes("white")) && (this.color === "black")) || (((!upRightImagePiece.getAttribute('alt').includes("blackBishop")) && (!upRightImagePiece.getAttribute('alt').includes("blackQueen")) && (upRightImagePiece.getAttribute('alt').includes("black"))) && (this.color === "white"))) {  
                                                            needsBreak = true;
                                                            isDangerous = false;
                                                        }
                                                    }
                                                    
                                                    break;
                                            } // end of switch case

                                            if (needsBreak) {
                                                break;
                                            }
                                        } // end of for each statement
                                    } // End of checking diagonally up left side statement

                                    if (isDangerous) {
                                        continue;
                                    }
                                    
                                    // start over
                                    needsBreak = false;
                                    isDangerous = false;

                                    // Check left side if enemy Knight is there
                                    if(eachMovement_xAxisValue-1 >= 1 && eachMovement_yAxisValue-2 >= 1 ){
                                        let knightPiecePossibleStance = document.querySelector(`.cell_${eachMovement_xAxisValue-1}_${eachMovement_yAxisValue-2}`);
                                        if (knightPiecePossibleStance.querySelector("img")) {
                                            let imagePiece = knightPiecePossibleStance.querySelector("img");
                                            if((imagePiece.getAttribute('alt').includes("whiteKnight")) && (this.color === "black")) {
                                                isDangerous = true;
                                            } else if ((imagePiece.getAttribute('alt').includes("blackKnight")) && (this.color === "white")) {
                                                isDangerous = true;
                                            } else if ((imagePiece.getAttribute('alt').includes("black") && this.color === "black") || (imagePiece.getAttribute('alt').includes("white") && this.color === "white")) {
                                                isDangerous = false;
                                            }
                                        }
                                    }

                                    if (isDangerous) {
                                        continue;
                                    }
                                    
                                    // start over
                                    needsBreak = false;
                                    isDangerous = false;

                                    if(eachMovement_xAxisValue-2 >= 1 && eachMovement_yAxisValue-1 >= 1 ){
                                        let knightPiecePossibleStance = document.querySelector(`.cell_${eachMovement_xAxisValue-2}_${eachMovement_yAxisValue-1}`);
                                        if (knightPiecePossibleStance.querySelector("img")) {
                                            let imagePiece = knightPiecePossibleStance.querySelector("img");
                                            if((imagePiece.getAttribute('alt').includes("whiteKnight")) && (this.color === "black")) {
                                                isDangerous = true;
                                            } else if ((imagePiece.getAttribute('alt').includes("blackKnight")) && (this.color === "white")) {
                                                isDangerous = true;
                                            } else if ((imagePiece.getAttribute('alt').includes("black") && this.color === "black") || (imagePiece.getAttribute('alt').includes("white") && this.color === "white")) {
                                                isDangerous = false;
                                            }
                                        }
                                    }

                                    if (isDangerous) {
                                        continue;
                                    }
                                    
                                    // start over
                                    needsBreak = false;
                                    isDangerous = false;

                                    if(eachMovement_xAxisValue+1 <= 8 && eachMovement_yAxisValue-2 >= 1 ){
                                        let knightPiecePossibleStance = document.querySelector(`.cell_${eachMovement_xAxisValue+1}_${eachMovement_yAxisValue-2}`);
                                        if (knightPiecePossibleStance.querySelector("img")) {
                                            let imagePiece = knightPiecePossibleStance.querySelector("img");
                                            if((imagePiece.getAttribute('alt').includes("whiteKnight")) && (this.color === "black")) {
                                                isDangerous = true;
                                            } else if ((imagePiece.getAttribute('alt').includes("blackKnight")) && (this.color === "white")) {
                                                isDangerous = true;
                                            } else if ((imagePiece.getAttribute('alt').includes("black") && this.color === "black") || (imagePiece.getAttribute('alt').includes("white") && this.color === "white")) {
                                                isDangerous = false;
                                            }
                                        }
                                    }

                                    if (isDangerous) {
                                        continue;
                                    }
                                    
                                    // start over
                                    needsBreak = false;
                                    isDangerous = false;

                                    if(eachMovement_xAxisValue+2 <= 8 && eachMovement_yAxisValue-1 >= 1 ){
                                        let knightPiecePossibleStance = document.querySelector(`.cell_${eachMovement_xAxisValue+2}_${eachMovement_yAxisValue-1}`);
                                        if (knightPiecePossibleStance.querySelector("img")) {
                                            let imagePiece = knightPiecePossibleStance.querySelector("img");
                                            if((imagePiece.getAttribute('alt').includes("whiteKnight")) && (this.color === "black")) {
                                                isDangerous = true;
                                            } else if ((imagePiece.getAttribute('alt').includes("blackKnight")) && (this.color === "white")) {
                                                isDangerous = true;
                                            } else if ((imagePiece.getAttribute('alt').includes("black") && this.color === "black") || (imagePiece.getAttribute('alt').includes("white") && this.color === "white")) {
                                                isDangerous = false;
                                            }
                                        }
                                    }

                                    if (isDangerous) {
                                        continue;
                                    }
                                    
                                    // start over
                                    needsBreak = false;
                                    isDangerous = false;

                                    // check right if knight is there
                                    if(eachMovement_xAxisValue-1 >= 1 && eachMovement_yAxisValue+2 <= 8 ){
                                        let knightPiecePossibleStance = document.querySelector(`.cell_${eachMovement_xAxisValue-1}_${eachMovement_yAxisValue+2}`);
                                        if (knightPiecePossibleStance.querySelector("img")) {
                                            let imagePiece = knightPiecePossibleStance.querySelector("img");
                                            if((imagePiece.getAttribute('alt').includes("whiteKnight")) && (this.color === "black")) {
                                                isDangerous = true;
                                            } else if ((imagePiece.getAttribute('alt').includes("blackKnight")) && (this.color === "white")) {
                                                isDangerous = true;
                                            } else if ((imagePiece.getAttribute('alt').includes("black") && this.color === "black") || (imagePiece.getAttribute('alt').includes("white") && this.color === "white")) {
                                                isDangerous = false;
                                            }
                                        }
                                    }

                                    if (isDangerous) {
                                        continue;
                                    }
                                    
                                    // start over
                                    needsBreak = false;
                                    isDangerous = false;


                                    if(eachMovement_xAxisValue-2 >= 1 && eachMovement_yAxisValue+1 <= 8 ){
                                        let knightPiecePossibleStance = document.querySelector(`.cell_${eachMovement_xAxisValue-2}_${eachMovement_yAxisValue+1}`);
                                        if (knightPiecePossibleStance.querySelector("img")) {
                                            let imagePiece = knightPiecePossibleStance.querySelector("img");
                                            if((imagePiece.getAttribute('alt').includes("whiteKnight")) && (this.color === "black")) {
                                                isDangerous = true;
                                            } else if ((imagePiece.getAttribute('alt').includes("blackKnight")) && (this.color === "white")) {
                                                isDangerous = true;
                                            } else if ((imagePiece.getAttribute('alt').includes("black") && this.color === "black") || (imagePiece.getAttribute('alt').includes("white") && this.color === "white")) {
                                                isDangerous = false;
                                            }
                                        }
                                    }

                                    if (isDangerous) {
                                        continue;
                                    }
                                    
                                    // start over
                                    needsBreak = false;
                                    isDangerous = false;

                                    if(eachMovement_xAxisValue+1 <= 8 && eachMovement_yAxisValue+2 <= 8 ){
                                        let knightPiecePossibleStance = document.querySelector(`.cell_${eachMovement_xAxisValue+1}_${eachMovement_yAxisValue+2}`);
                                        if (knightPiecePossibleStance.querySelector("img")) {
                                            let imagePiece = knightPiecePossibleStance.querySelector("img");
                                            if((imagePiece.getAttribute('alt').includes("whiteKnight")) && (this.color === "black")) {
                                                isDangerous = false;
                                            } else if ((imagePiece.getAttribute('alt').includes("blackKnight")) && (this.color === "white")) {
                                                isDangerous = false;
                                            } else if ((imagePiece.getAttribute('alt').includes("black") && this.color === "black") || (imagePiece.getAttribute('alt').includes("white") && this.color === "white")) {
                                                isDangerous = false;
                                            }
                                        }
                                    }

                                    if (isDangerous) {
                                        continue;
                                    }
                                    
                                    // start over
                                    needsBreak = false;
                                    isDangerous = false;

                                    if(eachMovement_xAxisValue+2 <= 8 && eachMovement_yAxisValue+1 <= 8 ){
                                        let knightPiecePossibleStance = document.querySelector(`.cell_${eachMovement_xAxisValue+2}_${eachMovement_yAxisValue+1}`);
                                        if (knightPiecePossibleStance.querySelector("img")) {
                                            let imagePiece = knightPiecePossibleStance.querySelector("img");
                                            if((imagePiece.getAttribute('alt').includes("whiteKnight")) && (this.color === "black")) {
                                                isDangerous = true;
                                            } else if ((imagePiece.getAttribute('alt').includes("blackKnight")) && (this.color === "white")) {
                                                isDangerous = true;
                                            } else if ((imagePiece.getAttribute('alt').includes("black") && this.color === "black") || (imagePiece.getAttribute('alt').includes("white") && this.color === "white")) {
                                                isDangerous = false;
                                            }
                                        }
                                    }
                                    
                                    // last element
                                    if (isDangerous) {
                                        continue;
                                    } else {
                                        defendingMovements.push(`.cell_${eachMovement_xAxisValue}_${eachMovement_yAxisValue}`);
                                    }
                                

                                } // End of outer for each statement for king movements
                                /////////////////////// check king's movements end


                            } else {
                                ////////////////////// other piece blocking the king start
                                // if the attacker is black rook or black queen
                                let piece_xAxisValue;
                                let piece_yAxisValue;
                                let possibleMoves;

                                if (attackerPieceName.includes("blackRook") || attackerPieceName.includes("blackQueen")){
                                    // check left and right
                                    if(attacker_xAxisValue === king_xAxisValue) {   
                                        let diff_yValue = attacker_yAxisValue - king_yAxisValue;
                                        if (diff_yValue > 0){
                                            // positive value: king is at the left and rook is at the right
                                            // rook or queen movement infiltration
                                            for(let k = 1; k < diff_yValue; k++){
                                                //////// Switch cases for each piece
                                                switch (defenderPieceName) {
                                                    case "whitePawn":
                                                        foundIdx = whitePawnPieces.findIndex((eachClass) => {return eachClass.position === defenderCoordinate;});
                                                        piece_xAxisValue = parseInt(whitePawnPieces[foundIdx].position.substr(6, 1));
                                                        piece_yAxisValue = parseInt(whitePawnPieces[foundIdx].position.substr(whitePawnPieces[foundIdx].position.length -1, 1));
                                                        possibleMoves = whitePawnPieces[foundIdx].possibleMove(piece_xAxisValue, piece_yAxisValue, true, attacker_xAxisValue, attacker_yAxisValue-k);

                                                        for(let m = 0; m < possibleMoves.length; m++) {
                                                            if (possibleMoves[m] === `.cell_${attacker_xAxisValue}_${attacker_yAxisValue-k}`){
                                                                defendingMovements.push(possibleMoves[m]);
                                                            }
                                                        }

                                                        break;
                                                    case "whiteKnight":
                                                        foundIdx = whiteKnightPieces.findIndex((eachClass) => {return eachClass.position === defenderCoordinate;});
                                                        piece_xAxisValue = parseInt(whiteKnightPieces[foundIdx].position.substr(6, 1));
                                                        piece_yAxisValue = parseInt(whiteKnightPieces[foundIdx].position.substr(whiteKnightPieces[foundIdx].position.length -1, 1));
                                                        possibleMoves = whiteKnightPieces[foundIdx].possibleMove(piece_xAxisValue, piece_yAxisValue, attacker_xAxisValue, attacker_yAxisValue-k);

                                                        for(let m = 0; m < possibleMoves.length; m++) {
                                                            if (possibleMoves[m] === `.cell_${attacker_xAxisValue}_${attacker_yAxisValue-k}`){
                                                                defendingMovements.push(possibleMoves[m]);
                                                            }
                                                        }

                                                        break;
                                                    case "whiteBishop":
                                                        foundIdx = whiteBishopPieces.findIndex((eachClass) => {return eachClass.position === defenderCoordinate;});
                                                        piece_xAxisValue = parseInt(whiteBishopPieces[foundIdx].position.substr(6, 1));
                                                        piece_yAxisValue = parseInt(whiteBishopPieces[foundIdx].position.substr(whiteBishopPieces[foundIdx].position.length -1, 1));
                                                        possibleMoves = whiteBishopPieces[foundIdx].possibleMove(piece_xAxisValue, piece_yAxisValue, attacker_xAxisValue, attacker_yAxisValue-k);

                                                        for(let m = 0; m < possibleMoves.length; m++) {
                                                            if (possibleMoves[m] === `.cell_${attacker_xAxisValue}_${attacker_yAxisValue-k}`){
                                                                defendingMovements.push(possibleMoves[m]);
                                                            }
                                                        }

                                                        break;
                                                    case "whiteRook":
                                                        foundIdx = whiteRookPieces.findIndex((eachClass) => {return eachClass.position === defenderCoordinate;});
                                                        piece_xAxisValue = parseInt(whiteRookPieces[foundIdx].position.substr(6, 1));
                                                        piece_yAxisValue = parseInt(whiteRookPieces[foundIdx].position.substr(whiteRookPieces[foundIdx].position.length -1, 1));
                                                        possibleMoves = whiteRookPieces[foundIdx].possibleMove(piece_xAxisValue, piece_yAxisValue, attacker_xAxisValue, attacker_yAxisValue-k, true);

                                                        for(let m = 0; m < possibleMoves.length; m++) {
                                                            if (possibleMoves[m] === `.cell_${attacker_xAxisValue}_${attacker_yAxisValue-k}`){
                                                                defendingMovements.push(possibleMoves[m]);
                                                            }
                                                        }

                                                        break;
                                                    case "whiteQueen":
                                                        piece_xAxisValue = parseInt(whiteQueenPiece[0].position.substr(6, 1));
                                                        piece_yAxisValue = parseInt(whiteQueenPiece[0].position.substr(whiteQueenPiece[0].position.length -1, 1));
                                                        possibleMoves = whiteQueenPiece[0].possibleMove(piece_xAxisValue, piece_yAxisValue, attacker_xAxisValue, attacker_yAxisValue-k);

                                                        for(let m = 0; m < possibleMoves.length; m++) {
                                                            if (possibleMoves[m] === `.cell_${attacker_xAxisValue}_${attacker_yAxisValue-k}`){
                                                                defendingMovements.push(possibleMoves[m]);
                                                            }
                                                        }

                                                        break;
                                                    
                                                    
                                                }   /////// end of switch case for defending piece can block the enemy         
                                            } 
                                        // king is at the right rook is at the left
                                        } else if (diff_yValue < 0) {
                                            // rook or queen movement infiltration
                                            for(let k = 1; k < Math.abs(diff_yValue); k++){
                                                /////////////// king is at the right and enemy rook is at the left
                                                //////// Switch cases for each piece
                                                switch (defenderPieceName) {
                                                    case "whitePawn":
                                                        foundIdx = whitePawnPieces.findIndex((eachClass) => {return eachClass.position === defenderCoordinate;});
                                                        piece_xAxisValue = parseInt(whitePawnPieces[foundIdx].position.substr(6, 1));
                                                        piece_yAxisValue = parseInt(whitePawnPieces[foundIdx].position.substr(whitePawnPieces[foundIdx].position.length -1, 1));
                                                        possibleMoves = whitePawnPieces[foundIdx].possibleMove(piece_xAxisValue, piece_yAxisValue, true, attacker_xAxisValue, attacker_yAxisValue+k);

                                                        for(let m = 0; m < possibleMoves.length; m++) {
                                                            if (possibleMoves[m] === `.cell_${attacker_xAxisValue}_${attacker_yAxisValue+k}`){
                                                                defendingMovements.push(possibleMoves[m]);
                                                            }
                                                        }

                                                        break;
                                                    case "whiteKnight":
                                                        foundIdx = whiteKnightPieces.findIndex((eachClass) => {return eachClass.position === defenderCoordinate;});
                                                        piece_xAxisValue = parseInt(whiteKnightPieces[foundIdx].position.substr(6, 1));
                                                        piece_yAxisValue = parseInt(whiteKnightPieces[foundIdx].position.substr(whiteKnightPieces[foundIdx].position.length -1, 1));
                                                        possibleMoves = whiteKnightPieces[foundIdx].possibleMove(piece_xAxisValue, piece_yAxisValue, attacker_xAxisValue, attacker_yAxisValue+k);

                                                        for(let m = 0; m < possibleMoves.length; m++) {
                                                            if (possibleMoves[m] === `.cell_${attacker_xAxisValue}_${attacker_yAxisValue+k}`){
                                                                defendingMovements.push(possibleMoves[m]);
                                                            }
                                                        }

                                                        break;
                                                    case "whiteBishop":
                                                        foundIdx = whiteBishopPieces.findIndex((eachClass) => {return eachClass.position === defenderCoordinate;});
                                                        piece_xAxisValue = parseInt(whiteBishopPieces[foundIdx].position.substr(6, 1));
                                                        piece_yAxisValue = parseInt(whiteBishopPieces[foundIdx].position.substr(whiteBishopPieces[foundIdx].position.length -1, 1));
                                                        possibleMoves = whiteBishopPieces[foundIdx].possibleMove(piece_xAxisValue, piece_yAxisValue, attacker_xAxisValue, attacker_yAxisValue+k);

                                                        for(let m = 0; m < possibleMoves.length; m++) {
                                                            if (possibleMoves[m] === `.cell_${attacker_xAxisValue}_${attacker_yAxisValue+k}`){
                                                                defendingMovements.push(possibleMoves[m]);
                                                            }
                                                        }

                                                        break;
                                                    case "whiteRook":
                                                        foundIdx = whiteRookPieces.findIndex((eachClass) => {return eachClass.position === defenderCoordinate;});
                                                        piece_xAxisValue = parseInt(whiteRookPieces[foundIdx].position.substr(6, 1));
                                                        piece_yAxisValue = parseInt(whiteRookPieces[foundIdx].position.substr(whiteRookPieces[foundIdx].position.length -1, 1));
                                                        possibleMoves = whiteRookPieces[foundIdx].possibleMove(piece_xAxisValue, piece_yAxisValue, attacker_xAxisValue, attacker_yAxisValue+k, true);

                                                        for(let m = 0; m < possibleMoves.length; m++) {
                                                            if (possibleMoves[m] === `.cell_${attacker_xAxisValue}_${attacker_yAxisValue+k}`){
                                                                defendingMovements.push(possibleMoves[m]);
                                                            }
                                                        }

                                                        break;
                                                    case "whiteQueen":
                                                        piece_xAxisValue = parseInt(whiteQueenPiece[0].position.substr(6, 1));
                                                        piece_yAxisValue = parseInt(whiteQueenPiece[0].position.substr(whiteQueenPiece[0].position.length -1, 1));
                                                        possibleMoves = whiteQueenPiece[0].possibleMove(piece_xAxisValue, piece_yAxisValue, attacker_xAxisValue, attacker_yAxisValue+k);

                                                        for(let m = 0; m < possibleMoves.length; m++) {
                                                            if (possibleMoves[m] === `.cell_${attacker_xAxisValue}_${attacker_yAxisValue+k}`){
                                                                defendingMovements.push(possibleMoves[m]);
                                                            }
                                                        }

                                                        break;
                                                    
                                                         
                                                } /////// end of switch case for defending piece can block the enemy
                                            
                                                /////////////// king is at the right and enemy rook is at the left
                                                // check diff yvalue is bigger than 0
                                            } // for loop of movement end
                                        } // check for left and right rook or queen
                                    } // everything complete for left and right check


                                    // check for up and down
                                    if(attacker_yAxisValue === king_yAxisValue) {   
                                        let diff_xValue = attacker_xAxisValue - king_xAxisValue;
                                        if (diff_xValue > 0){
                                            // positive value: king is at the up and rook is at the down
                                            // rook or queen movement infiltration
                                            for(let k = 1; k < diff_xValue; k++){

                                                //// if white pawn pieces can defend or block the enemy start
                                                switch (defenderPieceName) {
                                                    case "whitePawn":
                                                        foundIdx = whitePawnPieces.findIndex((eachClass) => {return eachClass.position === defenderCoordinate;});
                                                        piece_xAxisValue = parseInt(whitePawnPieces[foundIdx].position.substr(6, 1));
                                                        piece_yAxisValue = parseInt(whitePawnPieces[foundIdx].position.substr(whitePawnPieces[foundIdx].position.length -1, 1));
                                                        possibleMoves = whitePawnPieces[foundIdx].possibleMove(piece_xAxisValue, piece_yAxisValue, true, attacker_xAxisValue-k, attacker_yAxisValue);

                                                        for(let m = 0; m < possibleMoves.length; m++) {
                                                            if (possibleMoves[m] === `.cell_${attacker_xAxisValue-k}_${attacker_yAxisValue}`){
                                                                defendingMovements.push(possibleMoves[m]);
                                                            }
                                                        }

                                                        break;
                                                    case "whiteKnight":
                                                        foundIdx = whiteKnightPieces.findIndex((eachClass) => {return eachClass.position === defenderCoordinate;});
                                                        piece_xAxisValue = parseInt(whiteKnightPieces[foundIdx].position.substr(6, 1));
                                                        piece_yAxisValue = parseInt(whiteKnightPieces[foundIdx].position.substr(whiteKnightPieces[foundIdx].position.length -1, 1));
                                                        possibleMoves = whiteKnightPieces[foundIdx].possibleMove(piece_xAxisValue, piece_yAxisValue, attacker_xAxisValue-k, attacker_yAxisValue);

                                                        for(let m = 0; m < possibleMoves.length; m++) {
                                                            if (possibleMoves[m] === `.cell_${attacker_xAxisValue-k}_${attacker_yAxisValue}`){
                                                                defendingMovements.push(possibleMoves[m]);
                                                            }
                                                        }

                                                        break;
                                                    case "whiteBishop":
                                                        foundIdx = whiteBishopPieces.findIndex((eachClass) => {return eachClass.position === defenderCoordinate;});
                                                        piece_xAxisValue = parseInt(whiteBishopPieces[foundIdx].position.substr(6, 1));
                                                        piece_yAxisValue = parseInt(whiteBishopPieces[foundIdx].position.substr(whiteBishopPieces[foundIdx].position.length -1, 1));
                                                        possibleMoves = whiteBishopPieces[foundIdx].possibleMove(piece_xAxisValue, piece_yAxisValue, attacker_xAxisValue-k, attacker_yAxisValue);

                                                        for(let m = 0; m < possibleMoves.length; m++) {
                                                            if (possibleMoves[m] === `.cell_${attacker_xAxisValue-k}_${attacker_yAxisValue}`){
                                                                defendingMovements.push(possibleMoves[m]);
                                                            }
                                                        }

                                                        break;
                                                    case "whiteRook":
                                                        foundIdx = whiteRookPieces.findIndex((eachClass) => {return eachClass.position === defenderCoordinate;});
                                                        piece_xAxisValue = parseInt(whiteRookPieces[foundIdx].position.substr(6, 1));
                                                        piece_yAxisValue = parseInt(whiteRookPieces[foundIdx].position.substr(whiteRookPieces[foundIdx].position.length -1, 1));
                                                        possibleMoves = whiteRookPieces[foundIdx].possibleMove(piece_xAxisValue, piece_yAxisValue, attacker_xAxisValue-k, attacker_yAxisValue, true);

                                                        for(let m = 0; m < possibleMoves.length; m++) {
                                                            if (possibleMoves[m] === `.cell_${attacker_xAxisValue-k}_${attacker_yAxisValue}`){
                                                                defendingMovements.push(possibleMoves[m]);
                                                            }
                                                        }

                                                        break;
                                                    case "whiteQueen":
                                                        piece_xAxisValue = parseInt(whiteQueenPiece[0].position.substr(6, 1));
                                                        piece_yAxisValue = parseInt(whiteQueenPiece[0].position.substr(whiteQueenPiece[0].position.length -1, 1));
                                                        possibleMoves = whiteQueenPiece[0].possibleMove(piece_xAxisValue, piece_yAxisValue, attacker_xAxisValue-k, attacker_yAxisValue);

                                                        for(let m = 0; m < possibleMoves.length; m++) {
                                                            if (possibleMoves[m] === `.cell_${attacker_xAxisValue-k}_${attacker_yAxisValue}`){
                                                                defendingMovements.push(possibleMoves[m]);
                                                            }
                                                        }

                                                        break;
                                                    
                                                         
                                                } /////// end of switch case for defending piece can block the enemy
                                            }
                                                //// if white pawn pieces can defend or block the enemy end
                                        // king is at the bottom rook is at the top
                                        } else if (diff_xValue < 0) {
                                            // rook or queen movement infiltration
                                            for(let k = 1; k < Math.abs(diff_xValue); k++){

                                                // // if white pawn pieces can defend or block the enemy start
                                                switch (defenderPieceName) {
                                                    case "whitePawn":
                                                        foundIdx = whitePawnPieces.findIndex((eachClass) => {return eachClass.position === defenderCoordinate;});
                                                        piece_xAxisValue = parseInt(whitePawnPieces[foundIdx].position.substr(6, 1));
                                                        piece_yAxisValue = parseInt(whitePawnPieces[foundIdx].position.substr(whitePawnPieces[foundIdx].position.length -1, 1));
                                                        possibleMoves = whitePawnPieces[foundIdx].possibleMove(piece_xAxisValue, piece_yAxisValue, true, attacker_xAxisValue+k, attacker_yAxisValue);

                                                        for(let m = 0; m < possibleMoves.length; m++) {
                                                            if (possibleMoves[m] === `.cell_${attacker_xAxisValue+k}_${attacker_yAxisValue}`){
                                                                defendingMovements.push(possibleMoves[m]);
                                                            }
                                                        }

                                                        break;
                                                    case "whiteKnight":
                                                        foundIdx = whiteKnightPieces.findIndex((eachClass) => {return eachClass.position === defenderCoordinate;});
                                                        piece_xAxisValue = parseInt(whiteKnightPieces[foundIdx].position.substr(6, 1));
                                                        piece_yAxisValue = parseInt(whiteKnightPieces[foundIdx].position.substr(whiteKnightPieces[foundIdx].position.length -1, 1));
                                                        possibleMoves = whiteKnightPieces[foundIdx].possibleMove(piece_xAxisValue, piece_yAxisValue, attacker_xAxisValue+k, attacker_yAxisValue);

                                                        for(let m = 0; m < possibleMoves.length; m++) {
                                                            if (possibleMoves[m] === `.cell_${attacker_xAxisValue+k}_${attacker_yAxisValue}`){
                                                                defendingMovements.push(possibleMoves[m]);
                                                            }
                                                        }

                                                        break;
                                                    case "whiteBishop":
                                                        foundIdx = whiteBishopPieces.findIndex((eachClass) => {return eachClass.position === defenderCoordinate;});
                                                        piece_xAxisValue = parseInt(whiteBishopPieces[foundIdx].position.substr(6, 1));
                                                        piece_yAxisValue = parseInt(whiteBishopPieces[foundIdx].position.substr(whiteBishopPieces[foundIdx].position.length -1, 1));
                                                        possibleMoves = whiteBishopPieces[foundIdx].possibleMove(piece_xAxisValue, piece_yAxisValue, attacker_xAxisValue+k, attacker_yAxisValue);

                                                        for(let m = 0; m < possibleMoves.length; m++) {
                                                            if (possibleMoves[m] === `.cell_${attacker_xAxisValue+k}_${attacker_yAxisValue}`){
                                                                defendingMovements.push(possibleMoves[m]);
                                                            }
                                                        }

                                                        break;
                                                    case "whiteRook":
                                                        foundIdx = whiteRookPieces.findIndex((eachClass) => {return eachClass.position === defenderCoordinate;});
                                                        piece_xAxisValue = parseInt(whiteRookPieces[foundIdx].position.substr(6, 1));
                                                        piece_yAxisValue = parseInt(whiteRookPieces[foundIdx].position.substr(whiteRookPieces[foundIdx].position.length -1, 1));
                                                        possibleMoves = whiteRookPieces[foundIdx].possibleMove(piece_xAxisValue, piece_yAxisValue, attacker_xAxisValue+k, attacker_yAxisValue, true);

                                                        for(let m = 0; m < possibleMoves.length; m++) {
                                                            if (possibleMoves[m] === `.cell_${attacker_xAxisValue+k}_${attacker_yAxisValue}`){
                                                                defendingMovements.push(possibleMoves[m]);
                                                            }
                                                        }

                                                        break;
                                                    case "whiteQueen":
                                                        piece_xAxisValue = parseInt(whiteQueenPiece[0].position.substr(6, 1));
                                                        piece_yAxisValue = parseInt(whiteQueenPiece[0].position.substr(whiteQueenPiece[0].position.length -1, 1));
                                                        possibleMoves = whiteQueenPiece[0].possibleMove(piece_xAxisValue, piece_yAxisValue, attacker_xAxisValue+k, attacker_yAxisValue);

                                                        for(let m = 0; m < possibleMoves.length; m++) {
                                                            if (possibleMoves[m] === `.cell_${attacker_xAxisValue+k}_${attacker_yAxisValue}`){
                                                                defendingMovements.push(possibleMoves[m]);
                                                            }
                                                        }

                                                        break;
                                                    
                                                         
                                                } /////// end of switch case for defending piece can block the enemy

                                            } // for loop of movement end
                                        } // end of diff_xValue is negative

                                    } // check for up and down rook or queen
                                } // check for all white rook and white queen
                                ///////////////////

                                // if the attacker is black bishop or black queen
                                if (attackerPieceName.includes("blackQueen") || attackerPieceName.includes("blackBishop")){
                                    let diff_xValue = attacker_xAxisValue - king_xAxisValue;
                                    let diff_yValue = attacker_yAxisValue - king_yAxisValue;

                                    // it has to be diagonal
                                    if(Math.abs(diff_xValue) === Math.abs(diff_yValue)) {
                                        
                                        // attacker is bottom right, king is top left
                                        if(diff_xValue > 0 && diff_yValue > 0) {
                                            for (let k = 1; k < Math.abs(diff_xValue); k++) {

                                                // check if pawn pieces can block the attacker
                                                switch (defenderPieceName) {
                                                    case "whitePawn":
                                                        foundIdx = whitePawnPieces.findIndex((eachClass) => {return eachClass.position === defenderCoordinate;});
                                                        piece_xAxisValue = parseInt(whitePawnPieces[foundIdx].position.substr(6, 1));
                                                        piece_yAxisValue = parseInt(whitePawnPieces[foundIdx].position.substr(whitePawnPieces[foundIdx].position.length -1, 1));
                                                        possibleMoves = whitePawnPieces[foundIdx].possibleMove(piece_xAxisValue, piece_yAxisValue, true, attacker_xAxisValue-k, attacker_yAxisValue-k);

                                                        for(let m = 0; m < possibleMoves.length; m++) {
                                                            if (possibleMoves[m] === `.cell_${attacker_xAxisValue-k}_${attacker_yAxisValue-k}`){
                                                                defendingMovements.push(possibleMoves[m]);
                                                            }
                                                        }

                                                        break;
                                                    case "whiteKnight":
                                                        foundIdx = whiteKnightPieces.findIndex((eachClass) => {return eachClass.position === defenderCoordinate;});
                                                        piece_xAxisValue = parseInt(whiteKnightPieces[foundIdx].position.substr(6, 1));
                                                        piece_yAxisValue = parseInt(whiteKnightPieces[foundIdx].position.substr(whiteKnightPieces[foundIdx].position.length -1, 1));
                                                        possibleMoves = whiteKnightPieces[foundIdx].possibleMove(piece_xAxisValue, piece_yAxisValue, attacker_xAxisValue-k, attacker_yAxisValue-k);

                                                        for(let m = 0; m < possibleMoves.length; m++) {
                                                            if (possibleMoves[m] === `.cell_${attacker_xAxisValue-k}_${attacker_yAxisValue-k}`){
                                                                defendingMovements.push(possibleMoves[m]);
                                                            }
                                                        }

                                                        break;
                                                    case "whiteBishop":
                                                        foundIdx = whiteBishopPieces.findIndex((eachClass) => {return eachClass.position === defenderCoordinate;});
                                                        piece_xAxisValue = parseInt(whiteBishopPieces[foundIdx].position.substr(6, 1));
                                                        piece_yAxisValue = parseInt(whiteBishopPieces[foundIdx].position.substr(whiteBishopPieces[foundIdx].position.length -1, 1));
                                                        possibleMoves = whiteBishopPieces[foundIdx].possibleMove(piece_xAxisValue, piece_yAxisValue, attacker_xAxisValue-k, attacker_yAxisValue-k);

                                                        for(let m = 0; m < possibleMoves.length; m++) {
                                                            if (possibleMoves[m] === `.cell_${attacker_xAxisValue-k}_${attacker_yAxisValue-k}`){
                                                                defendingMovements.push(possibleMoves[m]);
                                                            }
                                                        }

                                                        break;
                                                    case "whiteRook":
                                                        foundIdx = whiteRookPieces.findIndex((eachClass) => {return eachClass.position === defenderCoordinate;});
                                                        piece_xAxisValue = parseInt(whiteRookPieces[foundIdx].position.substr(6, 1));
                                                        piece_yAxisValue = parseInt(whiteRookPieces[foundIdx].position.substr(whiteRookPieces[foundIdx].position.length -1, 1));
                                                        possibleMoves = whiteRookPieces[foundIdx].possibleMove(piece_xAxisValue, piece_yAxisValue, attacker_xAxisValue-k, attacker_yAxisValue-k, true);

                                                        for(let m = 0; m < possibleMoves.length; m++) {
                                                            if (possibleMoves[m] === `.cell_${attacker_xAxisValue-k}_${attacker_yAxisValue-k}`){
                                                                defendingMovements.push(possibleMoves[m]);
                                                            }
                                                        }

                                                        break;
                                                    case "whiteQueen":
                                                        piece_xAxisValue = parseInt(whiteQueenPiece[0].position.substr(6, 1));
                                                        piece_yAxisValue = parseInt(whiteQueenPiece[0].position.substr(whiteQueenPiece[0].position.length -1, 1));
                                                        possibleMoves = whiteQueenPiece[0].possibleMove(piece_xAxisValue, piece_yAxisValue, attacker_xAxisValue-k, attacker_yAxisValue-k);

                                                        for(let m = 0; m < possibleMoves.length; m++) {
                                                            if (possibleMoves[m] === `.cell_${attacker_xAxisValue-k}_${attacker_yAxisValue-k}`){
                                                                defendingMovements.push(possibleMoves[m]);
                                                            }
                                                        }

                                                        break;
                                                    
                                                }   /////// end of switch case for defending piece can block the enemy

                                            } // looping done
                                        } // attacker is bottom right, king is top left end


                                        // attacker is bottom left, king is top right
                                        if(diff_xValue > 0 && diff_yValue < 0) {
                                            for (let k = 1; k < Math.abs(diff_xValue); k++) {

                                                // check if pawn pieces can block the attacker
                                                switch (defenderPieceName) {
                                                    case "whitePawn":
                                                        foundIdx = whitePawnPieces.findIndex((eachClass) => {return eachClass.position === defenderCoordinate;});
                                                        piece_xAxisValue = parseInt(whitePawnPieces[foundIdx].position.substr(6, 1));
                                                        piece_yAxisValue = parseInt(whitePawnPieces[foundIdx].position.substr(whitePawnPieces[foundIdx].position.length -1, 1));
                                                        possibleMoves = whitePawnPieces[foundIdx].possibleMove(piece_xAxisValue, piece_yAxisValue, true, attacker_xAxisValue-k, attacker_yAxisValue+k);

                                                        for(let m = 0; m < possibleMoves.length; m++) {
                                                            if (possibleMoves[m] === `.cell_${attacker_xAxisValue-k}_${attacker_yAxisValue+k}`){
                                                                defendingMovements.push(possibleMoves[m]);
                                                            }
                                                        }

                                                        break;
                                                    case "whiteKnight":
                                                        foundIdx = whiteKnightPieces.findIndex((eachClass) => {return eachClass.position === defenderCoordinate;});
                                                        piece_xAxisValue = parseInt(whiteKnightPieces[foundIdx].position.substr(6, 1));
                                                        piece_yAxisValue = parseInt(whiteKnightPieces[foundIdx].position.substr(whiteKnightPieces[foundIdx].position.length -1, 1));
                                                        possibleMoves = whiteKnightPieces[foundIdx].possibleMove(piece_xAxisValue, piece_yAxisValue, attacker_xAxisValue-k, attacker_yAxisValue+k);

                                                        for(let m = 0; m < possibleMoves.length; m++) {
                                                            if (possibleMoves[m] === `.cell_${attacker_xAxisValue-k}_${attacker_yAxisValue+k}`){
                                                                defendingMovements.push(possibleMoves[m]);
                                                            }
                                                        }

                                                        break;
                                                    case "whiteBishop":
                                                        foundIdx = whiteBishopPieces.findIndex((eachClass) => {return eachClass.position === defenderCoordinate;});
                                                        piece_xAxisValue = parseInt(whiteBishopPieces[foundIdx].position.substr(6, 1));
                                                        piece_yAxisValue = parseInt(whiteBishopPieces[foundIdx].position.substr(whiteBishopPieces[foundIdx].position.length -1, 1));
                                                        possibleMoves = whiteBishopPieces[foundIdx].possibleMove(piece_xAxisValue, piece_yAxisValue, attacker_xAxisValue-k, attacker_yAxisValue+k);

                                                        for(let m = 0; m < possibleMoves.length; m++) {
                                                            if (possibleMoves[m] === `.cell_${attacker_xAxisValue-k}_${attacker_yAxisValue+k}`){
                                                                defendingMovements.push(possibleMoves[m]);
                                                            }
                                                        }

                                                        break;
                                                    case "whiteRook":
                                                        foundIdx = whiteRookPieces.findIndex((eachClass) => {return eachClass.position === defenderCoordinate;});
                                                        piece_xAxisValue = parseInt(whiteRookPieces[foundIdx].position.substr(6, 1));
                                                        piece_yAxisValue = parseInt(whiteRookPieces[foundIdx].position.substr(whiteRookPieces[foundIdx].position.length -1, 1));
                                                        possibleMoves = whiteRookPieces[foundIdx].possibleMove(piece_xAxisValue, piece_yAxisValue, attacker_xAxisValue-k, attacker_yAxisValue+k, true);

                                                        for(let m = 0; m < possibleMoves.length; m++) {
                                                            if (possibleMoves[m] === `.cell_${attacker_xAxisValue-k}_${attacker_yAxisValue+k}`){
                                                                defendingMovements.push(possibleMoves[m]);
                                                            }
                                                        }

                                                        break;
                                                    case "whiteQueen":
                                                        piece_xAxisValue = parseInt(whiteQueenPiece[0].position.substr(6, 1));
                                                        piece_yAxisValue = parseInt(whiteQueenPiece[0].position.substr(whiteQueenPiece[0].position.length -1, 1));
                                                        possibleMoves = whiteQueenPiece[0].possibleMove(piece_xAxisValue, piece_yAxisValue, attacker_xAxisValue-k, attacker_yAxisValue+k);

                                                        for(let m = 0; m < possibleMoves.length; m++) {
                                                            if (possibleMoves[m] === `.cell_${attacker_xAxisValue-k}_${attacker_yAxisValue+k}`){
                                                                defendingMovements.push(possibleMoves[m]);
                                                            }
                                                        }

                                                        break;
                                                    
                                                }   /////// end of switch case for defending piece can block the enemy
                                            } // looping done
                                        } // attacker is bottom left, king is top right end


                                        // attacker is top right, king is down left
                                        if(diff_xValue < 0 && diff_yValue > 0) {
                                            for (let k = 1; k < Math.abs(diff_xValue); k++) {

                                                // check if pawn pieces can block the attacker
                                                switch (defenderPieceName) {
                                                    case "whitePawn":
                                                        foundIdx = whitePawnPieces.findIndex((eachClass) => {return eachClass.position === defenderCoordinate;});
                                                        piece_xAxisValue = parseInt(whitePawnPieces[foundIdx].position.substr(6, 1));
                                                        piece_yAxisValue = parseInt(whitePawnPieces[foundIdx].position.substr(whitePawnPieces[foundIdx].position.length -1, 1));
                                                        possibleMoves = whitePawnPieces[foundIdx].possibleMove(piece_xAxisValue, piece_yAxisValue, true, attacker_xAxisValue+k, attacker_yAxisValue-k);

                                                        for(let m = 0; m < possibleMoves.length; m++) {
                                                            if (possibleMoves[m] === `.cell_${attacker_xAxisValue+k}_${attacker_yAxisValue-k}`){
                                                                defendingMovements.push(possibleMoves[m]);
                                                            }
                                                        }

                                                        break;
                                                    case "whiteKnight":
                                                        foundIdx = whiteKnightPieces.findIndex((eachClass) => {return eachClass.position === defenderCoordinate;});
                                                        piece_xAxisValue = parseInt(whiteKnightPieces[foundIdx].position.substr(6, 1));
                                                        piece_yAxisValue = parseInt(whiteKnightPieces[foundIdx].position.substr(whiteKnightPieces[foundIdx].position.length -1, 1));
                                                        possibleMoves = whiteKnightPieces[foundIdx].possibleMove(piece_xAxisValue, piece_yAxisValue, attacker_xAxisValue+k, attacker_yAxisValue-k);

                                                        for(let m = 0; m < possibleMoves.length; m++) {
                                                            if (possibleMoves[m] === `.cell_${attacker_xAxisValue+k}_${attacker_yAxisValue-k}`){
                                                                defendingMovements.push(possibleMoves[m]);
                                                            }
                                                        }

                                                        break;
                                                    case "whiteBishop":
                                                        foundIdx = whiteBishopPieces.findIndex((eachClass) => {return eachClass.position === defenderCoordinate;});
                                                        piece_xAxisValue = parseInt(whiteBishopPieces[foundIdx].position.substr(6, 1));
                                                        piece_yAxisValue = parseInt(whiteBishopPieces[foundIdx].position.substr(whiteBishopPieces[foundIdx].position.length -1, 1));
                                                        possibleMoves = whiteBishopPieces[foundIdx].possibleMove(piece_xAxisValue, piece_yAxisValue, attacker_xAxisValue+k, attacker_yAxisValue-k);

                                                        for(let m = 0; m < possibleMoves.length; m++) {
                                                            if (possibleMoves[m] === `.cell_${attacker_xAxisValue+k}_${attacker_yAxisValue-k}`){
                                                                defendingMovements.push(possibleMoves[m]);
                                                            }
                                                        }

                                                        break;
                                                    case "whiteRook":
                                                        foundIdx = whiteRookPieces.findIndex((eachClass) => {return eachClass.position === defenderCoordinate;});
                                                        piece_xAxisValue = parseInt(whiteRookPieces[foundIdx].position.substr(6, 1));
                                                        piece_yAxisValue = parseInt(whiteRookPieces[foundIdx].position.substr(whiteRookPieces[foundIdx].position.length -1, 1));
                                                        possibleMoves = whiteRookPieces[foundIdx].possibleMove(piece_xAxisValue, piece_yAxisValue, attacker_xAxisValue+k, attacker_yAxisValue-k, true);

                                                        for(let m = 0; m < possibleMoves.length; m++) {
                                                            if (possibleMoves[m] === `.cell_${attacker_xAxisValue+k}_${attacker_yAxisValue-k}`){
                                                                defendingMovements.push(possibleMoves[m]);
                                                            }
                                                        }

                                                        break;
                                                    case "whiteQueen":
                                                        piece_xAxisValue = parseInt(whiteQueenPiece[0].position.substr(6, 1));
                                                        piece_yAxisValue = parseInt(whiteQueenPiece[0].position.substr(whiteQueenPiece[0].position.length -1, 1));
                                                        possibleMoves = whiteQueenPiece[0].possibleMove(piece_xAxisValue, piece_yAxisValue, attacker_xAxisValue+k, attacker_yAxisValue-k);

                                                        for(let m = 0; m < possibleMoves.length; m++) {
                                                            if (possibleMoves[m] === `.cell_${attacker_xAxisValue+k}_${attacker_yAxisValue-k}`){
                                                                defendingMovements.push(possibleMoves[m]);
                                                            }
                                                        }

                                                        break;
                                                    
                                                }   /////// end of switch case for defending piece can block the enemy
                                            } // looping done
                                        } // attacker is top right, king is bottom left end

                                        // attacker is top right, king is bottom right start
                                        if(diff_xValue < 0 && diff_yValue < 0) {
                                            for (let k = 1; k < Math.abs(diff_xValue); k++) {

                                                // check if pawn pieces can block the attacker
                                                // check if pawn pieces can block the attacker
                                                switch (defenderPieceName) {
                                                    case "whitePawn":
                                                        foundIdx = whitePawnPieces.findIndex((eachClass) => {return eachClass.position === defenderCoordinate;});
                                                        piece_xAxisValue = parseInt(whitePawnPieces[foundIdx].position.substr(6, 1));
                                                        piece_yAxisValue = parseInt(whitePawnPieces[foundIdx].position.substr(whitePawnPieces[foundIdx].position.length -1, 1));
                                                        possibleMoves = whitePawnPieces[foundIdx].possibleMove(piece_xAxisValue, piece_yAxisValue, true, attacker_xAxisValue+k, attacker_yAxisValue+k);

                                                        for(let m = 0; m < possibleMoves.length; m++) {
                                                            if (possibleMoves[m] === `.cell_${attacker_xAxisValue+k}_${attacker_yAxisValue+k}`){
                                                                defendingMovements.push(possibleMoves[m]);
                                                            }
                                                        }

                                                        break;
                                                    case "whiteKnight":
                                                        foundIdx = whiteKnightPieces.findIndex((eachClass) => {return eachClass.position === defenderCoordinate;});
                                                        piece_xAxisValue = parseInt(whiteKnightPieces[foundIdx].position.substr(6, 1));
                                                        piece_yAxisValue = parseInt(whiteKnightPieces[foundIdx].position.substr(whiteKnightPieces[foundIdx].position.length -1, 1));
                                                        possibleMoves = whiteKnightPieces[foundIdx].possibleMove(piece_xAxisValue, piece_yAxisValue, attacker_xAxisValue+k, attacker_yAxisValue+k);

                                                        for(let m = 0; m < possibleMoves.length; m++) {
                                                            if (possibleMoves[m] === `.cell_${attacker_xAxisValue+k}_${attacker_yAxisValue+k}`){
                                                                defendingMovements.push(possibleMoves[m]);
                                                            }
                                                        }

                                                        break;
                                                    case "whiteBishop":
                                                        foundIdx = whiteBishopPieces.findIndex((eachClass) => {return eachClass.position === defenderCoordinate;});
                                                        piece_xAxisValue = parseInt(whiteBishopPieces[foundIdx].position.substr(6, 1));
                                                        piece_yAxisValue = parseInt(whiteBishopPieces[foundIdx].position.substr(whiteBishopPieces[foundIdx].position.length -1, 1));
                                                        possibleMoves = whiteBishopPieces[foundIdx].possibleMove(piece_xAxisValue, piece_yAxisValue, attacker_xAxisValue+k, attacker_yAxisValue+k);

                                                        for(let m = 0; m < possibleMoves.length; m++) {
                                                            if (possibleMoves[m] === `.cell_${attacker_xAxisValue+k}_${attacker_yAxisValue+k}`){
                                                                defendingMovements.push(possibleMoves[m]);
                                                            }
                                                        }

                                                        break;
                                                    case "whiteRook":
                                                        foundIdx = whiteRookPieces.findIndex((eachClass) => {return eachClass.position === defenderCoordinate;});
                                                        piece_xAxisValue = parseInt(whiteRookPieces[foundIdx].position.substr(6, 1));
                                                        piece_yAxisValue = parseInt(whiteRookPieces[foundIdx].position.substr(whiteRookPieces[foundIdx].position.length -1, 1));
                                                        possibleMoves = whiteRookPieces[foundIdx].possibleMove(piece_xAxisValue, piece_yAxisValue, attacker_xAxisValue+k, attacker_yAxisValue+k, true);

                                                        for(let m = 0; m < possibleMoves.length; m++) {
                                                            if (possibleMoves[m] === `.cell_${attacker_xAxisValue+k}_${attacker_yAxisValue+k}`){
                                                                defendingMovements.push(possibleMoves[m]);
                                                            }
                                                        }

                                                        break;
                                                    case "whiteQueen":
                                                        piece_xAxisValue = parseInt(whiteQueenPiece[0].position.substr(6, 1));
                                                        piece_yAxisValue = parseInt(whiteQueenPiece[0].position.substr(whiteQueenPiece[0].position.length -1, 1));
                                                        possibleMoves = whiteQueenPiece[0].possibleMove(piece_xAxisValue, piece_yAxisValue, attacker_xAxisValue+k, attacker_yAxisValue+k);

                                                        for(let m = 0; m < possibleMoves.length; m++) {
                                                            if (possibleMoves[m] === `.cell_${attacker_xAxisValue+k}_${attacker_yAxisValue+k}`){
                                                                defendingMovements.push(possibleMoves[m]);
                                                            }
                                                        }

                                                        break;
                                                    
                                                }   /////// end of switch case for defending piece can block the enemy

                                            } // looping done
                                        } // attacker is top right, king is bottom right end
                                    }
                                } // checked if it is all black queen and black bishop
                                ////////////////////// other pieces blocking calculation done


                                /////// Black Pieces defending start
                                if (attackerPieceName.includes("whiteRook") || attackerPieceName.includes("whiteQueen")){
                                    // check left and right
                                    if(attacker_xAxisValue === king_xAxisValue) {   
                                        let diff_yValue = attacker_yAxisValue - king_yAxisValue;
                                        if (diff_yValue > 0){
                                            // positive value: king is at the left and rook is at the right
                                            // rook or queen movement infiltration
                                            for(let k = 1; k < diff_yValue; k++){
                                                //////// Switch cases for each piece
                                                switch (defenderPieceName) {
                                                    case "blackPawn":
                                                        foundIdx = blackPawnPieces.findIndex((eachClass) => {return eachClass.position === defenderCoordinate;});
                                                        piece_xAxisValue = parseInt(blackPawnPieces[foundIdx].position.substr(6, 1));
                                                        piece_yAxisValue = parseInt(blackPawnPieces[foundIdx].position.substr(blackPawnPieces[foundIdx].position.length -1, 1));
                                                        possibleMoves = blackPawnPieces[foundIdx].possibleMove(piece_xAxisValue, piece_yAxisValue, true, attacker_xAxisValue, attacker_yAxisValue-k);

                                                        for(let m = 0; m < possibleMoves.length; m++) {
                                                            if (possibleMoves[m] === `.cell_${attacker_xAxisValue}_${attacker_yAxisValue-k}`){
                                                                defendingMovements.push(possibleMoves[m]);
                                                            }
                                                        }

                                                        break;
                                                    case "blackKnight":
                                                        foundIdx = blackKnightPieces.findIndex((eachClass) => {return eachClass.position === defenderCoordinate;});
                                                        piece_xAxisValue = parseInt(blackKnightPieces[foundIdx].position.substr(6, 1));
                                                        piece_yAxisValue = parseInt(blackKnightPieces[foundIdx].position.substr(blackKnightPieces[foundIdx].position.length -1, 1));
                                                        possibleMoves = blackKnightPieces[foundIdx].possibleMove(piece_xAxisValue, piece_yAxisValue, attacker_xAxisValue, attacker_yAxisValue-k);

                                                        for(let m = 0; m < possibleMoves.length; m++) {
                                                            if (possibleMoves[m] === `.cell_${attacker_xAxisValue}_${attacker_yAxisValue-k}`){
                                                                defendingMovements.push(possibleMoves[m]);
                                                            }
                                                        }

                                                        break;
                                                    case "blackBishop":
                                                        foundIdx = blackBishopPieces.findIndex((eachClass) => {return eachClass.position === defenderCoordinate;});
                                                        piece_xAxisValue = parseInt(blackBishopPieces[foundIdx].position.substr(6, 1));
                                                        piece_yAxisValue = parseInt(blackBishopPieces[foundIdx].position.substr(blackBishopPieces[foundIdx].position.length -1, 1));
                                                        possibleMoves = blackBishopPieces[foundIdx].possibleMove(piece_xAxisValue, piece_yAxisValue, attacker_xAxisValue, attacker_yAxisValue-k);

                                                        for(let m = 0; m < possibleMoves.length; m++) {
                                                            if (possibleMoves[m] === `.cell_${attacker_xAxisValue}_${attacker_yAxisValue-k}`){
                                                                defendingMovements.push(possibleMoves[m]);
                                                            }
                                                        }

                                                        break;
                                                    case "blackRook":
                                                        foundIdx = blackRookPieces.findIndex((eachClass) => {return eachClass.position === defenderCoordinate;});
                                                        piece_xAxisValue = parseInt(blackRookPieces[foundIdx].position.substr(6, 1));
                                                        piece_yAxisValue = parseInt(blackRookPieces[foundIdx].position.substr(blackRookPieces[foundIdx].position.length -1, 1));
                                                        possibleMoves = blackRookPieces[foundIdx].possibleMove(piece_xAxisValue, piece_yAxisValue, attacker_xAxisValue, attacker_yAxisValue-k, true);

                                                        for(let m = 0; m < possibleMoves.length; m++) {
                                                            if (possibleMoves[m] === `.cell_${attacker_xAxisValue}_${attacker_yAxisValue-k}`){
                                                                defendingMovements.push(possibleMoves[m]);
                                                            }
                                                        }

                                                        break;
                                                    case "blackQueen":
                                                        piece_xAxisValue = parseInt(blackQueenPiece[0].position.substr(6, 1));
                                                        piece_yAxisValue = parseInt(blackQueenPiece[0].position.substr(blackQueenPiece[0].position.length -1, 1));
                                                        possibleMoves = blackQueenPiece[0].possibleMove(piece_xAxisValue, piece_yAxisValue, attacker_xAxisValue, attacker_yAxisValue-k);

                                                        for(let m = 0; m < possibleMoves.length; m++) {
                                                            if (possibleMoves[m] === `.cell_${attacker_xAxisValue}_${attacker_yAxisValue-k}`){
                                                                defendingMovements.push(possibleMoves[m]);
                                                            }
                                                        }

                                                        break;
                                                    
                                                
                                                }   /////// end of switch case for defending piece can block the enemy         
                                            } 
                                        // king is at the right rook is at the left
                                        } else if (diff_yValue < 0) {
                                            // rook or queen movement infiltration
                                            for(let k = 1; k < Math.abs(diff_yValue); k++){
                                                /////////////// king is at the right and enemy rook is at the left
                                                //////// Switch cases for each piece
                                                switch (defenderPieceName) {
                                                    case "blackPawn":
                                                        foundIdx = blackPawnPieces.findIndex((eachClass) => {return eachClass.position === defenderCoordinate;});
                                                        piece_xAxisValue = parseInt(blackPawnPieces[foundIdx].position.substr(6, 1));
                                                        piece_yAxisValue = parseInt(blackPawnPieces[foundIdx].position.substr(blackPawnPieces[foundIdx].position.length -1, 1));
                                                        possibleMoves = blackPawnPieces[foundIdx].possibleMove(piece_xAxisValue, piece_yAxisValue, true, attacker_xAxisValue, attacker_yAxisValue+k);

                                                        for(let m = 0; m < possibleMoves.length; m++) {
                                                            if (possibleMoves[m] === `.cell_${attacker_xAxisValue}_${attacker_yAxisValue+k}`){
                                                                defendingMovements.push(possibleMoves[m]);
                                                            }
                                                        }

                                                        break;
                                                    case "blackKnight":
                                                        foundIdx = blackKnightPieces.findIndex((eachClass) => {return eachClass.position === defenderCoordinate;});
                                                        piece_xAxisValue = parseInt(blackKnightPieces[foundIdx].position.substr(6, 1));
                                                        piece_yAxisValue = parseInt(blackKnightPieces[foundIdx].position.substr(blackKnightPieces[foundIdx].position.length -1, 1));
                                                        possibleMoves = blackKnightPieces[foundIdx].possibleMove(piece_xAxisValue, piece_yAxisValue, attacker_xAxisValue, attacker_yAxisValue+k);

                                                        for(let m = 0; m < possibleMoves.length; m++) {
                                                            if (possibleMoves[m] === `.cell_${attacker_xAxisValue}_${attacker_yAxisValue+k}`){
                                                                defendingMovements.push(possibleMoves[m]);
                                                            }
                                                        }

                                                        break;
                                                    case "blackBishop":
                                                        foundIdx = blackBishopPieces.findIndex((eachClass) => {return eachClass.position === defenderCoordinate;});
                                                        piece_xAxisValue = parseInt(blackBishopPieces[foundIdx].position.substr(6, 1));
                                                        piece_yAxisValue = parseInt(blackBishopPieces[foundIdx].position.substr(blackBishopPieces[foundIdx].position.length -1, 1));
                                                        possibleMoves = blackBishopPieces[foundIdx].possibleMove(piece_xAxisValue, piece_yAxisValue, attacker_xAxisValue, attacker_yAxisValue+k);

                                                        for(let m = 0; m < possibleMoves.length; m++) {
                                                            if (possibleMoves[m] === `.cell_${attacker_xAxisValue}_${attacker_yAxisValue+k}`){
                                                                defendingMovements.push(possibleMoves[m]);
                                                            }
                                                        }

                                                        break;
                                                    case "blackRook":
                                                        foundIdx = blackRookPieces.findIndex((eachClass) => {return eachClass.position === defenderCoordinate;});
                                                        piece_xAxisValue = parseInt(blackRookPieces[foundIdx].position.substr(6, 1));
                                                        piece_yAxisValue = parseInt(blackRookPieces[foundIdx].position.substr(blackRookPieces[foundIdx].position.length -1, 1));
                                                        possibleMoves = blackRookPieces[foundIdx].possibleMove(piece_xAxisValue, piece_yAxisValue, attacker_xAxisValue, attacker_yAxisValue+k, true);

                                                        for(let m = 0; m < possibleMoves.length; m++) {
                                                            if (possibleMoves[m] === `.cell_${attacker_xAxisValue}_${attacker_yAxisValue+k}`){
                                                                defendingMovements.push(possibleMoves[m]);
                                                            }
                                                        }

                                                        break;
                                                    case "blackQueen":
                                                        piece_xAxisValue = parseInt(blackQueenPiece[0].position.substr(6, 1));
                                                        piece_yAxisValue = parseInt(blackQueenPiece[0].position.substr(blackQueenPiece[0].position.length -1, 1));
                                                        possibleMoves = blackQueenPiece[0].possibleMove(piece_xAxisValue, piece_yAxisValue, attacker_xAxisValue, attacker_yAxisValue+k);

                                                        for(let m = 0; m < possibleMoves.length; m++) {
                                                            if (possibleMoves[m] === `.cell_${attacker_xAxisValue}_${attacker_yAxisValue+k}`){
                                                                defendingMovements.push(possibleMoves[m]);
                                                            }
                                                        }

                                                        break;
                                                    
                                                         
                                                } /////// end of switch case for defending piece can block the enemy
                                            
                                                /////////////// king is at the right and enemy rook is at the left
                                                // check diff yvalue is bigger than 0
                                            } // for loop of movement end
                                        } // check for left and right rook or queen
                                    } // everything complete for left and right check


                                    // check for up and down
                                    if(attacker_yAxisValue === king_yAxisValue) {   
                                        let diff_xValue = attacker_xAxisValue - king_xAxisValue;
                                        if (diff_xValue > 0){
                                            // positive value: king is at the up and rook is at the down
                                            // rook or queen movement infiltration
                                            for(let k = 1; k < diff_xValue; k++){

                                                //// if white pawn pieces can defend or block the enemy start
                                                switch (defenderPieceName) {
                                                    case "blackPawn":
                                                        foundIdx = blackPawnPieces.findIndex((eachClass) => {return eachClass.position === defenderCoordinate;});
                                                        piece_xAxisValue = parseInt(blackPawnPieces[foundIdx].position.substr(6, 1));
                                                        piece_yAxisValue = parseInt(blackPawnPieces[foundIdx].position.substr(blackPawnPieces[foundIdx].position.length -1, 1));
                                                        possibleMoves = blackPawnPieces[foundIdx].possibleMove(piece_xAxisValue, piece_yAxisValue, true, attacker_xAxisValue-k, attacker_yAxisValue);

                                                        for(let m = 0; m < possibleMoves.length; m++) {
                                                            if (possibleMoves[m] === `.cell_${attacker_xAxisValue-k}_${attacker_yAxisValue}`){
                                                                defendingMovements.push(possibleMoves[m]);
                                                            }
                                                        }

                                                        break;
                                                    case "blackKnight":
                                                        foundIdx = blackKnightPieces.findIndex((eachClass) => {return eachClass.position === defenderCoordinate;});
                                                        piece_xAxisValue = parseInt(blackKnightPieces[foundIdx].position.substr(6, 1));
                                                        piece_yAxisValue = parseInt(blackKnightPieces[foundIdx].position.substr(blackKnightPieces[foundIdx].position.length -1, 1));
                                                        possibleMoves = blackKnightPieces[foundIdx].possibleMove(piece_xAxisValue, piece_yAxisValue, attacker_xAxisValue-k, attacker_yAxisValue);

                                                        for(let m = 0; m < possibleMoves.length; m++) {
                                                            if (possibleMoves[m] === `.cell_${attacker_xAxisValue-k}_${attacker_yAxisValue}`){
                                                                defendingMovements.push(possibleMoves[m]);
                                                            }
                                                        }

                                                        break;
                                                    case "blackBishop":
                                                        foundIdx = blackBishopPieces.findIndex((eachClass) => {return eachClass.position === defenderCoordinate;});
                                                        piece_xAxisValue = parseInt(blackBishopPieces[foundIdx].position.substr(6, 1));
                                                        piece_yAxisValue = parseInt(blackBishopPieces[foundIdx].position.substr(blackBishopPieces[foundIdx].position.length -1, 1));
                                                        possibleMoves = blackBishopPieces[foundIdx].possibleMove(piece_xAxisValue, piece_yAxisValue, attacker_xAxisValue-k, attacker_yAxisValue);

                                                        for(let m = 0; m < possibleMoves.length; m++) {
                                                            if (possibleMoves[m] === `.cell_${attacker_xAxisValue-k}_${attacker_yAxisValue}`){
                                                                defendingMovements.push(possibleMoves[m]);
                                                            }
                                                        }

                                                        break;
                                                    case "blackRook":
                                                        foundIdx = blackRookPieces.findIndex((eachClass) => {return eachClass.position === defenderCoordinate;});
                                                        piece_xAxisValue = parseInt(blackRookPieces[foundIdx].position.substr(6, 1));
                                                        piece_yAxisValue = parseInt(blackRookPieces[foundIdx].position.substr(blackRookPieces[foundIdx].position.length -1, 1));
                                                        possibleMoves = blackRookPieces[foundIdx].possibleMove(piece_xAxisValue, piece_yAxisValue, attacker_xAxisValue-k, attacker_yAxisValue, true);

                                                        for(let m = 0; m < possibleMoves.length; m++) {
                                                            if (possibleMoves[m] === `.cell_${attacker_xAxisValue-k}_${attacker_yAxisValue}`){
                                                                defendingMovements.push(possibleMoves[m]);
                                                            }
                                                        }

                                                        break;
                                                    case "blackQueen":
                                                        piece_xAxisValue = parseInt(blackQueenPiece[0].position.substr(6, 1));
                                                        piece_yAxisValue = parseInt(blackQueenPiece[0].position.substr(blackQueenPiece[0].position.length -1, 1));
                                                        possibleMoves = blackQueenPiece[0].possibleMove(piece_xAxisValue, piece_yAxisValue, attacker_xAxisValue-k, attacker_yAxisValue);

                                                        for(let m = 0; m < possibleMoves.length; m++) {
                                                            if (possibleMoves[m] === `.cell_${attacker_xAxisValue-k}_${attacker_yAxisValue}`){
                                                                defendingMovements.push(possibleMoves[m]);
                                                            }
                                                        }

                                                        break;
                                                    
                                                         
                                                } /////// end of switch case for defending piece can block the enemy
                                            }
                                                //// if white pawn pieces can defend or block the enemy end
                                        // king is at the bottom rook is at the top
                                        } else if (diff_xValue < 0) {
                                            // rook or queen movement infiltration
                                            for(let k = 1; k < Math.abs(diff_xValue); k++){

                                                // // if white pawn pieces can defend or block the enemy start
                                                switch (defenderPieceName) {
                                                    case "blackPawn":
                                                        foundIdx = blackPawnPieces.findIndex((eachClass) => {return eachClass.position === defenderCoordinate;});
                                                        piece_xAxisValue = parseInt(blackPawnPieces[foundIdx].position.substr(6, 1));
                                                        piece_yAxisValue = parseInt(blackPawnPieces[foundIdx].position.substr(blackPawnPieces[foundIdx].position.length -1, 1));
                                                        possibleMoves = blackPawnPieces[foundIdx].possibleMove(piece_xAxisValue, piece_yAxisValue, true, attacker_xAxisValue+k, attacker_yAxisValue);

                                                        for(let m = 0; m < possibleMoves.length; m++) {
                                                            if (possibleMoves[m] === `.cell_${attacker_xAxisValue+k}_${attacker_yAxisValue}`){
                                                                defendingMovements.push(possibleMoves[m]);
                                                            }
                                                        }

                                                        break;
                                                    case "blackKnight":
                                                        foundIdx = blackKnightPieces.findIndex((eachClass) => {return eachClass.position === defenderCoordinate;});
                                                        piece_xAxisValue = parseInt(blackKnightPieces[foundIdx].position.substr(6, 1));
                                                        piece_yAxisValue = parseInt(blackKnightPieces[foundIdx].position.substr(blackKnightPieces[foundIdx].position.length -1, 1));
                                                        possibleMoves = blackKnightPieces[foundIdx].possibleMove(piece_xAxisValue, piece_yAxisValue, attacker_xAxisValue+k, attacker_yAxisValue);

                                                        for(let m = 0; m < possibleMoves.length; m++) {
                                                            if (possibleMoves[m] === `.cell_${attacker_xAxisValue+k}_${attacker_yAxisValue}`){
                                                                defendingMovements.push(possibleMoves[m]);
                                                            }
                                                        }

                                                        break;
                                                    case "blackBishop":
                                                        foundIdx = blackBishopPieces.findIndex((eachClass) => {return eachClass.position === defenderCoordinate;});
                                                        piece_xAxisValue = parseInt(blackBishopPieces[foundIdx].position.substr(6, 1));
                                                        piece_yAxisValue = parseInt(blackBishopPieces[foundIdx].position.substr(blackBishopPieces[foundIdx].position.length -1, 1));
                                                        possibleMoves = blackBishopPieces[foundIdx].possibleMove(piece_xAxisValue, piece_yAxisValue, attacker_xAxisValue+k, attacker_yAxisValue);

                                                        for(let m = 0; m < possibleMoves.length; m++) {
                                                            if (possibleMoves[m] === `.cell_${attacker_xAxisValue+k}_${attacker_yAxisValue}`){
                                                                defendingMovements.push(possibleMoves[m]);
                                                            }
                                                        }

                                                        break;
                                                    case "blackRook":
                                                        foundIdx = blackRookPieces.findIndex((eachClass) => {return eachClass.position === defenderCoordinate;});
                                                        piece_xAxisValue = parseInt(blackRookPieces[foundIdx].position.substr(6, 1));
                                                        piece_yAxisValue = parseInt(blackRookPieces[foundIdx].position.substr(blackRookPieces[foundIdx].position.length -1, 1));
                                                        possibleMoves = blackRookPieces[foundIdx].possibleMove(piece_xAxisValue, piece_yAxisValue, attacker_xAxisValue+k, attacker_yAxisValue, true);

                                                        for(let m = 0; m < possibleMoves.length; m++) {
                                                            if (possibleMoves[m] === `.cell_${attacker_xAxisValue+k}_${attacker_yAxisValue}`){
                                                                defendingMovements.push(possibleMoves[m]);
                                                            }
                                                        }

                                                        break;
                                                    case "blackQueen":
                                                        piece_xAxisValue = parseInt(blackQueenPiece[0].position.substr(6, 1));
                                                        piece_yAxisValue = parseInt(blackQueenPiece[0].position.substr(blackQueenPiece[0].position.length -1, 1));
                                                        possibleMoves = blackQueenPiece[0].possibleMove(piece_xAxisValue, piece_yAxisValue, attacker_xAxisValue+k, attacker_yAxisValue);

                                                        for(let m = 0; m < possibleMoves.length; m++) {
                                                            if (possibleMoves[m] === `.cell_${attacker_xAxisValue+k}_${attacker_yAxisValue}`){
                                                                defendingMovements.push(possibleMoves[m]);
                                                            }
                                                        }

                                                        break;
                                                    
                                                          
                                                } /////// end of switch case for defending piece can block the enemy

                                            } // for loop of movement end
                                        } // end of diff_xValue is negative

                                    } // check for up and down rook or queen
                                } // check for all white rook and white queen
                                ///////////////////

                                // if the attacker is black bishop or black queen
                                if (attackerPieceName.includes("whiteQueen") || attackerPieceName.includes("whiteBishop")){
                                    let diff_xValue = attacker_xAxisValue - king_xAxisValue;
                                    let diff_yValue = attacker_yAxisValue - king_yAxisValue;

                                    // it has to be diagonal
                                    if(Math.abs(diff_xValue) === Math.abs(diff_yValue)) {
                                        
                                        // attacker is bottom right, king is top left
                                        if(diff_xValue > 0 && diff_yValue > 0) {
                                            for (let k = 1; k < Math.abs(diff_xValue); k++) {

                                                // check if pawn pieces can block the attacker
                                                switch (defenderPieceName) {
                                                    case "blackPawn":
                                                        foundIdx = blackPawnPieces.findIndex((eachClass) => {return eachClass.position === defenderCoordinate;});
                                                        piece_xAxisValue = parseInt(blackPawnPieces[foundIdx].position.substr(6, 1));
                                                        piece_yAxisValue = parseInt(blackPawnPieces[foundIdx].position.substr(blackPawnPieces[foundIdx].position.length -1, 1));
                                                        possibleMoves = blackPawnPieces[foundIdx].possibleMove(piece_xAxisValue, piece_yAxisValue, true, attacker_xAxisValue-k, attacker_yAxisValue-k);

                                                        for(let m = 0; m < possibleMoves.length; m++) {
                                                            if (possibleMoves[m] === `.cell_${attacker_xAxisValue-k}_${attacker_yAxisValue-k}`){
                                                                defendingMovements.push(possibleMoves[m]);
                                                            }
                                                        }

                                                        break;
                                                    case "blackKnight":
                                                        foundIdx = blackKnightPieces.findIndex((eachClass) => {return eachClass.position === defenderCoordinate;});
                                                        piece_xAxisValue = parseInt(blackKnightPieces[foundIdx].position.substr(6, 1));
                                                        piece_yAxisValue = parseInt(blackKnightPieces[foundIdx].position.substr(blackKnightPieces[foundIdx].position.length -1, 1));
                                                        possibleMoves = blackKnightPieces[foundIdx].possibleMove(piece_xAxisValue, piece_yAxisValue, attacker_xAxisValue-k, attacker_yAxisValue-k);

                                                        for(let m = 0; m < possibleMoves.length; m++) {
                                                            if (possibleMoves[m] === `.cell_${attacker_xAxisValue-k}_${attacker_yAxisValue-k}`){
                                                                defendingMovements.push(possibleMoves[m]);
                                                            }
                                                        }

                                                        break;
                                                    case "blackBishop":
                                                        foundIdx = blackBishopPieces.findIndex((eachClass) => {return eachClass.position === defenderCoordinate;});
                                                        piece_xAxisValue = parseInt(blackBishopPieces[foundIdx].position.substr(6, 1));
                                                        piece_yAxisValue = parseInt(blackBishopPieces[foundIdx].position.substr(blackBishopPieces[foundIdx].position.length -1, 1));
                                                        possibleMoves = blackBishopPieces[foundIdx].possibleMove(piece_xAxisValue, piece_yAxisValue, attacker_xAxisValue-k, attacker_yAxisValue-k);

                                                        for(let m = 0; m < possibleMoves.length; m++) {
                                                            if (possibleMoves[m] === `.cell_${attacker_xAxisValue-k}_${attacker_yAxisValue-k}`){
                                                                defendingMovements.push(possibleMoves[m]);
                                                            }
                                                        }

                                                        break;
                                                    case "blackRook":
                                                        foundIdx = blackRookPieces.findIndex((eachClass) => {return eachClass.position === defenderCoordinate;});
                                                        piece_xAxisValue = parseInt(blackRookPieces[foundIdx].position.substr(6, 1));
                                                        piece_yAxisValue = parseInt(blackRookPieces[foundIdx].position.substr(blackRookPieces[foundIdx].position.length -1, 1));
                                                        possibleMoves = blackRookPieces[foundIdx].possibleMove(piece_xAxisValue, piece_yAxisValue, attacker_xAxisValue-k, attacker_yAxisValue-k, true);

                                                        for(let m = 0; m < possibleMoves.length; m++) {
                                                            if (possibleMoves[m] === `.cell_${attacker_xAxisValue-k}_${attacker_yAxisValue-k}`){
                                                                defendingMovements.push(possibleMoves[m]);
                                                            }
                                                        }

                                                        break;
                                                    case "blackQueen":
                                                        piece_xAxisValue = parseInt(blackQueenPiece[0].position.substr(6, 1));
                                                        piece_yAxisValue = parseInt(blackQueenPiece[0].position.substr(blackQueenPiece[0].position.length -1, 1));
                                                        possibleMoves = blackQueenPiece[0].possibleMove(piece_xAxisValue, piece_yAxisValue, attacker_xAxisValue-k, attacker_yAxisValue-k);

                                                        for(let m = 0; m < possibleMoves.length; m++) {
                                                            if (possibleMoves[m] === `.cell_${attacker_xAxisValue-k}_${attacker_yAxisValue-k}`){
                                                                defendingMovements.push(possibleMoves[m]);
                                                            }
                                                        }

                                                        break;
                                                    
                                                }   /////// end of switch case for defending piece can block the enemy

                                            } // looping done
                                        } // attacker is bottom right, king is top left end


                                        // attacker is bottom left, king is top right
                                        if(diff_xValue > 0 && diff_yValue < 0) {
                                            for (let k = 1; k < Math.abs(diff_xValue); k++) {

                                                // check if pawn pieces can block the attacker
                                                switch (defenderPieceName) {
                                                    case "blackPawn":
                                                        foundIdx = blackPawnPieces.findIndex((eachClass) => {return eachClass.position === defenderCoordinate;});
                                                        piece_xAxisValue = parseInt(blackPawnPieces[foundIdx].position.substr(6, 1));
                                                        piece_yAxisValue = parseInt(blackPawnPieces[foundIdx].position.substr(blackPawnPieces[foundIdx].position.length -1, 1));
                                                        possibleMoves = blackPawnPieces[foundIdx].possibleMove(piece_xAxisValue, piece_yAxisValue, true, attacker_xAxisValue-k, attacker_yAxisValue+k);

                                                        for(let m = 0; m < possibleMoves.length; m++) {
                                                            if (possibleMoves[m] === `.cell_${attacker_xAxisValue-k}_${attacker_yAxisValue+k}`){
                                                                defendingMovements.push(possibleMoves[m]);
                                                            }
                                                        }

                                                        break;
                                                    case "blackKnight":
                                                        foundIdx = blackKnightPieces.findIndex((eachClass) => {return eachClass.position === defenderCoordinate;});
                                                        piece_xAxisValue = parseInt(blackKnightPieces[foundIdx].position.substr(6, 1));
                                                        piece_yAxisValue = parseInt(blackKnightPieces[foundIdx].position.substr(blackKnightPieces[foundIdx].position.length -1, 1));
                                                        possibleMoves = blackKnightPieces[foundIdx].possibleMove(piece_xAxisValue, piece_yAxisValue, attacker_xAxisValue-k, attacker_yAxisValue+k);

                                                        for(let m = 0; m < possibleMoves.length; m++) {
                                                            if (possibleMoves[m] === `.cell_${attacker_xAxisValue-k}_${attacker_yAxisValue+k}`){
                                                                defendingMovements.push(possibleMoves[m]);
                                                            }
                                                        }

                                                        break;
                                                    case "blackBishop":
                                                        foundIdx = blackBishopPieces.findIndex((eachClass) => {return eachClass.position === defenderCoordinate;});
                                                        piece_xAxisValue = parseInt(blackBishopPieces[foundIdx].position.substr(6, 1));
                                                        piece_yAxisValue = parseInt(blackBishopPieces[foundIdx].position.substr(blackBishopPieces[foundIdx].position.length -1, 1));
                                                        possibleMoves = blackBishopPieces[foundIdx].possibleMove(piece_xAxisValue, piece_yAxisValue, attacker_xAxisValue-k, attacker_yAxisValue+k);

                                                        for(let m = 0; m < possibleMoves.length; m++) {
                                                            if (possibleMoves[m] === `.cell_${attacker_xAxisValue-k}_${attacker_yAxisValue+k}`){
                                                                defendingMovements.push(possibleMoves[m]);
                                                            }
                                                        }

                                                        break;
                                                    case "blackRook":
                                                        foundIdx = blackRookPieces.findIndex((eachClass) => {return eachClass.position === defenderCoordinate;});
                                                        piece_xAxisValue = parseInt(blackRookPieces[foundIdx].position.substr(6, 1));
                                                        piece_yAxisValue = parseInt(blackRookPieces[foundIdx].position.substr(blackRookPieces[foundIdx].position.length -1, 1));
                                                        possibleMoves = blackRookPieces[foundIdx].possibleMove(piece_xAxisValue, piece_yAxisValue, attacker_xAxisValue-k, attacker_yAxisValue+k, true);

                                                        for(let m = 0; m < possibleMoves.length; m++) {
                                                            if (possibleMoves[m] === `.cell_${attacker_xAxisValue-k}_${attacker_yAxisValue+k}`){
                                                                defendingMovements.push(possibleMoves[m]);
                                                            }
                                                        }

                                                        break;
                                                    case "blackQueen":
                                                        piece_xAxisValue = parseInt(blackQueenPiece[0].position.substr(6, 1));
                                                        piece_yAxisValue = parseInt(blackQueenPiece[0].position.substr(blackQueenPiece[0].position.length -1, 1));
                                                        possibleMoves = blackQueenPiece[0].possibleMove(piece_xAxisValue, piece_yAxisValue, attacker_xAxisValue-k, attacker_yAxisValue+k);

                                                        for(let m = 0; m < possibleMoves.length; m++) {
                                                            if (possibleMoves[m] === `.cell_${attacker_xAxisValue-k}_${attacker_yAxisValue+k}`){
                                                                defendingMovements.push(possibleMoves[m]);
                                                            }
                                                        }

                                                        break;
                                
                                                }   /////// end of switch case for defending piece can block the enemy
                                            } // looping done
                                        } // attacker is bottom left, king is top right end


                                        // attacker is top right, king is down left
                                        if(diff_xValue < 0 && diff_yValue > 0) {
                                            for (let k = 1; k < Math.abs(diff_xValue); k++) {

                                                // check if pawn pieces can block the attacker
                                                switch (defenderPieceName) {
                                                    case "blackPawn":
                                                        foundIdx = blackPawnPieces.findIndex((eachClass) => {return eachClass.position === defenderCoordinate;});
                                                        piece_xAxisValue = parseInt(blackPawnPieces[foundIdx].position.substr(6, 1));
                                                        piece_yAxisValue = parseInt(blackPawnPieces[foundIdx].position.substr(blackPawnPieces[foundIdx].position.length -1, 1));
                                                        possibleMoves = blackPawnPieces[foundIdx].possibleMove(piece_xAxisValue, piece_yAxisValue, true, attacker_xAxisValue+k, attacker_yAxisValue-k);

                                                        for(let m = 0; m < possibleMoves.length; m++) {
                                                            if (possibleMoves[m] === `.cell_${attacker_xAxisValue+k}_${attacker_yAxisValue-k}`){
                                                                defendingMovements.push(possibleMoves[m]);
                                                            }
                                                        }

                                                        break;
                                                    case "blackKnight":
                                                        foundIdx = blackKnightPieces.findIndex((eachClass) => {return eachClass.position === defenderCoordinate;});
                                                        piece_xAxisValue = parseInt(blackKnightPieces[foundIdx].position.substr(6, 1));
                                                        piece_yAxisValue = parseInt(blackKnightPieces[foundIdx].position.substr(blackKnightPieces[foundIdx].position.length -1, 1));
                                                        possibleMoves = blackKnightPieces[foundIdx].possibleMove(piece_xAxisValue, piece_yAxisValue, attacker_xAxisValue+k, attacker_yAxisValue-k);

                                                        for(let m = 0; m < possibleMoves.length; m++) {
                                                            if (possibleMoves[m] === `.cell_${attacker_xAxisValue+k}_${attacker_yAxisValue-k}`){
                                                                defendingMovements.push(possibleMoves[m]);
                                                            }
                                                        }

                                                        break;
                                                    case "blackBishop":
                                                        foundIdx = blackBishopPieces.findIndex((eachClass) => {return eachClass.position === defenderCoordinate;});
                                                        piece_xAxisValue = parseInt(blackBishopPieces[foundIdx].position.substr(6, 1));
                                                        piece_yAxisValue = parseInt(blackBishopPieces[foundIdx].position.substr(blackBishopPieces[foundIdx].position.length -1, 1));
                                                        possibleMoves = blackBishopPieces[foundIdx].possibleMove(piece_xAxisValue, piece_yAxisValue, attacker_xAxisValue+k, attacker_yAxisValue-k);

                                                        for(let m = 0; m < possibleMoves.length; m++) {
                                                            if (possibleMoves[m] === `.cell_${attacker_xAxisValue+k}_${attacker_yAxisValue-k}`){
                                                                defendingMovements.push(possibleMoves[m]);
                                                            }
                                                        }

                                                        break;
                                                    case "blackRook":
                                                        foundIdx = blackRookPieces.findIndex((eachClass) => {return eachClass.position === defenderCoordinate;});
                                                        piece_xAxisValue = parseInt(blackRookPieces[foundIdx].position.substr(6, 1));
                                                        piece_yAxisValue = parseInt(blackRookPieces[foundIdx].position.substr(blackRookPieces[foundIdx].position.length -1, 1));
                                                        possibleMoves = blackRookPieces[foundIdx].possibleMove(piece_xAxisValue, piece_yAxisValue, attacker_xAxisValue+k, attacker_yAxisValue-k, true);

                                                        for(let m = 0; m < possibleMoves.length; m++) {
                                                            if (possibleMoves[m] === `.cell_${attacker_xAxisValue+k}_${attacker_yAxisValue-k}`){
                                                                defendingMovements.push(possibleMoves[m]);
                                                            }
                                                        }

                                                        break;
                                                    case "blackQueen":
                                                        piece_xAxisValue = parseInt(blackQueenPiece[0].position.substr(6, 1));
                                                        piece_yAxisValue = parseInt(blackQueenPiece[0].position.substr(blackQueenPiece[0].position.length -1, 1));
                                                        possibleMoves = blackQueenPiece[0].possibleMove(piece_xAxisValue, piece_yAxisValue, attacker_xAxisValue+k, attacker_yAxisValue-k);

                                                        for(let m = 0; m < possibleMoves.length; m++) {
                                                            if (possibleMoves[m] === `.cell_${attacker_xAxisValue+k}_${attacker_yAxisValue-k}`){
                                                                defendingMovements.push(possibleMoves[m]);
                                                            }
                                                        }

                                                        break;
                                                    
                                                }   /////// end of switch case for defending piece can block the enemy
                                            } // looping done
                                        } // attacker is top right, king is bottom left end

                                        // attacker is top right, king is bottom right start
                                        if(diff_xValue < 0 && diff_yValue < 0) {
                                            for (let k = 1; k < Math.abs(diff_xValue); k++) {

                                                // check if pawn pieces can block the attacker
                                                // check if pawn pieces can block the attacker
                                                switch (defenderPieceName) {
                                                    case "blackPawn":
                                                        foundIdx = blackPawnPieces.findIndex((eachClass) => {return eachClass.position === defenderCoordinate;});
                                                        piece_xAxisValue = parseInt(blackPawnPieces[foundIdx].position.substr(6, 1));
                                                        piece_yAxisValue = parseInt(blackPawnPieces[foundIdx].position.substr(blackPawnPieces[foundIdx].position.length -1, 1));
                                                        possibleMoves = blackPawnPieces[foundIdx].possibleMove(piece_xAxisValue, piece_yAxisValue, true, attacker_xAxisValue+k, attacker_yAxisValue+k);

                                                        for(let m = 0; m < possibleMoves.length; m++) {
                                                            if (possibleMoves[m] === `.cell_${attacker_xAxisValue+k}_${attacker_yAxisValue+k}`){
                                                                defendingMovements.push(possbleMoves[m]);
                                                            }
                                                        }

                                                        break;
                                                    case "blackKnight":
                                                        foundIdx = blackKnightPieces.findIndex((eachClass) => {return eachClass.position === defenderCoordinate;});
                                                        piece_xAxisValue = parseInt(blackKnightPieces[foundIdx].position.substr(6, 1));
                                                        piece_yAxisValue = parseInt(blackKnightPieces[foundIdx].position.substr(blackKnightPieces[foundIdx].position.length -1, 1));
                                                        possibleMoves = blackKnightPieces[foundIdx].possibleMove(piece_xAxisValue, piece_yAxisValue, attacker_xAxisValue+k, attacker_yAxisValue+k);

                                                        for(let m = 0; m < possibleMoves.length; m++) {
                                                            if (possibleMoves[m] === `.cell_${attacker_xAxisValue+k}_${attacker_yAxisValue+k}`){
                                                                defendingMovements.push(possibleMoves[m]);
                                                            }
                                                        }

                                                        break;
                                                    case "blackBishop":
                                                        foundIdx = blackBishopPieces.findIndex((eachClass) => {return eachClass.position === defenderCoordinate;});
                                                        piece_xAxisValue = parseInt(blackBishopPieces[foundIdx].position.substr(6, 1));
                                                        piece_yAxisValue = parseInt(blackBishopPieces[foundIdx].position.substr(blackBishopPieces[foundIdx].position.length -1, 1));
                                                        possibleMoves = blackBishopPieces[foundIdx].possibleMove(piece_xAxisValue, piece_yAxisValue, attacker_xAxisValue+k, attacker_yAxisValue+k);

                                                        for(let m = 0; m < possibleMoves.length; m++) {
                                                            if (possibleMoves[m] === `.cell_${attacker_xAxisValue+k}_${attacker_yAxisValue+k}`){
                                                                defendingMovements.push(possibleMoves[m]);
                                                            }
                                                        }

                                                        break;
                                                    case "blackRook":
                                                        foundIdx = blackRookPieces.findIndex((eachClass) => {return eachClass.position === defenderCoordinate;});
                                                        piece_xAxisValue = parseInt(blackRookPieces[foundIdx].position.substr(6, 1));
                                                        piece_yAxisValue = parseInt(blackRookPieces[foundIdx].position.substr(blackRookPieces[foundIdx].position.length -1, 1));
                                                        possibleMoves = blackRookPieces[foundIdx].possibleMove(piece_xAxisValue, piece_yAxisValue, attacker_xAxisValue+k, attacker_yAxisValue+k, true);

                                                        for(let m = 0; m < possibleMoves.length; m++) {
                                                            if (possibleMoves[m] === `.cell_${attacker_xAxisValue+k}_${attacker_yAxisValue+k}`){
                                                                defendingMovements.push(possibleMoves[m]);
                                                            }
                                                        }

                                                        break;
                                                    case "blackQueen":
                                                        piece_xAxisValue = parseInt(blackQueenPiece[0].position.substr(6, 1));
                                                        piece_yAxisValue = parseInt(blackQueenPiece[0].position.substr(blackQueenPiece[0].position.length -1, 1));
                                                        possibleMoves = blackQueenPiece[0].possibleMove(piece_xAxisValue, piece_yAxisValue, attacker_xAxisValue+k, attacker_yAxisValue+k);

                                                        for(let m = 0; m < possibleMoves.length; m++) {
                                                            if (possibleMoves[m] === `.cell_${attacker_xAxisValue+k}_${attacker_yAxisValue+k}`){
                                                                defendingMovements.push(possibleMoves[m]);
                                                            }
                                                        }

                                                        break;
                                                    
                                                    
                                                }   /////// end of switch case for defending piece can block the enemy

                                            } // looping done
                                        } // attacker is top right, king is bottom right end
                                    }
                                } 
                                //////// Black Pieces defending done

                            }

                    } // enf of switch case movements

                    return defendingMovements;


                } // end of defendingMoves function


                // isInDanger function
                isInDanger() {

                    let kingPossibleMovement = [];
                    let defendingMovements = [];
                    let xAxisValue = parseInt(this.position.substr(6, 1));
                    let yAxisValue = parseInt(this.position.substr(this.position.length - 1, 1));
                    let kingIsInDanger = false;

                    kingPossibleMovement.push(`cell_${xAxisValue}_${yAxisValue}`);

                    /////////////////////// check king's movements
                    // Each king Movement
                    for(let i = 0; i < kingPossibleMovement.length; i++){
                        let eachMovement_xAxisValue = xAxisValue;
                        let eachMovement_yAxisValue = yAxisValue;
                        let isDangerous = false;
                        let needsBreak = false;

                        // check left start rook queen
                        if(eachMovement_yAxisValue == 1) {
                            
                        } else {
                            for(let i = eachMovement_yAxisValue - 1; i >= 1; i--) {
                                // if y axis value is one, then don't check left
                                let leftPiece = document.querySelector(`.cell_${eachMovement_xAxisValue}_${i}`)
                                
                                switch(i) {
                                    case eachMovement_yAxisValue - 1:
                                        if (leftPiece.querySelector("img")) {
                                            let leftImagePiece = leftPiece.querySelector("img");
                                            if((leftImagePiece.getAttribute('alt').includes("whiteRook") || leftImagePiece.getAttribute('alt').includes("whiteQueen") || leftImagePiece.getAttribute('alt').includes("whiteKing")) && (this.color === "black")) {  
                                                needsBreak = true;
                                                isDangerous = true;
                                            } else if ((leftImagePiece.getAttribute('alt').includes("blackRook") || leftImagePiece.getAttribute('alt').includes("blackQueen") || leftImagePiece.getAttribute('alt').includes("blackKing")) && (this.color === "white")) {
                                                needsBreak = true;
                                                isDangerous = true;
                                            } else if ((leftImagePiece.getAttribute('alt').includes("black") && this.color === "black" && (!leftImagePiece.getAttribute('alt').includes("blackKing")) ) || (leftImagePiece.getAttribute('alt').includes("white") && this.color === "white" && (!leftImagePiece.getAttribute('alt').includes("whiteKing")))) {
                                                needsBreak = true;
                                                isDangerous = false;
                                            } else if (((!leftImagePiece.getAttribute('alt').includes("whiteRook")) && (!leftImagePiece.getAttribute('alt').includes("whiteQueen")) && (leftImagePiece.getAttribute('alt').includes("white")) && (this.color === "black")) || (((!leftImagePiece.getAttribute('alt').includes("blackRook")) && (!leftImagePiece.getAttribute('alt').includes("blackQueen")) && (leftImagePiece.getAttribute('alt').includes("black"))) && (this.color === "white"))) {  
                                                needsBreak = true;
                                                isDangerous = false;
                                            }
                                        } 
                                        break;
                                    default:
                                        if (leftPiece.querySelector("img")) {
                                            let leftImagePiece = leftPiece.querySelector("img");
                                            if((leftImagePiece.getAttribute('alt').includes("whiteRook") || leftImagePiece.getAttribute('alt').includes("whiteQueen")) && (this.color === "black")) {
                                                needsBreak = true;
                                                isDangerous = true;
                                            } else if ((leftImagePiece.getAttribute('alt').includes("blackRook") || leftImagePiece.getAttribute('alt').includes("blackQueen")) && (this.color === "white")) {
                                                needsBreak = true;
                                                isDangerous = true;
                                            } else if ((leftImagePiece.getAttribute('alt').includes("black") && this.color === "black" && (!leftImagePiece.getAttribute('alt').includes("blackKing")) ) || (leftImagePiece.getAttribute('alt').includes("white") && this.color === "white" && (!leftImagePiece.getAttribute('alt').includes("whiteKing")))) {
                                                needsBreak = true;
                                                isDangerous = false;
                                            } else if (((!leftImagePiece.getAttribute('alt').includes("whiteRook")) && (!leftImagePiece.getAttribute('alt').includes("whiteQueen")) && (leftImagePiece.getAttribute('alt').includes("white")) && (this.color === "black")) || (((!leftImagePiece.getAttribute('alt').includes("blackRook")) && (!leftImagePiece.getAttribute('alt').includes("blackQueen")) && (leftImagePiece.getAttribute('alt').includes("black"))) && (this.color === "white"))) {  
                                                needsBreak = true;
                                                isDangerous = false;
                                            }
                                        }
                                        
                                        break;
                                } // end of switch case

                                if (needsBreak) {
                                    break;
                                }
                                    
                            } // end of inner for each statement left side
                        } // check left finished

                        // if isDangerous is true then go to the next outer for each element of loop so continue
                        if (isDangerous) {
                            continue;
                        }
                        
                        // start over
                        needsBreak = false;
                        isDangerous = false;

                        // check right rook and queen
                        if(eachMovement_yAxisValue == 8) {
                            
                        } else {
                            for(let i = eachMovement_yAxisValue + 1; i <= 8; i++) {
                                let rightPiece = document.querySelector(`.cell_${eachMovement_xAxisValue}_${i}`)
                                
                                switch(i) {
                                    case eachMovement_yAxisValue + 1:
                                        if (rightPiece.querySelector("img")) {
                                            let rightImagePiece = rightPiece.querySelector("img");
                                            if((rightImagePiece.getAttribute('alt').includes("whiteRook") || rightImagePiece.getAttribute('alt').includes("whiteQueen") || rightImagePiece.getAttribute('alt').includes("whiteKing")) && (this.color === "black")) {
                                                needsBreak = true;
                                                isDangerous = true;
                                            } else if ((rightImagePiece.getAttribute('alt').includes("blackRook") || rightImagePiece.getAttribute('alt').includes("blackQueen") || rightImagePiece.getAttribute('alt').includes("blackKing")) && (this.color === "white")) {
                                                needsBreak = true;
                                                isDangerous = true;
                                            } else if ((rightImagePiece.getAttribute('alt').includes("black") && this.color === "black" && (!rightImagePiece.getAttribute('alt').includes("blackKing")) ) || (rightImagePiece.getAttribute('alt').includes("white") && this.color === "white" && (!rightImagePiece.getAttribute('alt').includes("whiteKing")))) {
                                                needsBreak = true;
                                                isDangerous = false;
                                            } else if (((!rightImagePiece.getAttribute('alt').includes("whiteRook")) && (!rightImagePiece.getAttribute('alt').includes("whiteQueen")) && (rightImagePiece.getAttribute('alt').includes("white")) && (this.color === "black")) || (((!rightImagePiece.getAttribute('alt').includes("blackRook")) && (!rightImagePiece.getAttribute('alt').includes("blackQueen")) && (rightImagePiece.getAttribute('alt').includes("black"))) && (this.color === "white"))) {  
                                                needsBreak = true;
                                                isDangerous = false;
                                            }
                                        } 
                                        break;
                                    default:
                                        if (rightPiece.querySelector("img")) {
                                            let rightImagePiece = rightPiece.querySelector("img");
                                            if((rightImagePiece.getAttribute('alt').includes("whiteRook") || rightImagePiece.getAttribute('alt').includes("whiteQueen")) && (this.color === "black")) {
                                                needsBreak = true;
                                                isDangerous = true;
                                            } else if ((rightImagePiece.getAttribute('alt').includes("blackRook") || rightImagePiece.getAttribute('alt').includes("blackQueen")) && (this.color === "white")) {
                                                needsBreak = true;
                                                isDangerous = true;
                                            } else if ((rightImagePiece.getAttribute('alt').includes("black") && this.color === "black" && (!rightImagePiece.getAttribute('alt').includes("blackKing")) ) || (rightImagePiece.getAttribute('alt').includes("white") && this.color === "white" && (!rightImagePiece.getAttribute('alt').includes("whiteKing")))) {
                                                needsBreak = true;
                                                isDangerous = false;
                                            } else if (((!rightImagePiece.getAttribute('alt').includes("whiteRook")) && (!rightImagePiece.getAttribute('alt').includes("whiteQueen")) && (rightImagePiece.getAttribute('alt').includes("white")) && (this.color === "black")) || (((!rightImagePiece.getAttribute('alt').includes("blackRook")) && (!rightImagePiece.getAttribute('alt').includes("blackQueen")) && (rightImagePiece.getAttribute('alt').includes("black"))) && (this.color === "white"))) {  
                                                needsBreak = true;
                                                isDangerous = false;
                                            }
                                        }
                                        
                                        break;
                                } // end of switch case

                                if (needsBreak) {
                                    break;
                                }

                            } // end of inner for each statement
                        } // End of checking right side statement

                        // if isDangerous is true then go to the next outer for each element of loop so continue
                        if (isDangerous) {
                            continue;
                        }
                        
                        // start over
                        needsBreak = false;
                        isDangerous = false;

                        // check up rook and queen
                        if(eachMovement_xAxisValue == 1) {
                            
                        } else {
                            for(let i = eachMovement_xAxisValue - 1; i >= 1; i--) {
                                let upPiece = document.querySelector(`.cell_${i}_${eachMovement_yAxisValue}`)
                                
                                switch(i) {
                                    case eachMovement_xAxisValue - 1:
                                        if (upPiece.querySelector("img")) {
                                            let upImagePiece = upPiece.querySelector("img");
                                            if((upImagePiece.getAttribute('alt').includes("whiteRook") || upImagePiece.getAttribute('alt').includes("whiteQueen") || upImagePiece.getAttribute('alt').includes("whiteKing")) && (this.color === "black")) {
                                                needsBreak = true;
                                                isDangerous = true;
                                            } else if ((upImagePiece.getAttribute('alt').includes("blackRook") || upImagePiece.getAttribute('alt').includes("blackQueen") || upImagePiece.getAttribute('alt').includes("blackKing")) && (this.color === "white")) {
                                                needsBreak = true;
                                                isDangerous = true;
                                            } else if ((upImagePiece.getAttribute('alt').includes("black") && this.color === "black" && (!upImagePiece.getAttribute('alt').includes("blackKing")) ) || (upImagePiece.getAttribute('alt').includes("white") && this.color === "white" && (!upImagePiece.getAttribute('alt').includes("whiteKing")))) {
                                                needsBreak = true;
                                                isDangerous = false;
                                            } else if (((!upImagePiece.getAttribute('alt').includes("whiteRook")) && (!upImagePiece.getAttribute('alt').includes("whiteQueen")) && (upImagePiece.getAttribute('alt').includes("white")) && (this.color === "black")) || (((!upImagePiece.getAttribute('alt').includes("blackRook")) && (!upImagePiece.getAttribute('alt').includes("blackQueen")) && (upImagePiece.getAttribute('alt').includes("black"))) && (this.color === "white"))) {  
                                                needsBreak = true;
                                                isDangerous = false;
                                            }
                                        } 
                                        break;
                                    default:
                                        if (upPiece.querySelector("img")) {
                                            let upImagePiece = upPiece.querySelector("img");
                                            if((upImagePiece.getAttribute('alt').includes("whiteRook") || upImagePiece.getAttribute('alt').includes("whiteQueen")) && (this.color === "black")) {
                                                needsBreak = true;
                                                isDangerous = true;
                                            } else if ((upImagePiece.getAttribute('alt').includes("blackRook") || upImagePiece.getAttribute('alt').includes("blackQueen")) && (this.color === "white")) {
                                                needsBreak = true;
                                                isDangerous = true;
                                            } else if ((upImagePiece.getAttribute('alt').includes("black") && this.color === "black" && (!upImagePiece.getAttribute('alt').includes("blackKing")) ) || (upImagePiece.getAttribute('alt').includes("white") && this.color === "white" && (!upImagePiece.getAttribute('alt').includes("whiteKing")))) {
                                                needsBreak = true;
                                                isDangerous = false;
                                            } else if (((!upImagePiece.getAttribute('alt').includes("whiteRook")) && (!upImagePiece.getAttribute('alt').includes("whiteQueen")) && (upImagePiece.getAttribute('alt').includes("white")) && (this.color === "black")) || (((!upImagePiece.getAttribute('alt').includes("blackRook")) && (!upImagePiece.getAttribute('alt').includes("blackQueen")) && (upImagePiece.getAttribute('alt').includes("black"))) && (this.color === "white"))) {  
                                                needsBreak = true;
                                                isDangerous = false;
                                            }
                                        }
                                        
                                        break;
                                } // end of switch case

                                if (needsBreak) {
                                    break;
                                }

                            } // end of for each statement
                        } // End of checking up side statement

                        // if isDangerous is true then go to the next outer for each element of loop so continue
                        if (isDangerous) {
                            continue;
                        }
                        
                        // start over
                        needsBreak = false;
                        isDangerous = false;

                        // check down side statement queen and rook
                        if(eachMovement_xAxisValue == 8) {
                            
                        } else {
                            for(let i = eachMovement_xAxisValue + 1; i <= 8; i++) {
                                let downPiece = document.querySelector(`.cell_${i}_${eachMovement_yAxisValue}`)
                                
                                switch(i) {
                                    case eachMovement_xAxisValue + 1:
                                        if (downPiece.querySelector("img")) {
                                            let downImagePiece = downPiece.querySelector("img");
                                            if((downImagePiece.getAttribute('alt').includes("whiteRook") || downImagePiece.getAttribute('alt').includes("whiteQueen") || downImagePiece.getAttribute('alt').includes("whiteKing")) && (this.color === "black")) {
                                                needsBreak = true;
                                                isDangerous = true;
                                            } else if ((downImagePiece.getAttribute('alt').includes("blackRook") || downImagePiece.getAttribute('alt').includes("blackQueen") || downImagePiece.getAttribute('alt').includes("blackKing")) && (this.color === "white")) {
                                                needsBreak = true;
                                                isDangerous = true;
                                            } else if ((downImagePiece.getAttribute('alt').includes("black") && this.color === "black" && (!downImagePiece.getAttribute('alt').includes("blackKing")) ) || (downImagePiece.getAttribute('alt').includes("white") && this.color === "white" && (!downImagePiece.getAttribute('alt').includes("whiteKing")))) {
                                                needsBreak = true;
                                                isDangerous = false;
                                            } else if (((!downImagePiece.getAttribute('alt').includes("whiteRook")) && (!downImagePiece.getAttribute('alt').includes("whiteQueen")) && (downImagePiece.getAttribute('alt').includes("white")) && (this.color === "black")) || (((!downImagePiece.getAttribute('alt').includes("blackRook")) && (!downImagePiece.getAttribute('alt').includes("blackQueen")) && (downImagePiece.getAttribute('alt').includes("black"))) && (this.color === "white"))) {  
                                                needsBreak = true;
                                                isDangerous = false;
                                            }
                                        } 
                                        break;
                                    default:
                                        if (downPiece.querySelector("img")) {
                                            let downImagePiece = downPiece.querySelector("img");
                                            if((downImagePiece.getAttribute('alt').includes("whiteRook") || downImagePiece.getAttribute('alt').includes("whiteQueen")) && (this.color === "black")) {
                                                needsBreak = true;
                                                isDangerous = true;
                                            } else if ((downImagePiece.getAttribute('alt').includes("blackRook") || downImagePiece.getAttribute('alt').includes("blackQueen")) && (this.color === "white")) {
                                                needsBreak = true;
                                                isDangerous = true;
                                            } else if ((downImagePiece.getAttribute('alt').includes("black") && this.color === "black" && (!downImagePiece.getAttribute('alt').includes("blackKing")) ) || (downImagePiece.getAttribute('alt').includes("white") && this.color === "white" && (!downImagePiece.getAttribute('alt').includes("whiteKing")))) {
                                                needsBreak = true;
                                                isDangerous = false;
                                            } else if (((!downImagePiece.getAttribute('alt').includes("whiteRook")) && (!downImagePiece.getAttribute('alt').includes("whiteQueen")) && (downImagePiece.getAttribute('alt').includes("white")) && (this.color === "black")) || (((!downImagePiece.getAttribute('alt').includes("blackRook")) && (!downImagePiece.getAttribute('alt').includes("blackQueen")) && (downImagePiece.getAttribute('alt').includes("black"))) && (this.color === "white"))) {  
                                                needsBreak = true;
                                                isDangerous = false;
                                            }
                                        }
                                        
                                        break;
                                } // end of switch case

                                if (needsBreak) {
                                    break;
                                }
                            } // end of for each statement
                        } // End of checking down side statement

                        // if isDangerous is true then go to the next outer for each element of loop so continue
                        if (isDangerous) {
                            continue;
                        }
                        
                        // start over
                        needsBreak = false;
                        isDangerous = false;

                        // Checking diagonally left down
                        if(eachMovement_yAxisValue == 1 || eachMovement_xAxisValue == 8) {
                        
                        } else {
                            for(let i = 1; i <= 8; i++) {
                                if (eachMovement_xAxisValue+i > 8 || eachMovement_yAxisValue-i < 1) {
                                    break;
                                }
                                let leftDownPiece = document.querySelector(`.cell_${eachMovement_xAxisValue+i}_${eachMovement_yAxisValue-i}`)
                                
                                switch(i) {
                                    case 1:
                                        if (leftDownPiece.querySelector("img")) {
                                            let leftDownImagePiece = leftDownPiece.querySelector("img");
                                            if((leftDownImagePiece.getAttribute('alt').includes("whiteBishop") || leftDownImagePiece.getAttribute('alt').includes("whiteQueen") || leftDownImagePiece.getAttribute('alt').includes("whiteKing")) && (this.color === "black")) {
                                                needsBreak = true;
                                                isDangerous = true;
                                            } else if ((leftDownImagePiece.getAttribute('alt').includes("blackBishop") || leftDownImagePiece.getAttribute('alt').includes("blackQueen") || leftDownImagePiece.getAttribute('alt').includes("blackKing")) && (this.color === "white")) {
                                                needsBreak = true;
                                                isDangerous = true;
                                            } else if (((leftDownImagePiece.getAttribute('alt').includes("blackPawn") && this.color === "white") && (!this.blackUp)) || ((leftDownImagePiece.getAttribute('alt').includes("whitePawn") && this.color === "black") && (this.blackUp))) {
                                                needsBreak = true;
                                                isDangerous = true;
                                            } else if ((leftDownImagePiece.getAttribute('alt').includes("black") && this.color === "black" && (!leftDownImagePiece.getAttribute('alt').includes("blackKing")) ) || (leftDownImagePiece.getAttribute('alt').includes("white") && this.color === "white" && (!leftDownImagePiece.getAttribute('alt').includes("whiteKing")))) {
                                                needsBreak = true;
                                                isDangerous = false;
                                            } else if (((!leftDownImagePiece.getAttribute('alt').includes("whiteBishop")) && (!leftDownImagePiece.getAttribute('alt').includes("whiteQueen")) && (leftDownImagePiece.getAttribute('alt').includes("white")) && (this.color === "black")) || (((!leftDownImagePiece.getAttribute('alt').includes("blackBishop")) && (!leftDownImagePiece.getAttribute('alt').includes("blackQueen")) && (leftDownImagePiece.getAttribute('alt').includes("black"))) && (this.color === "white"))) {  
                                                needsBreak = true;
                                                isDangerous = false;
                                            }

                                        } 
                                        break;
                                    default:
                                        if (leftDownPiece.querySelector("img")) {
                                            let leftDownImagePiece = leftDownPiece.querySelector("img");
                                            if((leftDownImagePiece.getAttribute('alt').includes("whiteBishop") || leftDownImagePiece.getAttribute('alt').includes("whiteQueen")) && (this.color === "black")) {
                                                needsBreak = true;
                                                isDangerous = true;
                                            } else if ((leftDownImagePiece.getAttribute('alt').includes("blackBishop") || leftDownImagePiece.getAttribute('alt').includes("blackQueen")) && (this.color === "white")) {
                                                needsBreak = true;
                                                isDangerous = true;
                                            } else if ((leftDownImagePiece.getAttribute('alt').includes("black") && this.color === "black" && (!leftDownImagePiece.getAttribute('alt').includes("blackKing")) ) || (leftDownImagePiece.getAttribute('alt').includes("white") && this.color === "white" && (!leftDownImagePiece.getAttribute('alt').includes("whiteKing")))) {
                                                needsBreak = true;
                                                isDangerous = false;
                                            } else if (((!leftDownImagePiece.getAttribute('alt').includes("whiteBishop")) && (!leftDownImagePiece.getAttribute('alt').includes("whiteQueen")) && (leftDownImagePiece.getAttribute('alt').includes("white")) && (this.color === "black")) || (((!leftDownImagePiece.getAttribute('alt').includes("blackBishop")) && (!leftDownImagePiece.getAttribute('alt').includes("blackQueen")) && (leftDownImagePiece.getAttribute('alt').includes("black"))) && (this.color === "white"))) {  
                                                needsBreak = true;
                                                isDangerous = false;
                                            }
                                        }
                                        break;
                                } // end of switch case
                                if (needsBreak) {
                                    break;
                                }    
                            } // diagonal left down for each statement
                        } // diagonal left down finished

                        if (isDangerous) {
                            continue;
                        }
                        
                        // start over
                        needsBreak = false;
                        isDangerous = false;

                        // checking diagonally right down
                        if(eachMovement_yAxisValue == 8 || eachMovement_xAxisValue == 8) {
                            
                        } else {
                            for(let i = 1; i <= 8; i++) {
                                if (eachMovement_xAxisValue+i > 8 || eachMovement_yAxisValue+i > 8) {
                                    break;
                                }

                                let rightDownPiece = document.querySelector(`.cell_${eachMovement_xAxisValue+i}_${eachMovement_yAxisValue+i}`)
                                
                                switch(i) {
                                    case 1:
                                        if (rightDownPiece.querySelector("img")) {
                                            let rightDownImagePiece = rightDownPiece.querySelector("img");
                                            if((rightDownImagePiece.getAttribute('alt').includes("whiteBishop") || rightDownImagePiece.getAttribute('alt').includes("whiteQueen") || rightDownImagePiece.getAttribute('alt').includes("whiteKing")) && (this.color === "black")) {
                                                needsBreak = true;
                                                isDangerous = true;
                                            } else if ((rightDownImagePiece.getAttribute('alt').includes("blackBishop") || rightDownImagePiece.getAttribute('alt').includes("blackQueen") || rightDownImagePiece.getAttribute('alt').includes("blackKing")) && (this.color === "white")) {
                                                needsBreak = true;
                                                isDangerous = true;
                                            } else if (((rightDownImagePiece.getAttribute('alt').includes("blackPawn") && this.color === "white") && (!this.blackUp)) || ((rightDownImagePiece.getAttribute('alt').includes("whitePawn") && this.color === "black") && (this.blackUp))) {
                                                needsBreak = true;
                                                isDangerous = true;
                                            } else if ((rightDownImagePiece.getAttribute('alt').includes("black") && this.color === "black" && (!rightDownImagePiece.getAttribute('alt').includes("blackKing")) ) || (rightDownImagePiece.getAttribute('alt').includes("white") && this.color === "white" && (!rightDownImagePiece.getAttribute('alt').includes("whiteKing")))) {
                                                needsBreak = true;
                                                isDangerous = false;
                                            } else if (((!rightDownImagePiece.getAttribute('alt').includes("whiteBishop")) && (!rightDownImagePiece.getAttribute('alt').includes("whiteQueen")) && (rightDownImagePiece.getAttribute('alt').includes("white")) && (this.color === "black")) || (((!rightDownImagePiece.getAttribute('alt').includes("blackBishop")) && (!rightDownImagePiece.getAttribute('alt').includes("blackQueen")) && (rightDownImagePiece.getAttribute('alt').includes("black"))) && (this.color === "white"))) {  
                                                needsBreak = true;
                                                isDangerous = false;
                                            }
                                        } 
                                        break;
                                    default:
                                        if (rightDownPiece.querySelector("img")) {
                                            let rightDownImagePiece = rightDownPiece.querySelector("img");
                                            if((rightDownImagePiece.getAttribute('alt').includes("whiteBishop") || rightDownImagePiece.getAttribute('alt').includes("whiteQueen")) && (this.color === "black")) {
                                                needsBreak = true;
                                                isDangerous = true;
                                            } else if ((rightDownImagePiece.getAttribute('alt').includes("blackBishop") || rightDownImagePiece.getAttribute('alt').includes("blackQueen")) && (this.color === "white")) {
                                                needsBreak = true;
                                                isDangerous = true;
                                            } else if ((rightDownImagePiece.getAttribute('alt').includes("black") && this.color === "black" && (!rightDownImagePiece.getAttribute('alt').includes("blackKing")) ) || (rightDownImagePiece.getAttribute('alt').includes("white") && this.color === "white" && (!rightDownImagePiece.getAttribute('alt').includes("whiteKing")))) {
                                                needsBreak = true;
                                                isDangerous = false;
                                            } else if (((!rightDownImagePiece.getAttribute('alt').includes("whiteBishop")) && (!rightDownImagePiece.getAttribute('alt').includes("whiteQueen")) && (rightDownImagePiece.getAttribute('alt').includes("white")) && (this.color === "black")) || (((!rightDownImagePiece.getAttribute('alt').includes("blackBishop")) && (!rightDownImagePiece.getAttribute('alt').includes("blackQueen")) && (rightDownImagePiece.getAttribute('alt').includes("black"))) && (this.color === "white"))) {  
                                                needsBreak = true;
                                                isDangerous = false;
                                            }
                                        }
                                        
                                        break;
                                } // end of switch case

                                if (needsBreak) {
                                    break;
                                }
                            } // end of for each statement
                        } // End of checking diagonally right down side statement

                        if (isDangerous) {
                            continue;
                        }
                        
                        // start over
                        needsBreak = false;
                        isDangerous = false;


                        // diagonal up left checking
                        if(eachMovement_yAxisValue == 1 || eachMovement_xAxisValue == 1) {
                            
                        } else {
                            for(let i = 1; i <= 8; i++) {
                                if (eachMovement_xAxisValue-i < 1 || eachMovement_yAxisValue-i < 1) {
                                    break;
                                }

                                let upLeftPiece = document.querySelector(`.cell_${eachMovement_xAxisValue-i}_${eachMovement_yAxisValue-i}`)
                                
                                switch(i) {
                                    case 1:
                                        if (upLeftPiece.querySelector("img")) {
                                            let upLeftImagePiece = upLeftPiece.querySelector("img");
                                            if((upLeftImagePiece.getAttribute('alt').includes("whiteBishop") || upLeftImagePiece.getAttribute('alt').includes("whiteQueen") || upLeftImagePiece.getAttribute('alt').includes("whiteKing")) && (this.color === "black")) {
                                                needsBreak = true;
                                                isDangerous = true;
                                            } else if ((upLeftImagePiece.getAttribute('alt').includes("blackBishop") || upLeftImagePiece.getAttribute('alt').includes("blackQueen") || upLeftImagePiece.getAttribute('alt').includes("blackKing")) && (this.color === "white")) {
                                                needsBreak = true;
                                                isDangerous = true;
                                            } else if (((upLeftImagePiece.getAttribute('alt').includes("blackPawn") && this.color === "white") && (this.blackUp)) || ((upLeftImagePiece.getAttribute('alt').includes("whitePawn") && this.color === "black") && (!this.blackUp))) {
                                                needsBreak = true;
                                                isDangerous = true;
                                            } else if ((upLeftImagePiece.getAttribute('alt').includes("black") && this.color === "black" && (!upLeftImagePiece.getAttribute('alt').includes("blackKing")) ) || (upLeftImagePiece.getAttribute('alt').includes("white") && this.color === "white" && (!upLeftImagePiece.getAttribute('alt').includes("whiteKing")))) {
                                                needsBreak = true;
                                                isDangerous = false;
                                            } else if (((!upLeftImagePiece.getAttribute('alt').includes("whiteBishop")) && (!upLeftImagePiece.getAttribute('alt').includes("whiteQueen")) && (upLeftImagePiece.getAttribute('alt').includes("white")) && (this.color === "black")) || (((!upLeftImagePiece.getAttribute('alt').includes("blackBishop")) && (!upLeftImagePiece.getAttribute('alt').includes("blackQueen")) && (upLeftImagePiece.getAttribute('alt').includes("black"))) && (this.color === "white"))) {  
                                                needsBreak = true;
                                                isDangerous = false;
                                            }
                                        } 
                                        break;
                                    default:
                                        if (upLeftPiece.querySelector("img")) {
                                            let upLeftImagePiece = upLeftPiece.querySelector("img");
                                            if((upLeftImagePiece.getAttribute('alt').includes("whiteBishop") || upLeftImagePiece.getAttribute('alt').includes("whiteQueen")) && (this.color === "black")) {
                                                needsBreak = true;
                                                isDangerous = true;
                                            } else if ((upLeftImagePiece.getAttribute('alt').includes("blackBishop") || upLeftImagePiece.getAttribute('alt').includes("blackQueen")) && (this.color === "white")) {
                                                needsBreak = true;
                                                isDangerous = true;
                                            } else if ((upLeftImagePiece.getAttribute('alt').includes("black") && this.color === "black" && (!upLeftImagePiece.getAttribute('alt').includes("blackKing")) ) || (upLeftImagePiece.getAttribute('alt').includes("white") && this.color === "white" && (!upLeftImagePiece.getAttribute('alt').includes("whiteKing")))) {
                                                needsBreak = true;
                                                isDangerous = false;
                                            } else if (((!upLeftImagePiece.getAttribute('alt').includes("whiteBishop")) && (!upLeftImagePiece.getAttribute('alt').includes("whiteQueen")) && (upLeftImagePiece.getAttribute('alt').includes("white")) && (this.color === "black")) || (((!upLeftImagePiece.getAttribute('alt').includes("blackBishop")) && (!upLeftImagePiece.getAttribute('alt').includes("blackQueen")) && (upLeftImagePiece.getAttribute('alt').includes("black"))) && (this.color === "white"))) {  
                                                needsBreak = true;
                                                isDangerous = false;
                                            }
                                        }
                                        
                                        break;
                                } // end of switch case

                                if (needsBreak) {
                                    break;
                                }

                            } // end of for each statement
                        } // End of checking diagonally up left side statement

                        if (isDangerous) {
                            continue;
                        }
                        
                        // start over
                        needsBreak = false;
                        isDangerous = false;

                        // check diagonally up right
                        if(eachMovement_yAxisValue == 8 || eachMovement_xAxisValue == 1) {
                            
                        } else {
                            for(let i = 1; i <= 8; i++) {
                                if (eachMovement_xAxisValue-i < 1 || eachMovement_yAxisValue+i > 8) {
                                    break;
                                }

                                let upRightPiece = document.querySelector(`.cell_${eachMovement_xAxisValue-i}_${eachMovement_yAxisValue+i}`)
                                
                                switch(i) {
                                    case 1:
                                        if (upRightPiece.querySelector("img")) {
                                            let upRightImagePiece = upRightPiece.querySelector("img");
                                            if((upRightImagePiece.getAttribute('alt').includes("whiteBishop") || upRightImagePiece.getAttribute('alt').includes("whiteQueen") || upRightImagePiece.getAttribute('alt').includes("whiteKing")) && (this.color === "black")) {
                                                needsBreak = true;
                                                isDangerous = true;
                                            } else if ((upRightImagePiece.getAttribute('alt').includes("blackBishop") || upRightImagePiece.getAttribute('alt').includes("blackQueen") || upRightImagePiece.getAttribute('alt').includes("blackKing")) && (this.color === "white")) {
                                                needsBreak = true;
                                                isDangerous = true;
                                            } else if (((upRightImagePiece.getAttribute('alt').includes("blackPawn") && this.color === "white") && (this.blackUp)) || ((upRightImagePiece.getAttribute('alt').includes("whitePawn") && this.color === "black") && (!this.blackUp))) {
                                                needsBreak = true;
                                                isDangerous = true;
                                            } else if ((upRightImagePiece.getAttribute('alt').includes("black") && this.color === "black" && (!upRightImagePiece.getAttribute('alt').includes("blackKing")) ) || (upRightImagePiece.getAttribute('alt').includes("white") && this.color === "white" && (!upRightImagePiece.getAttribute('alt').includes("whiteKing")))) {
                                                needsBreak = true;
                                                isDangerous = false;
                                            } else if (((!upRightImagePiece.getAttribute('alt').includes("whiteBishop")) && (!upRightImagePiece.getAttribute('alt').includes("whiteQueen")) && (upRightImagePiece.getAttribute('alt').includes("white")) && (this.color === "black")) || (((!upRightImagePiece.getAttribute('alt').includes("blackBishop")) && (!upRightImagePiece.getAttribute('alt').includes("blackQueen")) && (upRightImagePiece.getAttribute('alt').includes("black"))) && (this.color === "white"))) {  
                                                needsBreak = true;
                                                isDangerous = false;
                                            }
                                        } 
                                        break;
                                    default:
                                        if (upRightPiece.querySelector("img")) {
                                            let upRightImagePiece = upRightPiece.querySelector("img");
                                            if((upRightImagePiece.getAttribute('alt').includes("whiteBishop") || upRightImagePiece.getAttribute('alt').includes("whiteQueen")) && (this.color === "black")) {
                                                needsBreak = true;
                                                isDangerous = true;
                                            } else if ((upRightImagePiece.getAttribute('alt').includes("blackBishop") || upRightImagePiece.getAttribute('alt').includes("blackQueen")) && (this.color === "white")) {
                                                needsBreak = true;
                                                isDangerous = true;
                                            } else if ((upRightImagePiece.getAttribute('alt').includes("black") && this.color === "black" && (!upRightImagePiece.getAttribute('alt').includes("blackKing")) ) || (upRightImagePiece.getAttribute('alt').includes("white") && this.color === "white" && (!upRightImagePiece.getAttribute('alt').includes("whiteKing")))) {
                                                needsBreak = true;
                                                isDangerous = false;
                                            } else if (((!upRightImagePiece.getAttribute('alt').includes("whiteBishop")) && (!upRightImagePiece.getAttribute('alt').includes("whiteQueen")) && (upRightImagePiece.getAttribute('alt').includes("white")) && (this.color === "black")) || (((!upRightImagePiece.getAttribute('alt').includes("blackBishop")) && (!upRightImagePiece.getAttribute('alt').includes("blackQueen")) && (upRightImagePiece.getAttribute('alt').includes("black"))) && (this.color === "white"))) {  
                                                needsBreak = true;
                                                isDangerous = false;
                                            }
                                        }
                                        
                                        break;
                                } // end of switch case

                                if (needsBreak) {
                                    break;
                                }
                            } // end of for each statement
                        } // End of checking diagonally up left side statement

                        if (isDangerous) {
                            continue;
                        }
                        
                        // start over
                        needsBreak = false;
                        isDangerous = false;

                        // Check left side if enemy Knight is there
                        if(eachMovement_xAxisValue-1 >= 1 && eachMovement_yAxisValue-2 >= 1 ){
                            let knightPiecePossibleStance = document.querySelector(`.cell_${eachMovement_xAxisValue-1}_${eachMovement_yAxisValue-2}`);
                            if (knightPiecePossibleStance.querySelector("img")) {
                                let imagePiece = knightPiecePossibleStance.querySelector("img");
                                if((imagePiece.getAttribute('alt').includes("whiteKnight")) && (this.color === "black")) {
                                    isDangerous = true;
                                } else if ((imagePiece.getAttribute('alt').includes("blackKnight")) && (this.color === "white")) {
                                    isDangerous = true;
                                } else if ((imagePiece.getAttribute('alt').includes("black") && this.color === "black") || (imagePiece.getAttribute('alt').includes("white") && this.color === "white")) {
                                    isDangerous = false;
                                }
                            }
                        }

                        if (isDangerous) {
                            continue;
                        }
                        
                        // start over
                        needsBreak = false;
                        isDangerous = false;

                        if(eachMovement_xAxisValue-2 >= 1 && eachMovement_yAxisValue-1 >= 1 ){
                            let knightPiecePossibleStance = document.querySelector(`.cell_${eachMovement_xAxisValue-2}_${eachMovement_yAxisValue-1}`);
                            if (knightPiecePossibleStance.querySelector("img")) {
                                let imagePiece = knightPiecePossibleStance.querySelector("img");
                                if((imagePiece.getAttribute('alt').includes("whiteKnight")) && (this.color === "black")) {
                                    isDangerous = true;
                                } else if ((imagePiece.getAttribute('alt').includes("blackKnight")) && (this.color === "white")) {
                                    isDangerous = true;
                                } else if ((imagePiece.getAttribute('alt').includes("black") && this.color === "black") || (imagePiece.getAttribute('alt').includes("white") && this.color === "white")) {
                                    isDangerous = false;
                                }
                            }
                        }

                        if (isDangerous) {
                            continue;
                        }
                        
                        // start over
                        needsBreak = false;
                        isDangerous = false;

                        if(eachMovement_xAxisValue+1 <= 8 && eachMovement_yAxisValue-2 >= 1 ){
                            let knightPiecePossibleStance = document.querySelector(`.cell_${eachMovement_xAxisValue+1}_${eachMovement_yAxisValue-2}`);
                            if (knightPiecePossibleStance.querySelector("img")) {
                                let imagePiece = knightPiecePossibleStance.querySelector("img");
                                if((imagePiece.getAttribute('alt').includes("whiteKnight")) && (this.color === "black")) {
                                    isDangerous = true;
                                } else if ((imagePiece.getAttribute('alt').includes("blackKnight")) && (this.color === "white")) {
                                    isDangerous = true;
                                } else if ((imagePiece.getAttribute('alt').includes("black") && this.color === "black") || (imagePiece.getAttribute('alt').includes("white") && this.color === "white")) {
                                    isDangerous = false;
                                }
                            }
                        }

                        if (isDangerous) {
                            continue;
                        }
                        
                        // start over
                        needsBreak = false;
                        isDangerous = false;

                        if(eachMovement_xAxisValue+2 <= 8 && eachMovement_yAxisValue-1 >= 1 ){
                            let knightPiecePossibleStance = document.querySelector(`.cell_${eachMovement_xAxisValue+2}_${eachMovement_yAxisValue-1}`);
                            if (knightPiecePossibleStance.querySelector("img")) {
                                let imagePiece = knightPiecePossibleStance.querySelector("img");
                                if((imagePiece.getAttribute('alt').includes("whiteKnight")) && (this.color === "black")) {
                                    isDangerous = true;
                                } else if ((imagePiece.getAttribute('alt').includes("blackKnight")) && (this.color === "white")) {
                                    isDangerous = true;
                                } else if ((imagePiece.getAttribute('alt').includes("black") && this.color === "black") || (imagePiece.getAttribute('alt').includes("white") && this.color === "white")) {
                                    isDangerous = false;
                                }
                            }
                        }

                        if (isDangerous) {
                            continue;
                        }
                        
                        // start over
                        needsBreak = false;
                        isDangerous = false;

                        // check right if knight is there
                        if(eachMovement_xAxisValue-1 >= 1 && eachMovement_yAxisValue+2 <= 8 ){
                            let knightPiecePossibleStance = document.querySelector(`.cell_${eachMovement_xAxisValue-1}_${eachMovement_yAxisValue+2}`);
                            if (knightPiecePossibleStance.querySelector("img")) {
                                let imagePiece = knightPiecePossibleStance.querySelector("img");
                                if((imagePiece.getAttribute('alt').includes("whiteKnight")) && (this.color === "black")) {
                                    isDangerous = true;
                                } else if ((imagePiece.getAttribute('alt').includes("blackKnight")) && (this.color === "white")) {
                                    isDangerous = true;
                                } else if ((imagePiece.getAttribute('alt').includes("black") && this.color === "black") || (imagePiece.getAttribute('alt').includes("white") && this.color === "white")) {
                                    isDangerous = false;
                                }
                            }
                        }

                        if (isDangerous) {
                            continue;
                        }
                        
                        // start over
                        needsBreak = false;
                        isDangerous = false;


                        if(eachMovement_xAxisValue-2 >= 1 && eachMovement_yAxisValue+1 <= 8 ){
                            let knightPiecePossibleStance = document.querySelector(`.cell_${eachMovement_xAxisValue-2}_${eachMovement_yAxisValue+1}`);
                            if (knightPiecePossibleStance.querySelector("img")) {
                                let imagePiece = knightPiecePossibleStance.querySelector("img");
                                if((imagePiece.getAttribute('alt').includes("whiteKnight")) && (this.color === "black")) {
                                    isDangerous = true;
                                } else if ((imagePiece.getAttribute('alt').includes("blackKnight")) && (this.color === "white")) {
                                    isDangerous = true;
                                } else if ((imagePiece.getAttribute('alt').includes("black") && this.color === "black") || (imagePiece.getAttribute('alt').includes("white") && this.color === "white")) {
                                    isDangerous = false;
                                }
                            }
                        }

                        if (isDangerous) {
                            continue;
                        }
                        
                        // start over
                        needsBreak = false;
                        isDangerous = false;

                        if(eachMovement_xAxisValue+1 <= 8 && eachMovement_yAxisValue+2 <= 8 ){
                            let knightPiecePossibleStance = document.querySelector(`.cell_${eachMovement_xAxisValue+1}_${eachMovement_yAxisValue+2}`);
                            if (knightPiecePossibleStance.querySelector("img")) {
                                let imagePiece = knightPiecePossibleStance.querySelector("img");
                                if((imagePiece.getAttribute('alt').includes("whiteKnight")) && (this.color === "black")) {
                                    isDangerous = false;
                                } else if ((imagePiece.getAttribute('alt').includes("blackKnight")) && (this.color === "white")) {
                                    isDangerous = false;
                                } else if ((imagePiece.getAttribute('alt').includes("black") && this.color === "black") || (imagePiece.getAttribute('alt').includes("white") && this.color === "white")) {
                                    isDangerous = false;
                                }
                            }
                        }

                        if (isDangerous) {
                            continue;
                        }
                        
                        // start over
                        needsBreak = false;
                        isDangerous = false;

                        if(eachMovement_xAxisValue+2 <= 8 && eachMovement_yAxisValue+1 <= 8 ){
                            let knightPiecePossibleStance = document.querySelector(`.cell_${eachMovement_xAxisValue+2}_${eachMovement_yAxisValue+1}`);
                            if (knightPiecePossibleStance.querySelector("img")) {
                                let imagePiece = knightPiecePossibleStance.querySelector("img");
                                if((imagePiece.getAttribute('alt').includes("whiteKnight")) && (this.color === "black")) {
                                    isDangerous = true;
                                } else if ((imagePiece.getAttribute('alt').includes("blackKnight")) && (this.color === "white")) {
                                    isDangerous = true;
                                } else if ((imagePiece.getAttribute('alt').includes("black") && this.color === "black") || (imagePiece.getAttribute('alt').includes("white") && this.color === "white")) {
                                    isDangerous = false;
                                }
                            }
                        }
                        
                        // last element
                        if (isDangerous) {
                            continue;
                        } else {
                            defendingMovements.push(`.cell_${eachMovement_xAxisValue}_${eachMovement_yAxisValue}`);
                        }
                    

                    } // End of outer for each statement for king movements
                    /////////////////////// check king's movements end

                    if (defendingMovements.length > 0) {
                        kingIsInDanger = false;
                        return kingIsInDanger;
                    } else {
                        kingIsInDanger = true;
                        return kingIsInDanger;
                    }

                } // IsInDanger function finished

                castlingVerification(xAxisValue, yAxisValue) {
                    let kingPossibleMovement = [];
                    let defendingMovements = [];
                    let kingIsInDanger = false;

                    kingPossibleMovement.push(`cell_${xAxisValue}_${yAxisValue}`);

                    /////////////////////// check king's movements
                    // Each king Movement
                    for(let i = 0; i < kingPossibleMovement.length; i++){
                        let eachMovement_xAxisValue = xAxisValue;
                        let eachMovement_yAxisValue = yAxisValue;
                        let isDangerous = false;
                        let needsBreak = false;

                        // check left start rook queen
                        if(eachMovement_yAxisValue == 1) {
                            
                        } else {
                            for(let i = eachMovement_yAxisValue - 1; i >= 1; i--) {
                                // if y axis value is one, then don't check left
                                let leftPiece = document.querySelector(`.cell_${eachMovement_xAxisValue}_${i}`)
                                
                                switch(i) {
                                    case eachMovement_yAxisValue - 1:
                                        if (leftPiece.querySelector("img")) {
                                            let leftImagePiece = leftPiece.querySelector("img");
                                            if((leftImagePiece.getAttribute('alt').includes("whiteRook") || leftImagePiece.getAttribute('alt').includes("whiteQueen") || leftImagePiece.getAttribute('alt').includes("whiteKing")) && (this.color === "black")) {  
                                                needsBreak = true;
                                                isDangerous = true;
                                            } else if ((leftImagePiece.getAttribute('alt').includes("blackRook") || leftImagePiece.getAttribute('alt').includes("blackQueen") || leftImagePiece.getAttribute('alt').includes("blackKing")) && (this.color === "white")) {
                                                needsBreak = true;
                                                isDangerous = true;
                                            } else if ((leftImagePiece.getAttribute('alt').includes("black") && this.color === "black" && (!leftImagePiece.getAttribute('alt').includes("blackKing")) ) || (leftImagePiece.getAttribute('alt').includes("white") && this.color === "white" && (!leftImagePiece.getAttribute('alt').includes("whiteKing")))) {
                                                needsBreak = true;
                                                isDangerous = false;
                                            } else if (((!leftImagePiece.getAttribute('alt').includes("whiteRook")) && (!leftImagePiece.getAttribute('alt').includes("whiteQueen")) && (leftImagePiece.getAttribute('alt').includes("white")) && (this.color === "black")) || (((!leftImagePiece.getAttribute('alt').includes("blackRook")) && (!leftImagePiece.getAttribute('alt').includes("blackQueen")) && (leftImagePiece.getAttribute('alt').includes("black"))) && (this.color === "white"))) {  
                                                needsBreak = true;
                                                isDangerous = false;
                                            }
                                        } 
                                        break;
                                    default:
                                        if (leftPiece.querySelector("img")) {
                                            let leftImagePiece = leftPiece.querySelector("img");
                                            if((leftImagePiece.getAttribute('alt').includes("whiteRook") || leftImagePiece.getAttribute('alt').includes("whiteQueen")) && (this.color === "black")) {
                                                needsBreak = true;
                                                isDangerous = true;
                                            } else if ((leftImagePiece.getAttribute('alt').includes("blackRook") || leftImagePiece.getAttribute('alt').includes("blackQueen")) && (this.color === "white")) {
                                                needsBreak = true;
                                                isDangerous = true;
                                            } else if ((leftImagePiece.getAttribute('alt').includes("black") && this.color === "black" && (!leftImagePiece.getAttribute('alt').includes("blackKing")) ) || (leftImagePiece.getAttribute('alt').includes("white") && this.color === "white" && (!leftImagePiece.getAttribute('alt').includes("whiteKing")))) {
                                                needsBreak = true;
                                                isDangerous = false;
                                            } else if (((!leftImagePiece.getAttribute('alt').includes("whiteRook")) && (!leftImagePiece.getAttribute('alt').includes("whiteQueen")) && (leftImagePiece.getAttribute('alt').includes("white")) && (this.color === "black")) || (((!leftImagePiece.getAttribute('alt').includes("blackRook")) && (!leftImagePiece.getAttribute('alt').includes("blackQueen")) && (leftImagePiece.getAttribute('alt').includes("black"))) && (this.color === "white"))) {  
                                                needsBreak = true;
                                                isDangerous = false;
                                            }
                                        }
                                        
                                        break;
                                } // end of switch case

                                if (needsBreak) {
                                    break;
                                }
                                    
                            } // end of inner for each statement left side
                        } // check left finished

                        // if isDangerous is true then go to the next outer for each element of loop so continue
                        if (isDangerous) {
                            continue;
                        }
                        
                        // start over
                        needsBreak = false;
                        isDangerous = false;

                        // check right rook and queen
                        if(eachMovement_yAxisValue == 8) {
                            
                        } else {
                            for(let i = eachMovement_yAxisValue + 1; i <= 8; i++) {
                                let rightPiece = document.querySelector(`.cell_${eachMovement_xAxisValue}_${i}`)
                                
                                switch(i) {
                                    case eachMovement_yAxisValue + 1:
                                        if (rightPiece.querySelector("img")) {
                                            let rightImagePiece = rightPiece.querySelector("img");
                                            if((rightImagePiece.getAttribute('alt').includes("whiteRook") || rightImagePiece.getAttribute('alt').includes("whiteQueen") || rightImagePiece.getAttribute('alt').includes("whiteKing")) && (this.color === "black")) {
                                                needsBreak = true;
                                                isDangerous = true;
                                            } else if ((rightImagePiece.getAttribute('alt').includes("blackRook") || rightImagePiece.getAttribute('alt').includes("blackQueen") || rightImagePiece.getAttribute('alt').includes("blackKing")) && (this.color === "white")) {
                                                needsBreak = true;
                                                isDangerous = true;
                                            } else if ((rightImagePiece.getAttribute('alt').includes("black") && this.color === "black" && (!rightImagePiece.getAttribute('alt').includes("blackKing")) ) || (rightImagePiece.getAttribute('alt').includes("white") && this.color === "white" && (!rightImagePiece.getAttribute('alt').includes("whiteKing")))) {
                                                needsBreak = true;
                                                isDangerous = false;
                                            } else if (((!rightImagePiece.getAttribute('alt').includes("whiteRook")) && (!rightImagePiece.getAttribute('alt').includes("whiteQueen")) && (rightImagePiece.getAttribute('alt').includes("white")) && (this.color === "black")) || (((!rightImagePiece.getAttribute('alt').includes("blackRook")) && (!rightImagePiece.getAttribute('alt').includes("blackQueen")) && (rightImagePiece.getAttribute('alt').includes("black"))) && (this.color === "white"))) {  
                                                needsBreak = true;
                                                isDangerous = false;
                                            }
                                        } 
                                        break;
                                    default:
                                        if (rightPiece.querySelector("img")) {
                                            let rightImagePiece = rightPiece.querySelector("img");
                                            if((rightImagePiece.getAttribute('alt').includes("whiteRook") || rightImagePiece.getAttribute('alt').includes("whiteQueen")) && (this.color === "black")) {
                                                needsBreak = true;
                                                isDangerous = true;
                                            } else if ((rightImagePiece.getAttribute('alt').includes("blackRook") || rightImagePiece.getAttribute('alt').includes("blackQueen")) && (this.color === "white")) {
                                                needsBreak = true;
                                                isDangerous = true;
                                            } else if ((rightImagePiece.getAttribute('alt').includes("black") && this.color === "black" && (!rightImagePiece.getAttribute('alt').includes("blackKing")) ) || (rightImagePiece.getAttribute('alt').includes("white") && this.color === "white" && (!rightImagePiece.getAttribute('alt').includes("whiteKing")))) {
                                                needsBreak = true;
                                                isDangerous = false;
                                            } else if (((!rightImagePiece.getAttribute('alt').includes("whiteRook")) && (!rightImagePiece.getAttribute('alt').includes("whiteQueen")) && (rightImagePiece.getAttribute('alt').includes("white")) && (this.color === "black")) || (((!rightImagePiece.getAttribute('alt').includes("blackRook")) && (!rightImagePiece.getAttribute('alt').includes("blackQueen")) && (rightImagePiece.getAttribute('alt').includes("black"))) && (this.color === "white"))) {  
                                                needsBreak = true;
                                                isDangerous = false;
                                            }
                                        }
                                        
                                        break;
                                } // end of switch case

                                if (needsBreak) {
                                    break;
                                }

                            } // end of inner for each statement
                        } // End of checking right side statement

                        // if isDangerous is true then go to the next outer for each element of loop so continue
                        if (isDangerous) {
                            continue;
                        }
                        
                        // start over
                        needsBreak = false;
                        isDangerous = false;

                        // check up rook and queen
                        if(eachMovement_xAxisValue == 1) {
                            
                        } else {
                            for(let i = eachMovement_xAxisValue - 1; i >= 1; i--) {
                                let upPiece = document.querySelector(`.cell_${i}_${eachMovement_yAxisValue}`)
                                
                                switch(i) {
                                    case eachMovement_xAxisValue - 1:
                                        if (upPiece.querySelector("img")) {
                                            let upImagePiece = upPiece.querySelector("img");
                                            if((upImagePiece.getAttribute('alt').includes("whiteRook") || upImagePiece.getAttribute('alt').includes("whiteQueen") || upImagePiece.getAttribute('alt').includes("whiteKing")) && (this.color === "black")) {
                                                needsBreak = true;
                                                isDangerous = true;
                                            } else if ((upImagePiece.getAttribute('alt').includes("blackRook") || upImagePiece.getAttribute('alt').includes("blackQueen") || upImagePiece.getAttribute('alt').includes("blackKing")) && (this.color === "white")) {
                                                needsBreak = true;
                                                isDangerous = true;
                                            } else if ((upImagePiece.getAttribute('alt').includes("black") && this.color === "black" && (!upImagePiece.getAttribute('alt').includes("blackKing")) ) || (upImagePiece.getAttribute('alt').includes("white") && this.color === "white" && (!upImagePiece.getAttribute('alt').includes("whiteKing")))) {
                                                needsBreak = true;
                                                isDangerous = false;
                                            } else if (((!upImagePiece.getAttribute('alt').includes("whiteRook")) && (!upImagePiece.getAttribute('alt').includes("whiteQueen")) && (upImagePiece.getAttribute('alt').includes("white")) && (this.color === "black")) || (((!upImagePiece.getAttribute('alt').includes("blackRook")) && (!upImagePiece.getAttribute('alt').includes("blackQueen")) && (upImagePiece.getAttribute('alt').includes("black"))) && (this.color === "white"))) {  
                                                needsBreak = true;
                                                isDangerous = false;
                                            }
                                        } 
                                        break;
                                    default:
                                        if (upPiece.querySelector("img")) {
                                            let upImagePiece = upPiece.querySelector("img");
                                            if((upImagePiece.getAttribute('alt').includes("whiteRook") || upImagePiece.getAttribute('alt').includes("whiteQueen")) && (this.color === "black")) {
                                                needsBreak = true;
                                                isDangerous = true;
                                            } else if ((upImagePiece.getAttribute('alt').includes("blackRook") || upImagePiece.getAttribute('alt').includes("blackQueen")) && (this.color === "white")) {
                                                needsBreak = true;
                                                isDangerous = true;
                                            } else if ((upImagePiece.getAttribute('alt').includes("black") && this.color === "black" && (!upImagePiece.getAttribute('alt').includes("blackKing")) ) || (upImagePiece.getAttribute('alt').includes("white") && this.color === "white" && (!upImagePiece.getAttribute('alt').includes("whiteKing")))) {
                                                needsBreak = true;
                                                isDangerous = false;
                                            } else if (((!upImagePiece.getAttribute('alt').includes("whiteRook")) && (!upImagePiece.getAttribute('alt').includes("whiteQueen")) && (upImagePiece.getAttribute('alt').includes("white")) && (this.color === "black")) || (((!upImagePiece.getAttribute('alt').includes("blackRook")) && (!upImagePiece.getAttribute('alt').includes("blackQueen")) && (upImagePiece.getAttribute('alt').includes("black"))) && (this.color === "white"))) {  
                                                needsBreak = true;
                                                isDangerous = false;
                                            }
                                        }
                                        
                                        break;
                                } // end of switch case

                                if (needsBreak) {
                                    break;
                                }

                            } // end of for each statement
                        } // End of checking up side statement

                        // if isDangerous is true then go to the next outer for each element of loop so continue
                        if (isDangerous) {
                            continue;
                        }
                        
                        // start over
                        needsBreak = false;
                        isDangerous = false;

                        // check down side statement queen and rook
                        if(eachMovement_xAxisValue == 8) {
                            
                        } else {
                            for(let i = eachMovement_xAxisValue + 1; i <= 8; i++) {
                                let downPiece = document.querySelector(`.cell_${i}_${eachMovement_yAxisValue}`)
                                
                                switch(i) {
                                    case eachMovement_xAxisValue + 1:
                                        if (downPiece.querySelector("img")) {
                                            let downImagePiece = downPiece.querySelector("img");
                                            if((downImagePiece.getAttribute('alt').includes("whiteRook") || downImagePiece.getAttribute('alt').includes("whiteQueen") || downImagePiece.getAttribute('alt').includes("whiteKing")) && (this.color === "black")) {
                                                needsBreak = true;
                                                isDangerous = true;
                                            } else if ((downImagePiece.getAttribute('alt').includes("blackRook") || downImagePiece.getAttribute('alt').includes("blackQueen") || downImagePiece.getAttribute('alt').includes("blackKing")) && (this.color === "white")) {
                                                needsBreak = true;
                                                isDangerous = true;
                                            } else if ((downImagePiece.getAttribute('alt').includes("black") && this.color === "black" && (!downImagePiece.getAttribute('alt').includes("blackKing")) ) || (downImagePiece.getAttribute('alt').includes("white") && this.color === "white" && (!downImagePiece.getAttribute('alt').includes("whiteKing")))) {
                                                needsBreak = true;
                                                isDangerous = false;
                                            } else if (((!downImagePiece.getAttribute('alt').includes("whiteRook")) && (!downImagePiece.getAttribute('alt').includes("whiteQueen")) && (downImagePiece.getAttribute('alt').includes("white")) && (this.color === "black")) || (((!downImagePiece.getAttribute('alt').includes("blackRook")) && (!downImagePiece.getAttribute('alt').includes("blackQueen")) && (downImagePiece.getAttribute('alt').includes("black"))) && (this.color === "white"))) {  
                                                needsBreak = true;
                                                isDangerous = false;
                                            }
                                        } 
                                        break;
                                    default:
                                        if (downPiece.querySelector("img")) {
                                            let downImagePiece = downPiece.querySelector("img");
                                            if((downImagePiece.getAttribute('alt').includes("whiteRook") || downImagePiece.getAttribute('alt').includes("whiteQueen")) && (this.color === "black")) {
                                                needsBreak = true;
                                                isDangerous = true;
                                            } else if ((downImagePiece.getAttribute('alt').includes("blackRook") || downImagePiece.getAttribute('alt').includes("blackQueen")) && (this.color === "white")) {
                                                needsBreak = true;
                                                isDangerous = true;
                                            } else if ((downImagePiece.getAttribute('alt').includes("black") && this.color === "black" && (!downImagePiece.getAttribute('alt').includes("blackKing")) ) || (downImagePiece.getAttribute('alt').includes("white") && this.color === "white" && (!downImagePiece.getAttribute('alt').includes("whiteKing")))) {
                                                needsBreak = true;
                                                isDangerous = false;
                                            } else if (((!downImagePiece.getAttribute('alt').includes("whiteRook")) && (!downImagePiece.getAttribute('alt').includes("whiteQueen")) && (downImagePiece.getAttribute('alt').includes("white")) && (this.color === "black")) || (((!downImagePiece.getAttribute('alt').includes("blackRook")) && (!downImagePiece.getAttribute('alt').includes("blackQueen")) && (downImagePiece.getAttribute('alt').includes("black"))) && (this.color === "white"))) {  
                                                needsBreak = true;
                                                isDangerous = false;
                                            }
                                        }
                                        
                                        break;
                                } // end of switch case

                                if (needsBreak) {
                                    break;
                                }
                            } // end of for each statement
                        } // End of checking down side statement

                        // if isDangerous is true then go to the next outer for each element of loop so continue
                        if (isDangerous) {
                            continue;
                        }
                        
                        // start over
                        needsBreak = false;
                        isDangerous = false;

                        // Checking diagonally left down
                        if(eachMovement_yAxisValue == 1 || eachMovement_xAxisValue == 8) {
                        
                        } else {
                            for(let i = 1; i <= 8; i++) {
                                if (eachMovement_xAxisValue+i > 8 || eachMovement_yAxisValue-i < 1) {
                                    break;
                                }
                                let leftDownPiece = document.querySelector(`.cell_${eachMovement_xAxisValue+i}_${eachMovement_yAxisValue-i}`)
                                
                                switch(i) {
                                    case 1:
                                        if (leftDownPiece.querySelector("img")) {
                                            let leftDownImagePiece = leftDownPiece.querySelector("img");
                                            if((leftDownImagePiece.getAttribute('alt').includes("whiteBishop") || leftDownImagePiece.getAttribute('alt').includes("whiteQueen") || leftDownImagePiece.getAttribute('alt').includes("whiteKing")) && (this.color === "black")) {
                                                needsBreak = true;
                                                isDangerous = true;
                                            } else if ((leftDownImagePiece.getAttribute('alt').includes("blackBishop") || leftDownImagePiece.getAttribute('alt').includes("blackQueen") || leftDownImagePiece.getAttribute('alt').includes("blackKing")) && (this.color === "white")) {
                                                needsBreak = true;
                                                isDangerous = true;
                                            } else if (((leftDownImagePiece.getAttribute('alt').includes("blackPawn") && this.color === "white") && (!this.blackUp)) || ((leftDownImagePiece.getAttribute('alt').includes("whitePawn") && this.color === "black") && (this.blackUp))) {
                                                needsBreak = true;
                                                isDangerous = true;
                                            } else if ((leftDownImagePiece.getAttribute('alt').includes("black") && this.color === "black" && (!leftDownImagePiece.getAttribute('alt').includes("blackKing")) ) || (leftDownImagePiece.getAttribute('alt').includes("white") && this.color === "white" && (!leftDownImagePiece.getAttribute('alt').includes("whiteKing")))) {
                                                needsBreak = true;
                                                isDangerous = false;
                                            } else if (((!leftDownImagePiece.getAttribute('alt').includes("whiteBishop")) && (!leftDownImagePiece.getAttribute('alt').includes("whiteQueen")) && (leftDownImagePiece.getAttribute('alt').includes("white")) && (this.color === "black")) || (((!leftDownImagePiece.getAttribute('alt').includes("blackBishop")) && (!leftDownImagePiece.getAttribute('alt').includes("blackQueen")) && (leftDownImagePiece.getAttribute('alt').includes("black"))) && (this.color === "white"))) {  
                                                needsBreak = true;
                                                isDangerous = false;
                                            }

                                        } 
                                        break;
                                    default:
                                        if (leftDownPiece.querySelector("img")) {
                                            let leftDownImagePiece = leftDownPiece.querySelector("img");
                                            if((leftDownImagePiece.getAttribute('alt').includes("whiteBishop") || leftDownImagePiece.getAttribute('alt').includes("whiteQueen")) && (this.color === "black")) {
                                                needsBreak = true;
                                                isDangerous = true;
                                            } else if ((leftDownImagePiece.getAttribute('alt').includes("blackBishop") || leftDownImagePiece.getAttribute('alt').includes("blackQueen")) && (this.color === "white")) {
                                                needsBreak = true;
                                                isDangerous = true;
                                            } else if ((leftDownImagePiece.getAttribute('alt').includes("black") && this.color === "black" && (!leftDownImagePiece.getAttribute('alt').includes("blackKing")) ) || (leftDownImagePiece.getAttribute('alt').includes("white") && this.color === "white" && (!leftDownImagePiece.getAttribute('alt').includes("whiteKing")))) {
                                                needsBreak = true;
                                                isDangerous = false;
                                            } else if (((!leftDownImagePiece.getAttribute('alt').includes("whiteBishop")) && (!leftDownImagePiece.getAttribute('alt').includes("whiteQueen")) && (leftDownImagePiece.getAttribute('alt').includes("white")) && (this.color === "black")) || (((!leftDownImagePiece.getAttribute('alt').includes("blackBishop")) && (!leftDownImagePiece.getAttribute('alt').includes("blackQueen")) && (leftDownImagePiece.getAttribute('alt').includes("black"))) && (this.color === "white"))) {  
                                                needsBreak = true;
                                                isDangerous = false;
                                            }
                                        }
                                        break;
                                } // end of switch case
                                if (needsBreak) {
                                    break;
                                }    
                            } // diagonal left down for each statement
                        } // diagonal left down finished

                        if (isDangerous) {
                            continue;
                        }
                        
                        // start over
                        needsBreak = false;
                        isDangerous = false;

                        // checking diagonally right down
                        if(eachMovement_yAxisValue == 8 || eachMovement_xAxisValue == 8) {
                            
                        } else {
                            for(let i = 1; i <= 8; i++) {
                                if (eachMovement_xAxisValue+i > 8 || eachMovement_yAxisValue+i > 8) {
                                    break;
                                }

                                let rightDownPiece = document.querySelector(`.cell_${eachMovement_xAxisValue+i}_${eachMovement_yAxisValue+i}`)
                                
                                switch(i) {
                                    case 1:
                                        if (rightDownPiece.querySelector("img")) {
                                            let rightDownImagePiece = rightDownPiece.querySelector("img");
                                            if((rightDownImagePiece.getAttribute('alt').includes("whiteBishop") || rightDownImagePiece.getAttribute('alt').includes("whiteQueen") || rightDownImagePiece.getAttribute('alt').includes("whiteKing")) && (this.color === "black")) {
                                                needsBreak = true;
                                                isDangerous = true;
                                            } else if ((rightDownImagePiece.getAttribute('alt').includes("blackBishop") || rightDownImagePiece.getAttribute('alt').includes("blackQueen") || rightDownImagePiece.getAttribute('alt').includes("blackKing")) && (this.color === "white")) {
                                                needsBreak = true;
                                                isDangerous = true;
                                            } else if (((rightDownImagePiece.getAttribute('alt').includes("blackPawn") && this.color === "white") && (!this.blackUp)) || ((rightDownImagePiece.getAttribute('alt').includes("whitePawn") && this.color === "black") && (this.blackUp))) {
                                                needsBreak = true;
                                                isDangerous = true;
                                            } else if ((rightDownImagePiece.getAttribute('alt').includes("black") && this.color === "black" && (!rightDownImagePiece.getAttribute('alt').includes("blackKing")) ) || (rightDownImagePiece.getAttribute('alt').includes("white") && this.color === "white" && (!rightDownImagePiece.getAttribute('alt').includes("whiteKing")))) {
                                                needsBreak = true;
                                                isDangerous = false;
                                            } else if (((!rightDownImagePiece.getAttribute('alt').includes("whiteBishop")) && (!rightDownImagePiece.getAttribute('alt').includes("whiteQueen")) && (rightDownImagePiece.getAttribute('alt').includes("white")) && (this.color === "black")) || (((!rightDownImagePiece.getAttribute('alt').includes("blackBishop")) && (!rightDownImagePiece.getAttribute('alt').includes("blackQueen")) && (rightDownImagePiece.getAttribute('alt').includes("black"))) && (this.color === "white"))) {  
                                                needsBreak = true;
                                                isDangerous = false;
                                            }
                                        } 
                                        break;
                                    default:
                                        if (rightDownPiece.querySelector("img")) {
                                            let rightDownImagePiece = rightDownPiece.querySelector("img");
                                            if((rightDownImagePiece.getAttribute('alt').includes("whiteBishop") || rightDownImagePiece.getAttribute('alt').includes("whiteQueen")) && (this.color === "black")) {
                                                needsBreak = true;
                                                isDangerous = true;
                                            } else if ((rightDownImagePiece.getAttribute('alt').includes("blackBishop") || rightDownImagePiece.getAttribute('alt').includes("blackQueen")) && (this.color === "white")) {
                                                needsBreak = true;
                                                isDangerous = true;
                                            } else if ((rightDownImagePiece.getAttribute('alt').includes("black") && this.color === "black" && (!rightDownImagePiece.getAttribute('alt').includes("blackKing")) ) || (rightDownImagePiece.getAttribute('alt').includes("white") && this.color === "white" && (!rightDownImagePiece.getAttribute('alt').includes("whiteKing")))) {
                                                needsBreak = true;
                                                isDangerous = false;
                                            } else if (((!rightDownImagePiece.getAttribute('alt').includes("whiteBishop")) && (!rightDownImagePiece.getAttribute('alt').includes("whiteQueen")) && (rightDownImagePiece.getAttribute('alt').includes("white")) && (this.color === "black")) || (((!rightDownImagePiece.getAttribute('alt').includes("blackBishop")) && (!rightDownImagePiece.getAttribute('alt').includes("blackQueen")) && (rightDownImagePiece.getAttribute('alt').includes("black"))) && (this.color === "white"))) {  
                                                needsBreak = true;
                                                isDangerous = false;
                                            }
                                        }
                                        
                                        break;
                                } // end of switch case

                                if (needsBreak) {
                                    break;
                                }
                            } // end of for each statement
                        } // End of checking diagonally right down side statement

                        if (isDangerous) {
                            continue;
                        }
                        
                        // start over
                        needsBreak = false;
                        isDangerous = false;


                        // diagonal up left checking
                        if(eachMovement_yAxisValue == 1 || eachMovement_xAxisValue == 1) {
                            
                        } else {
                            for(let i = 1; i <= 8; i++) {
                                if (eachMovement_xAxisValue-i < 1 || eachMovement_yAxisValue-i < 1) {
                                    break;
                                }

                                let upLeftPiece = document.querySelector(`.cell_${eachMovement_xAxisValue-i}_${eachMovement_yAxisValue-i}`)
                                
                                switch(i) {
                                    case 1:
                                        if (upLeftPiece.querySelector("img")) {
                                            let upLeftImagePiece = upLeftPiece.querySelector("img");
                                            if((upLeftImagePiece.getAttribute('alt').includes("whiteBishop") || upLeftImagePiece.getAttribute('alt').includes("whiteQueen") || upLeftImagePiece.getAttribute('alt').includes("whiteKing")) && (this.color === "black")) {
                                                needsBreak = true;
                                                isDangerous = true;
                                            } else if ((upLeftImagePiece.getAttribute('alt').includes("blackBishop") || upLeftImagePiece.getAttribute('alt').includes("blackQueen") || upLeftImagePiece.getAttribute('alt').includes("blackKing")) && (this.color === "white")) {
                                                needsBreak = true;
                                                isDangerous = true;
                                            } else if (((upLeftImagePiece.getAttribute('alt').includes("blackPawn") && this.color === "white") && (this.blackUp)) || ((upLeftImagePiece.getAttribute('alt').includes("whitePawn") && this.color === "black") && (!this.blackUp))) {
                                                needsBreak = true;
                                                isDangerous = true;
                                            } else if ((upLeftImagePiece.getAttribute('alt').includes("black") && this.color === "black" && (!upLeftImagePiece.getAttribute('alt').includes("blackKing")) ) || (upLeftImagePiece.getAttribute('alt').includes("white") && this.color === "white" && (!upLeftImagePiece.getAttribute('alt').includes("whiteKing")))) {
                                                needsBreak = true;
                                                isDangerous = false;
                                            } else if (((!upLeftImagePiece.getAttribute('alt').includes("whiteBishop")) && (!upLeftImagePiece.getAttribute('alt').includes("whiteQueen")) && (upLeftImagePiece.getAttribute('alt').includes("white")) && (this.color === "black")) || (((!upLeftImagePiece.getAttribute('alt').includes("blackBishop")) && (!upLeftImagePiece.getAttribute('alt').includes("blackQueen")) && (upLeftImagePiece.getAttribute('alt').includes("black"))) && (this.color === "white"))) {  
                                                needsBreak = true;
                                                isDangerous = false;
                                            }
                                        } 
                                        break;
                                    default:
                                        if (upLeftPiece.querySelector("img")) {
                                            let upLeftImagePiece = upLeftPiece.querySelector("img");
                                            if((upLeftImagePiece.getAttribute('alt').includes("whiteBishop") || upLeftImagePiece.getAttribute('alt').includes("whiteQueen")) && (this.color === "black")) {
                                                needsBreak = true;
                                                isDangerous = true;
                                            } else if ((upLeftImagePiece.getAttribute('alt').includes("blackBishop") || upLeftImagePiece.getAttribute('alt').includes("blackQueen")) && (this.color === "white")) {
                                                needsBreak = true;
                                                isDangerous = true;
                                            } else if ((upLeftImagePiece.getAttribute('alt').includes("black") && this.color === "black" && (!upLeftImagePiece.getAttribute('alt').includes("blackKing")) ) || (upLeftImagePiece.getAttribute('alt').includes("white") && this.color === "white" && (!upLeftImagePiece.getAttribute('alt').includes("whiteKing")))) {
                                                needsBreak = true;
                                                isDangerous = false;
                                            } else if (((!upLeftImagePiece.getAttribute('alt').includes("whiteBishop")) && (!upLeftImagePiece.getAttribute('alt').includes("whiteQueen")) && (upLeftImagePiece.getAttribute('alt').includes("white")) && (this.color === "black")) || (((!upLeftImagePiece.getAttribute('alt').includes("blackBishop")) && (!upLeftImagePiece.getAttribute('alt').includes("blackQueen")) && (upLeftImagePiece.getAttribute('alt').includes("black"))) && (this.color === "white"))) {  
                                                needsBreak = true;
                                                isDangerous = false;
                                            }
                                        }
                                        
                                        break;
                                } // end of switch case

                                if (needsBreak) {
                                    break;
                                }

                            } // end of for each statement
                        } // End of checking diagonally up left side statement

                        if (isDangerous) {
                            continue;
                        }
                        
                        // start over
                        needsBreak = false;
                        isDangerous = false;

                        // check diagonally up right
                        if(eachMovement_yAxisValue == 8 || eachMovement_xAxisValue == 1) {
                            
                        } else {
                            for(let i = 1; i <= 8; i++) {
                                if (eachMovement_xAxisValue-i < 1 || eachMovement_yAxisValue+i > 8) {
                                    break;
                                }

                                let upRightPiece = document.querySelector(`.cell_${eachMovement_xAxisValue-i}_${eachMovement_yAxisValue+i}`)
                                
                                switch(i) {
                                    case 1:
                                        if (upRightPiece.querySelector("img")) {
                                            let upRightImagePiece = upRightPiece.querySelector("img");
                                            if((upRightImagePiece.getAttribute('alt').includes("whiteBishop") || upRightImagePiece.getAttribute('alt').includes("whiteQueen") || upRightImagePiece.getAttribute('alt').includes("whiteKing")) && (this.color === "black")) {
                                                needsBreak = true;
                                                isDangerous = true;
                                            } else if ((upRightImagePiece.getAttribute('alt').includes("blackBishop") || upRightImagePiece.getAttribute('alt').includes("blackQueen") || upRightImagePiece.getAttribute('alt').includes("blackKing")) && (this.color === "white")) {
                                                needsBreak = true;
                                                isDangerous = true;
                                            } else if (((upRightImagePiece.getAttribute('alt').includes("blackPawn") && this.color === "white") && (this.blackUp)) || ((upRightImagePiece.getAttribute('alt').includes("whitePawn") && this.color === "black") && (!this.blackUp))) {
                                                needsBreak = true;
                                                isDangerous = true;
                                            } else if ((upRightImagePiece.getAttribute('alt').includes("black") && this.color === "black" && (!upRightImagePiece.getAttribute('alt').includes("blackKing")) ) || (upRightImagePiece.getAttribute('alt').includes("white") && this.color === "white" && (!upRightImagePiece.getAttribute('alt').includes("whiteKing")))) {
                                                needsBreak = true;
                                                isDangerous = false;
                                            } else if (((!upRightImagePiece.getAttribute('alt').includes("whiteBishop")) && (!upRightImagePiece.getAttribute('alt').includes("whiteQueen")) && (upRightImagePiece.getAttribute('alt').includes("white")) && (this.color === "black")) || (((!upRightImagePiece.getAttribute('alt').includes("blackBishop")) && (!upRightImagePiece.getAttribute('alt').includes("blackQueen")) && (upRightImagePiece.getAttribute('alt').includes("black"))) && (this.color === "white"))) {  
                                                needsBreak = true;
                                                isDangerous = false;
                                            }
                                        } 
                                        break;
                                    default:
                                        if (upRightPiece.querySelector("img")) {
                                            let upRightImagePiece = upRightPiece.querySelector("img");
                                            if((upRightImagePiece.getAttribute('alt').includes("whiteBishop") || upRightImagePiece.getAttribute('alt').includes("whiteQueen")) && (this.color === "black")) {
                                                needsBreak = true;
                                                isDangerous = true;
                                            } else if ((upRightImagePiece.getAttribute('alt').includes("blackBishop") || upRightImagePiece.getAttribute('alt').includes("blackQueen")) && (this.color === "white")) {
                                                needsBreak = true;
                                                isDangerous = true;
                                            } else if ((upRightImagePiece.getAttribute('alt').includes("black") && this.color === "black" && (!upRightImagePiece.getAttribute('alt').includes("blackKing")) ) || (upRightImagePiece.getAttribute('alt').includes("white") && this.color === "white" && (!upRightImagePiece.getAttribute('alt').includes("whiteKing")))) {
                                                needsBreak = true;
                                                isDangerous = false;
                                            } else if (((!upRightImagePiece.getAttribute('alt').includes("whiteBishop")) && (!upRightImagePiece.getAttribute('alt').includes("whiteQueen")) && (upRightImagePiece.getAttribute('alt').includes("white")) && (this.color === "black")) || (((!upRightImagePiece.getAttribute('alt').includes("blackBishop")) && (!upRightImagePiece.getAttribute('alt').includes("blackQueen")) && (upRightImagePiece.getAttribute('alt').includes("black"))) && (this.color === "white"))) {  
                                                needsBreak = true;
                                                isDangerous = false;
                                            }
                                        }
                                        
                                        break;
                                } // end of switch case

                                if (needsBreak) {
                                    break;
                                }
                            } // end of for each statement
                        } // End of checking diagonally up left side statement

                        if (isDangerous) {
                            continue;
                        }
                        
                        // start over
                        needsBreak = false;
                        isDangerous = false;

                        // Check left side if enemy Knight is there
                        if(eachMovement_xAxisValue-1 >= 1 && eachMovement_yAxisValue-2 >= 1 ){
                            let knightPiecePossibleStance = document.querySelector(`.cell_${eachMovement_xAxisValue-1}_${eachMovement_yAxisValue-2}`);
                            if (knightPiecePossibleStance.querySelector("img")) {
                                let imagePiece = knightPiecePossibleStance.querySelector("img");
                                if((imagePiece.getAttribute('alt').includes("whiteKnight")) && (this.color === "black")) {
                                    isDangerous = true;
                                } else if ((imagePiece.getAttribute('alt').includes("blackKnight")) && (this.color === "white")) {
                                    isDangerous = true;
                                } else if ((imagePiece.getAttribute('alt').includes("black") && this.color === "black") || (imagePiece.getAttribute('alt').includes("white") && this.color === "white")) {
                                    isDangerous = false;
                                }
                            }
                        }

                        if (isDangerous) {
                            continue;
                        }
                        
                        // start over
                        needsBreak = false;
                        isDangerous = false;

                        if(eachMovement_xAxisValue-2 >= 1 && eachMovement_yAxisValue-1 >= 1 ){
                            let knightPiecePossibleStance = document.querySelector(`.cell_${eachMovement_xAxisValue-2}_${eachMovement_yAxisValue-1}`);
                            if (knightPiecePossibleStance.querySelector("img")) {
                                let imagePiece = knightPiecePossibleStance.querySelector("img");
                                if((imagePiece.getAttribute('alt').includes("whiteKnight")) && (this.color === "black")) {
                                    isDangerous = true;
                                } else if ((imagePiece.getAttribute('alt').includes("blackKnight")) && (this.color === "white")) {
                                    isDangerous = true;
                                } else if ((imagePiece.getAttribute('alt').includes("black") && this.color === "black") || (imagePiece.getAttribute('alt').includes("white") && this.color === "white")) {
                                    isDangerous = false;
                                }
                            }
                        }

                        if (isDangerous) {
                            continue;
                        }
                        
                        // start over
                        needsBreak = false;
                        isDangerous = false;

                        if(eachMovement_xAxisValue+1 <= 8 && eachMovement_yAxisValue-2 >= 1 ){
                            let knightPiecePossibleStance = document.querySelector(`.cell_${eachMovement_xAxisValue+1}_${eachMovement_yAxisValue-2}`);
                            if (knightPiecePossibleStance.querySelector("img")) {
                                let imagePiece = knightPiecePossibleStance.querySelector("img");
                                if((imagePiece.getAttribute('alt').includes("whiteKnight")) && (this.color === "black")) {
                                    isDangerous = true;
                                } else if ((imagePiece.getAttribute('alt').includes("blackKnight")) && (this.color === "white")) {
                                    isDangerous = true;
                                } else if ((imagePiece.getAttribute('alt').includes("black") && this.color === "black") || (imagePiece.getAttribute('alt').includes("white") && this.color === "white")) {
                                    isDangerous = false;
                                }
                            }
                        }

                        if (isDangerous) {
                            continue;
                        }
                        
                        // start over
                        needsBreak = false;
                        isDangerous = false;

                        if(eachMovement_xAxisValue+2 <= 8 && eachMovement_yAxisValue-1 >= 1 ){
                            let knightPiecePossibleStance = document.querySelector(`.cell_${eachMovement_xAxisValue+2}_${eachMovement_yAxisValue-1}`);
                            if (knightPiecePossibleStance.querySelector("img")) {
                                let imagePiece = knightPiecePossibleStance.querySelector("img");
                                if((imagePiece.getAttribute('alt').includes("whiteKnight")) && (this.color === "black")) {
                                    isDangerous = true;
                                } else if ((imagePiece.getAttribute('alt').includes("blackKnight")) && (this.color === "white")) {
                                    isDangerous = true;
                                } else if ((imagePiece.getAttribute('alt').includes("black") && this.color === "black") || (imagePiece.getAttribute('alt').includes("white") && this.color === "white")) {
                                    isDangerous = false;
                                }
                            }
                        }

                        if (isDangerous) {
                            continue;
                        }
                        
                        // start over
                        needsBreak = false;
                        isDangerous = false;

                        // check right if knight is there
                        if(eachMovement_xAxisValue-1 >= 1 && eachMovement_yAxisValue+2 <= 8 ){
                            let knightPiecePossibleStance = document.querySelector(`.cell_${eachMovement_xAxisValue-1}_${eachMovement_yAxisValue+2}`);
                            if (knightPiecePossibleStance.querySelector("img")) {
                                let imagePiece = knightPiecePossibleStance.querySelector("img");
                                if((imagePiece.getAttribute('alt').includes("whiteKnight")) && (this.color === "black")) {
                                    isDangerous = true;
                                } else if ((imagePiece.getAttribute('alt').includes("blackKnight")) && (this.color === "white")) {
                                    isDangerous = true;
                                } else if ((imagePiece.getAttribute('alt').includes("black") && this.color === "black") || (imagePiece.getAttribute('alt').includes("white") && this.color === "white")) {
                                    isDangerous = false;
                                }
                            }
                        }

                        if (isDangerous) {
                            continue;
                        }
                        
                        // start over
                        needsBreak = false;
                        isDangerous = false;


                        if(eachMovement_xAxisValue-2 >= 1 && eachMovement_yAxisValue+1 <= 8 ){
                            let knightPiecePossibleStance = document.querySelector(`.cell_${eachMovement_xAxisValue-2}_${eachMovement_yAxisValue+1}`);
                            if (knightPiecePossibleStance.querySelector("img")) {
                                let imagePiece = knightPiecePossibleStance.querySelector("img");
                                if((imagePiece.getAttribute('alt').includes("whiteKnight")) && (this.color === "black")) {
                                    isDangerous = true;
                                } else if ((imagePiece.getAttribute('alt').includes("blackKnight")) && (this.color === "white")) {
                                    isDangerous = true;
                                } else if ((imagePiece.getAttribute('alt').includes("black") && this.color === "black") || (imagePiece.getAttribute('alt').includes("white") && this.color === "white")) {
                                    isDangerous = false;
                                }
                            }
                        }

                        if (isDangerous) {
                            continue;
                        }
                        
                        // start over
                        needsBreak = false;
                        isDangerous = false;

                        if(eachMovement_xAxisValue+1 <= 8 && eachMovement_yAxisValue+2 <= 8 ){
                            let knightPiecePossibleStance = document.querySelector(`.cell_${eachMovement_xAxisValue+1}_${eachMovement_yAxisValue+2}`);
                            if (knightPiecePossibleStance.querySelector("img")) {
                                let imagePiece = knightPiecePossibleStance.querySelector("img");
                                if((imagePiece.getAttribute('alt').includes("whiteKnight")) && (this.color === "black")) {
                                    isDangerous = false;
                                } else if ((imagePiece.getAttribute('alt').includes("blackKnight")) && (this.color === "white")) {
                                    isDangerous = false;
                                } else if ((imagePiece.getAttribute('alt').includes("black") && this.color === "black") || (imagePiece.getAttribute('alt').includes("white") && this.color === "white")) {
                                    isDangerous = false;
                                }
                            }
                        }

                        if (isDangerous) {
                            continue;
                        }
                        
                        // start over
                        needsBreak = false;
                        isDangerous = false;

                        if(eachMovement_xAxisValue+2 <= 8 && eachMovement_yAxisValue+1 <= 8 ){
                            let knightPiecePossibleStance = document.querySelector(`.cell_${eachMovement_xAxisValue+2}_${eachMovement_yAxisValue+1}`);
                            if (knightPiecePossibleStance.querySelector("img")) {
                                let imagePiece = knightPiecePossibleStance.querySelector("img");
                                if((imagePiece.getAttribute('alt').includes("whiteKnight")) && (this.color === "black")) {
                                    isDangerous = true;
                                } else if ((imagePiece.getAttribute('alt').includes("blackKnight")) && (this.color === "white")) {
                                    isDangerous = true;
                                } else if ((imagePiece.getAttribute('alt').includes("black") && this.color === "black") || (imagePiece.getAttribute('alt').includes("white") && this.color === "white")) {
                                    isDangerous = false;
                                }
                            }
                        }
                        
                        // last element
                        if (isDangerous) {
                            continue;
                        } else {
                            defendingMovements.push(`.cell_${eachMovement_xAxisValue}_${eachMovement_yAxisValue}`);
                        }
                    

                    } // End of outer for each statement for king movements
                    /////////////////////// check king's movements end

                    if (defendingMovements.length > 0) {
                        kingIsInDanger = false;
                        return kingIsInDanger;
                    } else {
                        kingIsInDanger = true;
                        return kingIsInDanger;
                    }
                } // castlingVerification check done
                

            } // end of king class
            
            // King Class end

            // Classes ////////////////////////////////////////////////////////////////////////////////////////////////////////////////


            // possible moves calculate start
            function possibleMove(piece, coordinates, newCoordinates) {
                let foundIdx = 0;
                let xAxisValue = parseInt(coordinates.substr(6, 1));
                let yAxisValue = parseInt(coordinates.substr(coordinates.length -1, 1));
                let newxAxisValue = parseInt(newCoordinates.substr(6, 1));
                let newyAxisValue = parseInt(newCoordinates.substr(coordinates.length -1, 1));

                let possibleMoves = [];
                let pieceName = "";


                // pieces movement
                if (piece.getAttribute('alt').includes("whitePawn")) {
                    foundIdx = whitePawnPieces.findIndex(function(cellNumber){return cellNumber.position === `.cell_${xAxisValue}_${yAxisValue}`});
                    pieceName = "whitePawn";
                } else if (piece.getAttribute('alt').includes("blackPawn")) {
                    foundIdx = blackPawnPieces.findIndex(function(cellNumber){return cellNumber.position === `.cell_${xAxisValue}_${yAxisValue}`});
                    pieceName = "blackPawn";
                } else if (piece.getAttribute('alt').includes("blackRook")) {
                    foundIdx = blackRookPieces.findIndex(function(cellNumber){return cellNumber.position === `.cell_${xAxisValue}_${yAxisValue}`});
                    pieceName = "blackRook";
                } else if (piece.getAttribute('alt').includes("whiteRook")) {
                    foundIdx = whiteRookPieces.findIndex(function(cellNumber){return cellNumber.position === `.cell_${xAxisValue}_${yAxisValue}`});
                    pieceName = "whiteRook";
                } else if (piece.getAttribute('alt').includes("whiteBishop")) {
                    foundIdx = whiteBishopPieces.findIndex(function(cellNumber){return cellNumber.position === `.cell_${xAxisValue}_${yAxisValue}`});
                    pieceName = "whiteBishop";
                } else if (piece.getAttribute('alt').includes("blackBishop")) {
                    foundIdx = blackBishopPieces.findIndex(function(cellNumber){return cellNumber.position === `.cell_${xAxisValue}_${yAxisValue}`});
                    pieceName = "blackBishop";
                } else if (piece.getAttribute('alt').includes("blackKnight")) {
                    foundIdx = blackKnightPieces.findIndex(function(cellNumber){return cellNumber.position === `.cell_${xAxisValue}_${yAxisValue}`});
                    pieceName = "blackKnight";
                } else if (piece.getAttribute('alt').includes("whiteKnight")) {
                    foundIdx = whiteKnightPieces.findIndex(function(cellNumber){return cellNumber.position === `.cell_${xAxisValue}_${yAxisValue}`});
                    pieceName = "whiteKnight";
                } else if (piece.getAttribute('alt').includes("blackQueen")) {
                    foundIdx = blackQueenPiece.findIndex(function(cellNumber){return cellNumber.position === `.cell_${xAxisValue}_${yAxisValue}`});
                    pieceName = "blackQueen";
                } else if (piece.getAttribute('alt').includes("whiteQueen")) {
                    foundIdx = whiteQueenPiece.findIndex(function(cellNumber){return cellNumber.position === `.cell_${xAxisValue}_${yAxisValue}`});
                    pieceName = "whiteQueen";
                } else if (piece.getAttribute('alt').includes("blackKing")) {
                    foundIdx = blackKingPiece.findIndex(function(cellNumber){return cellNumber.position === `.cell_${xAxisValue}_${yAxisValue}`});
                    pieceName = "blackKing";
                } else {
                    foundIdx = whiteKingPiece.findIndex(function(cellNumber){return cellNumber.position === `.cell_${xAxisValue}_${yAxisValue}`});
                    pieceName = "whiteKing";
                }


                
                if (foundIdx !== -1) {
                    switch (pieceName){
                        case "whitePawn":
                            possibleMoves = whitePawnPieces[foundIdx].possibleMove(xAxisValue, yAxisValue, false, newxAxisValue, newyAxisValue);
                            break;
                        case "blackPawn":
                            possibleMoves = blackPawnPieces[foundIdx].possibleMove(xAxisValue, yAxisValue, false, newxAxisValue, newyAxisValue);
                            break;
                        case "blackRook":
                            possibleMoves = blackRookPieces[foundIdx].possibleMove(xAxisValue, yAxisValue, newxAxisValue, newyAxisValue, false);
                            break;
                        case "whiteRook":
                            possibleMoves = whiteRookPieces[foundIdx].possibleMove(xAxisValue, yAxisValue, newxAxisValue, newyAxisValue, false);
                            break;
                        case "blackBishop":
                            possibleMoves = blackBishopPieces[foundIdx].possibleMove(xAxisValue, yAxisValue, newxAxisValue, newyAxisValue);
                            break;
                        case "whiteBishop":
                            possibleMoves = whiteBishopPieces[foundIdx].possibleMove(xAxisValue, yAxisValue, newxAxisValue, newyAxisValue);
                            break;
                        case "blackKnight":
                            possibleMoves = blackKnightPieces[foundIdx].possibleMove(xAxisValue, yAxisValue, newxAxisValue, newyAxisValue);
                            break;
                        case "whiteKnight":
                            possibleMoves = whiteKnightPieces[foundIdx].possibleMove(xAxisValue, yAxisValue, newxAxisValue, newyAxisValue);
                            break;
                        case "blackQueen":
                            possibleMoves = blackQueenPiece[foundIdx].possibleMove(xAxisValue, yAxisValue, newxAxisValue, newyAxisValue);
                            break;
                        case "whiteQueen":
                            possibleMoves = whiteQueenPiece[foundIdx].possibleMove(xAxisValue, yAxisValue, newxAxisValue, newyAxisValue);
                            break;
                        case "blackKing":
                            possibleMoves = blackKingPiece[foundIdx].possibleMove(xAxisValue, yAxisValue, false);
                            break;
                        case "whiteKing":
                            possibleMoves = whiteKingPiece[foundIdx].possibleMove(xAxisValue, yAxisValue, false);
                            break;
                    }
                    
                }

                return possibleMoves;

            }
            // possible moves calculate end

            // possible eating move start
            function eatingPossibility(piece, coordinates, newCoordinates) {
                let foundIdx = 0;
                let xAxisValue = parseInt(coordinates.substr(6, 1));
                let yAxisValue = parseInt(coordinates.substr(coordinates.length -1, 1));
                let new_xAxisValue = parseInt(newCoordinates.substr(6, 1));
                let new_yAxisValue = parseInt(newCoordinates.substr(coordinates.length -1, 1));
                let currentPosition = `.cell_${xAxisValue}_${yAxisValue}`;
                let newEatingPosition = `.cell_${new_xAxisValue}_${new_yAxisValue}`;

                let possibleMoves = [];
                let pieceName = "";

                

                // find index of piece
                if (piece.getAttribute('alt').includes("whitePawn")) {
                    foundIdx = whitePawnPieces.findIndex(function(cellNumber){return cellNumber.position === currentPosition});
                    pieceName = "whitePawn";
                } else if (piece.getAttribute('alt').includes("blackPawn")) {
                    foundIdx = blackPawnPieces.findIndex(function(cellNumber){return cellNumber.position === currentPosition});
                    pieceName = "blackPawn";
                } else if (piece.getAttribute('alt').includes("blackRook")) {
                    foundIdx = blackRookPieces.findIndex(function(cellNumber){return cellNumber.position === currentPosition});
                    pieceName = "blackRook";
                } else if (piece.getAttribute('alt').includes("whiteRook")) {
                    foundIdx = whiteRookPieces.findIndex(function(cellNumber){return cellNumber.position === currentPosition});
                    pieceName = "whiteRook";
                } else if (piece.getAttribute('alt').includes("blackBishop")) {
                    foundIdx = blackBishopPieces.findIndex(function(cellNumber){return cellNumber.position === currentPosition});
                    pieceName = "blackBishop";
                } else if (piece.getAttribute('alt').includes("whiteBishop")) {
                    foundIdx = whiteBishopPieces.findIndex(function(cellNumber){return cellNumber.position === currentPosition});
                    pieceName = "whiteBishop";
                } else if (piece.getAttribute('alt').includes("blackKnight")) {
                    foundIdx = blackKnightPieces.findIndex(function(cellNumber){return cellNumber.position === currentPosition});
                    pieceName = "blackKnight";
                } else if (piece.getAttribute('alt').includes("whiteKnight")) {
                    foundIdx = whiteKnightPieces.findIndex(function(cellNumber){return cellNumber.position === currentPosition});
                    pieceName = "whiteKnight";
                } else if (piece.getAttribute('alt').includes("blackQueen")) {
                    foundIdx = blackQueenPiece.findIndex(function(cellNumber){return cellNumber.position === currentPosition});
                    pieceName = "blackQueen";
                } else if (piece.getAttribute('alt').includes("whiteQueen")) {
                    foundIdx = whiteQueenPiece.findIndex(function(cellNumber){return cellNumber.position === currentPosition});
                    pieceName = "whiteQueen";
                } else if (piece.getAttribute('alt').includes("blackKing")) {
                    foundIdx = blackKingPiece.findIndex(function(cellNumber){return cellNumber.position === currentPosition});
                    pieceName = "blackKing";
                } else {
                    foundIdx = whiteKingPiece.findIndex(function(cellNumber){return cellNumber.position === currentPosition});
                    pieceName = "whiteKing";
                }

                if (foundIdx !== -1) {
                    switch (pieceName){
                        case "whitePawn":
                            possibleMoves = whitePawnPieces[foundIdx].eatingPossibility(xAxisValue, yAxisValue, false);
                            break;
                        case "blackPawn":
                            possibleMoves = blackPawnPieces[foundIdx].eatingPossibility(xAxisValue, yAxisValue , false);
                            break;
                        case "whiteRook":
                            possibleMoves = whiteRookPieces[foundIdx].eatingPossibility(xAxisValue, yAxisValue, new_xAxisValue, new_yAxisValue, false);
                            break;
                        case "blackRook":
                            possibleMoves = blackRookPieces[foundIdx].eatingPossibility(xAxisValue, yAxisValue, new_xAxisValue, new_yAxisValue, false);
                            break;
                        case "blackBishop":
                            possibleMoves = blackBishopPieces[foundIdx].eatingPossibility(xAxisValue, yAxisValue, new_xAxisValue, new_yAxisValue);
                            break;
                        case "whiteBishop":
                            possibleMoves = whiteBishopPieces[foundIdx].eatingPossibility(xAxisValue, yAxisValue, new_xAxisValue, new_yAxisValue);
                            break;
                        case "blackKnight":
                            possibleMoves = blackKnightPieces[foundIdx].possibleMove(xAxisValue, yAxisValue, new_xAxisValue, new_yAxisValue);
                            break;
                        case "whiteKnight":
                            possibleMoves = whiteKnightPieces[foundIdx].possibleMove(xAxisValue, yAxisValue, new_xAxisValue, new_yAxisValue);
                            break;
                        case "blackQueen":
                            possibleMoves = blackQueenPiece[foundIdx].eatingPossibility(xAxisValue, yAxisValue, new_xAxisValue, new_yAxisValue);
                            break;
                        case "whiteQueen":
                            possibleMoves = whiteQueenPiece[foundIdx].eatingPossibility(xAxisValue, yAxisValue, new_xAxisValue, new_yAxisValue);
                            break;
                        case "blackKing":
                            possibleMoves = blackKingPiece[foundIdx].possibleMove(xAxisValue, yAxisValue, false);
                            break;
                        case "whiteKing":
                            possibleMoves = whiteKingPiece[foundIdx].possibleMove(xAxisValue, yAxisValue, false);
                            break;
                    }
                    
                }
                
                return possibleMoves;

            
            }

            // possible eating move end


            // updating pieces start
            function updateCoordinate(piece, prevCoordinate, coordinates, eaten, eatenPiece, reverse, blackup) {
                let foundIdx = 0;
                let prev_xAxisValue = prevCoordinate.substr(6, 1);
                let prev_yAxisValue = prevCoordinate.substr(coordinates.length -1, 1);
                let new_xAxisValue = coordinates.substr(6, 1);
                let new_yAxisValue = coordinates.substr(coordinates.length -1, 1);
                let possibleMoves = [];
                let pieceName = "";
                
                // getting previous movement
                if (piece.getAttribute('alt').includes("whitePawn")) {
                    foundIdx = whitePawnPieces.findIndex(function(cellNumber){return cellNumber.position === `.cell_${prev_xAxisValue}_${prev_yAxisValue}`});
                    pieceName = "whitePawn";
                } else if (piece.getAttribute('alt').includes("blackPawn")) {
                    foundIdx = blackPawnPieces.findIndex(function(cellNumber){return cellNumber.position === `.cell_${prev_xAxisValue}_${prev_yAxisValue}`});
                    pieceName = "blackPawn";
                } else if (piece.getAttribute('alt').includes("blackRook")) {
                    foundIdx = blackRookPieces.findIndex(function(cellNumber){return cellNumber.position === `.cell_${prev_xAxisValue}_${prev_yAxisValue}`});
                    pieceName = "blackRook";
                } else if (piece.getAttribute('alt').includes("whiteRook")) {
                    foundIdx = whiteRookPieces.findIndex(function(cellNumber){return cellNumber.position === `.cell_${prev_xAxisValue}_${prev_yAxisValue}`});
                    pieceName = "whiteRook";
                } else if (piece.getAttribute('alt').includes("blackBishop")) {
                    foundIdx = blackBishopPieces.findIndex(function(cellNumber){return cellNumber.position === `.cell_${prev_xAxisValue}_${prev_yAxisValue}`});
                    pieceName = "blackBishop";
                } else if (piece.getAttribute('alt').includes("whiteBishop")) {
                    foundIdx = whiteBishopPieces.findIndex(function(cellNumber){return cellNumber.position === `.cell_${prev_xAxisValue}_${prev_yAxisValue}`});
                    pieceName = "whiteBishop";
                } else if (piece.getAttribute('alt').includes("blackKnight")) {
                    foundIdx = blackKnightPieces.findIndex(function(cellNumber){return cellNumber.position === `.cell_${prev_xAxisValue}_${prev_yAxisValue}`});
                    pieceName = "blackKnight";
                } else if (piece.getAttribute('alt').includes("whiteKnight")) {
                    foundIdx = whiteKnightPieces.findIndex(function(cellNumber){return cellNumber.position === `.cell_${prev_xAxisValue}_${prev_yAxisValue}`});
                    pieceName = "whiteKnight";
                } else if (piece.getAttribute('alt').includes("blackQueen")) {
                    foundIdx = blackQueenPiece.findIndex(function(cellNumber){return cellNumber.position === `.cell_${prev_xAxisValue}_${prev_yAxisValue}`});
                    pieceName = "blackQueen";
                } else if (piece.getAttribute('alt').includes("whiteQueen")) {
                    foundIdx = whiteQueenPiece.findIndex(function(cellNumber){return cellNumber.position === `.cell_${prev_xAxisValue}_${prev_yAxisValue}`});
                    pieceName = "whiteQueen";
                } else if (piece.getAttribute('alt').includes("blackKing")) {
                    foundIdx = blackKingPiece.findIndex(function(cellNumber){return cellNumber.position === `.cell_${prev_xAxisValue}_${prev_yAxisValue}`});
                    pieceName = "blackKing";
                } else {
                    foundIdx = whiteKingPiece.findIndex(function(cellNumber){return cellNumber.position === `.cell_${prev_xAxisValue}_${prev_yAxisValue}`});
                    pieceName = "whiteKing";
                }
            


                if (foundIdx !== -1) {
                    switch (pieceName){
                        case "whitePawn":
                            whitePawnPieces[foundIdx].updatePosition(`.cell_${new_xAxisValue}_${new_yAxisValue}`);

                            // Pawn Promotion
                            if((prev_xAxisValue == 7 && new_xAxisValue == 8) || (prev_xAxisValue == 2 && new_xAxisValue == 1)) {
                                let promotedPiece = prompt("Congratulations! Your Pawn is promoted! Which piece would you like to select? Examples are shown below", `"knight", "bishop", "queen", "rook"`);
                                let newCoordinatePiece = document.querySelector(`.cell_${new_xAxisValue}_${new_yAxisValue}`);
                                switch (promotedPiece) {
                                    case "knight":
                                        var whiteKnight = new Knight(`.cell_${new_xAxisValue}_${new_yAxisValue}`, blackUp, "white");
                                        whiteKnightPieces.push(whiteKnight);
                                        whitePawnPieces.splice(foundIdx, 1);
                                        newCoordinatePiece.innerHTML = "";
                                        newCoordinatePiece.innerHTML = `<img src="./img/whiteKnight.png" alt="whiteKnight">`;
                                        break
                                    case "bishop":
                                        var whiteBishop = new Bishop(`.cell_${new_xAxisValue}_${new_yAxisValue}`, blackUp, "white");
                                        whiteBishopPieces.push(whiteBishop);
                                        whitePawnPieces.splice(foundIdx, 1);
                                        newCoordinatePiece.innerHTML = "";
                                        newCoordinatePiece.innerHTML = `<img src="./img/whiteBishop.png" alt="whiteBishop">`;
                                        break;
                                    case "queen":
                                        var whiteQueen = new Queen(`.cell_${new_xAxisValue}_${new_yAxisValue}`, blackUp, "white");
                                        whiteQueenPiece.push(whiteQueen);
                                        whitePawnPieces.splice(foundIdx, 1);
                                        newCoordinatePiece.innerHTML = "";
                                        newCoordinatePiece.innerHTML = `<img src="./img/whiteQueen.png" alt="whiteQueen">`;
                                        break;
                                    case "rook":
                                        var whiteRook = new Rook(`.cell_${new_xAxisValue}_${new_yAxisValue}`, blackUp, "white");
                                        whiteRookPieces.push(whiteRook);
                                        whitePawnPieces.splice(foundIdx, 1);
                                        newCoordinatePiece.innerHTML = "";
                                        newCoordinatePiece.innerHTML = `<img src="./img/whiteRook.png" alt="whiteRook">`;
                                        break;

                                } // end of switch case
                            }

                            break;
                        case "blackPawn":
                            blackPawnPieces[foundIdx].updatePosition(`.cell_${new_xAxisValue}_${new_yAxisValue}`);

                            // Pawn Promotion
                            if((prev_xAxisValue == 7 && new_xAxisValue == 8) || (prev_xAxisValue == 2 && new_xAxisValue == 1)) {
                                let promotedPiece = prompt("Congratulations! Your Pawn is promoted! Which piece would you like to select? Examples are shown below", `"knight", "bishop", "queen", "rook"`);
                                let newCoordinatePiece = document.querySelector(`.cell_${new_xAxisValue}_${new_yAxisValue}`);
                                switch (promotedPiece) {
                                    case "knight":
                                        var blackKnight = new Knight(`.cell_${new_xAxisValue}_${new_yAxisValue}`, blackUp, "black");
                                        blackKnightPieces.push(blackKnight);
                                        blackPawnPieces.splice(foundIdx, 1);
                                        newCoordinatePiece.innerHTML = "";
                                        newCoordinatePiece.innerHTML = `<img src="./img/blackKnight.png" alt="blackKnight">`;
                                        break;
                                    case "bishop":
                                        var blackBishop = new Bishop(`.cell_${new_xAxisValue}_${new_yAxisValue}`, blackUp, "black");
                                        blackBishopPieces.push(blackBishop);
                                        blackBishopPieces.splice(foundIdx, 1);
                                        newCoordinatePiece.innerHTML = "";
                                        newCoordinatePiece.innerHTML = `<img src="./img/blackBishop.png" alt="blackBishop">`;
                                        break;
                                    case "queen":
                                        var blackQueen = new Queen(`.cell_${new_xAxisValue}_${new_yAxisValue}`, blackUp, "black");
                                        blackQueenPiece.push(blackQueen);
                                        blackPawnPieces.splice(foundIdx, 1);
                                        newCoordinatePiece.innerHTML = "";
                                        newCoordinatePiece.innerHTML = `<img src="./img/blackQueen.png" alt="blackQueen">`;
                                        break;
                                    case "rook":
                                        var blackRook = new Rook(`.cell_${new_xAxisValue}_${new_yAxisValue}`, blackUp, "black");
                                        blackRookPieces.push(blackRook);
                                        blackPawnPieces.splice(foundIdx, 1);
                                        newCoordinatePiece.innerHTML = "";
                                        newCoordinatePiece.innerHTML = `<img src="./img/blackRook.png" alt="blackRook">`;
                                        break;

                                } // end of switch case
                            }

                            break;
                        case "blackRook":
                            blackRookPieces[foundIdx].updatePosition(`.cell_${new_xAxisValue}_${new_yAxisValue}`);
                            break;
                        case "whiteRook":
                            whiteRookPieces[foundIdx].updatePosition(`.cell_${new_xAxisValue}_${new_yAxisValue}`);
                            break;
                        case "whiteBishop":
                            whiteBishopPieces[foundIdx].updatePosition(`.cell_${new_xAxisValue}_${new_yAxisValue}`);
                            break;
                        case "blackBishop":
                            blackBishopPieces[foundIdx].updatePosition(`.cell_${new_xAxisValue}_${new_yAxisValue}`);
                            break;
                        case "blackKnight":
                            blackKnightPieces[foundIdx].updatePosition(`.cell_${new_xAxisValue}_${new_yAxisValue}`);
                            break;
                        case "whiteKnight":
                            whiteKnightPieces[foundIdx].updatePosition(`.cell_${new_xAxisValue}_${new_yAxisValue}`);
                            break;
                        case "blackQueen":
                            blackQueenPiece[foundIdx].updatePosition(`.cell_${new_xAxisValue}_${new_yAxisValue}`);
                            break;
                        case "whiteQueen":
                            whiteQueenPiece[foundIdx].updatePosition(`.cell_${new_xAxisValue}_${new_yAxisValue}`);
                            break;
                        case "blackKing":
                            blackKingPiece[foundIdx].updatePosition(`.cell_${new_xAxisValue}_${new_yAxisValue}`);
                            break;
                        case "whiteKing":
                            whiteKingPiece[foundIdx].updatePosition(`.cell_${new_xAxisValue}_${new_yAxisValue}`);
                            break;                          
                    } // end of switch case
                } // end of if foundIdx !== 0

                // Decrease pieces if some piece is eaten
                if (eaten) {
                    if (eatenPiece.getAttribute('alt').includes("whitePawn")) {
                        foundIdx = whitePawnPieces.findIndex(function(cellNumber){return cellNumber.position === `.cell_${new_xAxisValue}_${new_yAxisValue}`});
                        whitePawnPieces.splice(foundIdx, 1);
                    } else if (eatenPiece.getAttribute('alt').includes("blackPawn")) {
                        foundIdx = blackPawnPieces.findIndex(function(cellNumber){return cellNumber.position === `.cell_${new_xAxisValue}_${new_yAxisValue}`});
                        blackPawnPieces.splice(foundIdx, 1);
                    } else if (eatenPiece.getAttribute('alt').includes("blackRook")) {
                        foundIdx = blackRookPieces.findIndex(function(cellNumber){return cellNumber.position === `.cell_${new_xAxisValue}_${new_yAxisValue}`});
                        blackRookPieces.splice(foundIdx, 1);
                    } else if (eatenPiece.getAttribute('alt').includes("whiteRook")) {
                        foundIdx = whiteRookPieces.findIndex(function(cellNumber){return cellNumber.position === `.cell_${new_xAxisValue}_${new_yAxisValue}`});
                        whiteRookPieces.splice(foundIdx, 1);
                    } else if (eatenPiece.getAttribute('alt').includes("whiteBishop")) {
                        foundIdx = whiteBishopPieces.findIndex(function(cellNumber){return cellNumber.position === `.cell_${new_xAxisValue}_${new_yAxisValue}`});
                        whiteBishopPieces.splice(foundIdx, 1);
                    } else if (eatenPiece.getAttribute('alt').includes("blackBishop")) {
                        foundIdx = blackBishopPieces.findIndex(function(cellNumber){return cellNumber.position === `.cell_${new_xAxisValue}_${new_yAxisValue}`});
                        blackBishopPieces.splice(foundIdx, 1);
                    } else if (eatenPiece.getAttribute('alt').includes("blackKnight")) {
                        foundIdx = blackKnightPieces.findIndex(function(cellNumber){return cellNumber.position === `.cell_${new_xAxisValue}_${new_yAxisValue}`});
                        blackKnightPieces.splice(foundIdx, 1);
                    } else if (eatenPiece.getAttribute('alt').includes("whiteKnight")) {
                        foundIdx = whiteKnightPieces.findIndex(function(cellNumber){return cellNumber.position === `.cell_${new_xAxisValue}_${new_yAxisValue}`});
                        whiteKnightPieces.splice(foundIdx, 1);
                    } else if (eatenPiece.getAttribute('alt').includes("blackQueen")) {
                        foundIdx = blackQueenPiece.findIndex(function(cellNumber){return cellNumber.position === `.cell_${new_xAxisValue}_${new_yAxisValue}`});
                        blackQueenPiece.splice(foundIdx, 1);
                    } else if (eatenPiece.getAttribute('alt').includes("whiteQueen")) {
                        foundIdx = whiteQueenPiece.findIndex(function(cellNumber){return cellNumber.position === `.cell_${new_xAxisValue}_${new_yAxisValue}`});
                        whiteQueenPiece.splice(foundIdx, 1);
                    } else if (eatenPiece.getAttribute('alt').includes("blackKing")) {
                        foundIdx = blackKingPiece.findIndex(function(cellNumber){return cellNumber.position === `.cell_${new_xAxisValue}_${new_yAxisValue}`});
                        blackKingPiece.splice(foundIdx, 1);
                        alert("White Won!");
                        location.reload();
                    } else {
                        foundIdx = whiteKingPiece.findIndex(function(cellNumber){return cellNumber.position === `.cell_${new_xAxisValue}_${new_yAxisValue}`});
                        whiteKingPiece.splice(foundIdx, 1);
                        alert("Black Won!");
                        location.reload();
                    }
                }

                // reverse the update
                if (reverse) {
                    if (eatenPiece.getAttribute('alt').includes("whitePawn")) {
                        var whitePawn = new Pawn(`.cell_${new_xAxisValue}_${new_yAxisValue}`, blackUp, "white");
                        whitePawnPieces.push(whitePawn);
                    } else if (eatenPiece.getAttribute('alt').includes("blackPawn")) {
                        var blackPawn = new Pawn(`.cell_${new_xAxisValue}_${new_yAxisValue}`, blackUp, "black");
                        blackPawnPieces.push(blackPawn);
                    } else if (eatenPiece.getAttribute('alt').includes("blackRook")) {
                        var blackRook = new Rook(`.cell_${new_xAxisValue}_${new_yAxisValue}`, blackUp, "black");
                        blackRookPieces.push(blackRook);
                    } else if (eatenPiece.getAttribute('alt').includes("whiteRook")) {
                        var whiteRook = new Rook(`.cell_${new_xAxisValue}_${new_yAxisValue}`, blackUp, "white");
                        whiteRookPieces.push(whiteRook);
                    } else if (eatenPiece.getAttribute('alt').includes("whiteBishop")) {
                        var whiteBishop = new Bishop(`.cell_${new_xAxisValue}_${new_yAxisValue}`, blackUp, "white");
                        whiteBishopPieces.push(whiteBishop);
                    } else if (eatenPiece.getAttribute('alt').includes("blackBishop")) {
                        var blackBishop = new Bishop(`.cell_${new_xAxisValue}_${new_yAxisValue}`, blackUp, "black");
                        blackBishopPieces.push(blackBishop);
                    } else if (eatenPiece.getAttribute('alt').includes("blackKnight")) {
                        var blackKnight = new Knight(`.cell_${new_xAxisValue}_${new_yAxisValue}`, blackUp, "black");
                        blackKnightPieces.push(blackKnight);
                    } else if (eatenPiece.getAttribute('alt').includes("whiteKnight")) {
                        var whiteKnight = new Knight(`.cell_${new_xAxisValue}_${new_yAxisValue}`, blackUp, "white");
                        whiteKnightPieces.push(whiteKnight);
                    } else if (eatenPiece.getAttribute('alt').includes("blackQueen")) {
                        var blackQueen = new Queen(`.cell_${new_xAxisValue}_${new_yAxisValue}`, blackUp, "black");
                        blackQueenPiece.push(blackQueen);
                    } else if (eatenPiece.getAttribute('alt').includes("whiteQueen")) {
                        var whiteQueen = new Queen(`.cell_${new_xAxisValue}_${new_yAxisValue}`, blackUp, "white");
                        whiteQueenPiece.push(whiteQueen);
                    } else if (eatenPiece.getAttribute('alt').includes("blackKing")) {
                        var blackKing = new King(`.cell_${new_xAxisValue}_${new_yAxisValue}`, blackUp, "black");
                        blackKingPiece.push(blackKing);
                    } else {
                        var whiteKing = new King(`.cell_${new_xAxisValue}_${new_yAxisValue}`, blackUp, "white");
                        whiteKingPiece.push(whiteKing);
                    }
                }


            }
            // updating pieces end


            // Variables Start
            const chess_board = document.querySelector(".chess_board");
            let boxes = 8;
            const chess_pieces = ["Rook", "Knight", "Bishop", "Queen", "King", "Bishop", "Knight", "Rook"];
            let tempNum = 1;
            let selectedPiece = null;
            let prevCoordinate = null;

            // white pieces
            let whitePawnPieces = [];
            let whiteRookPieces = [];
            let whiteKnightPieces = [];
            let whiteBishopPieces = [];
            let whiteQueenPiece = [];
            let whiteKingPiece = [];

            // black pieces
            let blackPawnPieces = [];
            let blackRookPieces = [];
            let blackKnightPieces = [];
            let blackBishopPieces = [];
            let blackQueenPiece = [];
            let blackKingPiece = [];

            let possibleMoves = [];
            let foundIdx = 0;
            let turn = "";
            let blackUp = false;
            let whiteRowNum = 0;
            let blackRowNum = 0;
            let whiteUp = true;
            let isCheckBlack = false;
            let isCheckWhite = false;
            let checkedWord = document.querySelector('h1');
            let isCheckMate = false;
            let defendingMoves = [];
            let attackerPiece;
            let attackerCoordination;
            let defendTheKingMessage;
            let pawnMatch = false;
            let kingInDanger = false;
            let prevCoordinateDIV;
            let counter = 1;
            // Variables End

            turn = "white";
            
            if (confirm("Do you want black pieces to be in the upperp position?")) {
                blackUp = true;
            } else {
                blackUp = false;
            }

            for(let rowNum = 1; rowNum <= boxes; rowNum++){
                // start of row outer for loop

                // start of inner for loop
                for(let colNum = 1; colNum <= boxes; colNum++){
                    let newCell = document.createElement("div");
                

                    // Different colors
                    if ((rowNum +colNum) % 2 === 0) {
                        newCell.style.backgroundColor = "rgb(99, 70, 49)";
                        
                    } else {
                        newCell.style.backgroundColor = "antiquewhite";
                        
                    }
                    newCell.className = `cell_${rowNum}_${colNum}`;

                    // when clicked it shows where piece can move
                    newCell.setAttribute("onclick", `clicked(".cell_${rowNum}_${colNum}")`);

                    chess_board.appendChild(newCell);
                }// end of inner for loop
            
            } // end of row outer for loop


            // White and Black Pawn position(For the Pawn)
            if (blackUp) {
                blackRowNum = 2;
                whiteRowNum = 7;  
            } else {
                blackRowNum = 7;
                whiteRowNum = 2;
            }

            for(let i = 1; i <= 8; i++){
                const whitePawnPosition = document.querySelector(`.cell_${whiteRowNum}_${i}`);
                whitePawnPosition.innerHTML = `<img src="./img/whitePawn.png" alt="whitePawn">`
                var whitePawn = new Pawn(`.cell_${whiteRowNum}_${i}`, blackUp, "white");
                whitePawnPieces.push(whitePawn);

                const blackPawnPosition = document.querySelector(`.cell_${blackRowNum}_${i}`);
                blackPawnPosition.innerHTML = `<img src="./img/blackPawn.png" alt="blackPawn">`
                var blackPawn = new Pawn(`.cell_${blackRowNum}_${i}`, blackUp, "black");
                blackPawnPieces.push(blackPawn);
            }

            // White and Black Pawn position(For the Other)
            if (blackUp) {
                blackRowNum = 1;
                whiteRowNum = 8;
            } else {
                blackRowNum = 8;
                whiteRowNum = 1;
            }

            // White and Black Rook Position
            chess_pieces.forEach((piece) => {
                // White Pieces
                const whitePosition = document.querySelector(`.cell_${whiteRowNum}_${tempNum}`);
                whitePosition.innerHTML = `<img src="./img/white${piece}.png" alt="white${piece}">`;
                switch (piece) {
                    case "Rook":
                        var whiteRook = new Rook(`.cell_${whiteRowNum}_${tempNum}`, blackUp, "white");
                        whiteRookPieces.push(whiteRook);
                        break;
                    case "Bishop":
                        var whiteBishop = new Bishop(`.cell_${whiteRowNum}_${tempNum}`, blackUp, "white");
                        whiteBishopPieces.push(whiteBishop);
                        break;
                    case "Knight":
                        var whiteKnight = new Knight(`.cell_${whiteRowNum}_${tempNum}`, blackUp, "white");
                        whiteKnightPieces.push(whiteKnight);
                        break;
                    case "Queen":
                        var whiteQueen = new Queen(`.cell_${whiteRowNum}_${tempNum}`, blackUp, "white");
                        whiteQueenPiece.push(whiteQueen);
                        break;   
                    case "King":
                        var whiteKing = new King(`.cell_${whiteRowNum}_${tempNum}`, blackUp, "white");
                        whiteKingPiece.push(whiteKing);
                        break;
                }

                // Black Pieces
                const blackPosition = document.querySelector(`.cell_${blackRowNum}_${tempNum}`);
                blackPosition.innerHTML = `<img src="./img/black${piece}.png" alt="black${piece}">`;
                switch (piece) {
                    case "Rook":
                        var blackRook = new Rook(`.cell_${blackRowNum}_${tempNum}`, blackUp, "black");
                        blackRookPieces.push(blackRook);
                        break;
                    case "Bishop":
                        var blackBishop = new Bishop(`.cell_${blackRowNum}_${tempNum}`, blackUp, "black");
                        blackBishopPieces.push(blackBishop);
                        break;
                    case "Knight":
                        var blackKnight = new Knight(`.cell_${blackRowNum}_${tempNum}`, blackUp, "black");
                        blackKnightPieces.push(blackKnight);
                        break;
                    case "Queen":
                        var blackQueen = new Queen(`.cell_${blackRowNum}_${tempNum}`, blackUp, "black");
                        blackQueenPiece.push(blackQueen);
                        break; 
                    case "King":
                        var blackKing = new King(`.cell_${blackRowNum}_${tempNum}`, blackUp, "black");
                        blackKingPiece.push(blackKing);
                        break;
                }

                tempNum++;
            });

            tempNum = 0;

            window.clicked = function(coordinateValue) {
                // selecting a coordinate
                const coordinate = document.querySelector(`${coordinateValue}`);

                // if the piece is selected
                if(selectedPiece) {
                    let tempSelectedPiece = selectedPiece;

                    // if the movement place is empty
                    if (coordinate.innerHTML === "") {
                        if (isCheckBlack) {
                            // Black is checked so you have to block the attacker by moving, or King has to evade
                            defendingMoves = blackKingPiece[0].defendingMoves(selectedPiece, prevCoordinate, attackerPiece, attackerCoordination, "block");
                        } else if (isCheckWhite) {
                            defendingMoves = whiteKingPiece[0].defendingMoves(selectedPiece, prevCoordinate, attackerPiece, attackerCoordination, "block");
                        } else {
                            defendTheKingMessage = true;
                        }

                        possibleMoves = possibleMove(selectedPiece, prevCoordinate, `${coordinateValue}`);

                        if (possibleMoves.length > 0) {
                            // check if it is checked situation
                            if (isCheckBlack || isCheckWhite) {

                                // when it is check castling is impossible
                                if (selectedPiece.getAttribute('alt').includes("King")) {
                                    let previous_xAxisValue = parseInt(prevCoordinate.substr(6, 1));
                                    let previous_yAxisValue = parseInt(prevCoordinate.substr(prevCoordinate.length -1, 1));
                                    let originLength = defendingMoves.length;
                                    let i = 0;
                                    let castlingMove = false;

                                    while (i < originLength) {
                                        if ((defendingMoves[i] === `.cell_${previous_xAxisValue}_${previous_yAxisValue+2}`) || (defendingMoves[i] === `.cell_${previous_xAxisValue}_${previous_yAxisValue-2}`)) {
                                            defendingMoves.splice(i, 1);
                                            castlingMove = true;
                                            i--;
                                            originLength = defendingMoves.length;
                                        }
                                        i++;
                                    } // loop


                                }// castling move filtered out



                                defendTheKingMessage = false;
                                for(let n = 0; n < defendingMoves.length; n++) {
                                    if(defendingMoves[n] === `${coordinateValue}`) {
                                        // pawn check
                                        if (selectedPiece.getAttribute('alt').includes("Pawn")){
                                            pawnMatch = true;
                                        }
                                        
                                        defendTheKingMessage = true;
                                        coordinate.appendChild(selectedPiece);
                                        updateCoordinate(selectedPiece, prevCoordinate, `${coordinateValue}`, false, "", false, blackUp);
                                        defendTheKingMessage = true;

                                        // if it is defended isCheckWhite or isCheckBlack becomes false
                                        if (isCheckBlack){
                                            isCheckBlack = false;
                                        } else if (isCheckWhite) {
                                            isCheckWhite = false;
                                        }


                                        switch (turn) {
                                            case "white":
                                                isCheckBlack = blackKingPiece[0].checked(selectedPiece, `${coordinateValue}`, turn, prevCoordinate);
                                                attackerPiece = selectedPiece;
                                                attackerCoordination = `${coordinateValue}`;
                                                if (isCheckBlack) {
                                                    checkedWord = document.querySelector('h1');
                                                    checkedWord.style.opacity = 1;
                                                }
                                                
                                                turn = "black";
                                                break;
                                            case "black":
                                                isCheckWhite = whiteKingPiece[0].checked(selectedPiece, `${coordinateValue}`, turn, prevCoordinate);
                                                attackerPiece = selectedPiece;
                                                attackerCoordination = `${coordinateValue}`;
                                                if (isCheckWhite) {
                                                    checkedWord = document.querySelector('h1');
                                                    checkedWord.style.opacity = 1;
                                                }
                                                
                                                turn = "white";
                                                break;
                                        } // end of switch case statement
                                        break;
                                    } // end of if it matches possible movements
                                } // for each defending moves

                                if (!defendTheKingMessage) {
                                    if (selectedPiece.getAttribute('alt').includes("blackKing")){
                                        blackKingPiece[0].numberOfMoves = blackKingPiece[0].numberOfMoves - 1; 
                                    }

                                    if (selectedPiece.getAttribute('alt').includes("whiteKing")){
                                        whiteKingPiece[0].numberOfMoves = whiteKingPiece[0].numberOfMoves - 1; 
                                    }

                                    if (selectedPiece.getAttribute('alt').includes("blackRook")){
                                        foundIdx = blackRookPieces.findIndex((rookClass) => {return rookClass.position === prevCoordinate});
                                        blackRookPieces[foundIdx].numberOfMoves = blackRookPieces[foundIdx].numberOfMoves - 1; 
                                    }

                                    if (selectedPiece.getAttribute('alt').includes("whiteRook")){
                                        foundIdx = whiteRookPieces.findIndex((rookClass) => {return rookClass.position === prevCoordinate});
                                        whiteRookPieces[foundIdx].numberOfMoves = whiteRookPieces[foundIdx].numberOfMoves - 1; 
                                    }
                                }

                            } else {
                                // not checked
                                defendTheKingMessage = true;
                                counter = 0;
                                for(let o = 0; o < possibleMoves.length; o++) {
                                    // possibleMoves matches the clicked coordinateValue
                                    if(possibleMoves[o] === `${coordinateValue}`) {
                                        coordinate.appendChild(selectedPiece);
                                        updateCoordinate(selectedPiece, prevCoordinate, `${coordinateValue}`, false, "", false, blackUp);

                                        // Check whether if the king is in danger
                                        if (turn === "white") {
                                            kingInDanger = whiteKingPiece[0].isInDanger();
                                        } else {
                                            kingInDanger = blackKingPiece[0].isInDanger();
                                        }
                                        
                                        // if king is in danger don't move
                                        if (kingInDanger) {
                                            // reverse the update
                                            prevCoordinateDIV.appendChild(selectedPiece);
                                            updateCoordinate(selectedPiece, `${coordinateValue}`, prevCoordinate, false, "", false, blackUp);
                                            coordinate.innerHTML = "";
                                            defendTheKingMessage = false;

                                            // pawn check
                                            if (selectedPiece.getAttribute('alt').includes("Pawn")){
                                                pawnMatch = false;
                                            }

                                            // rook check
                                            if (selectedPiece.getAttribute('alt').includes("whiteRook")) {
                                                foundIdx = whiteRookPieces.findIndex((eachRookClass) => {return eachRookClass.position === prevCoordinate});
                                                whiteRookPieces[foundIdx].numberOfMoves = whiteRookPieces[foundIdx].numberOfMoves - 1; 
                                            }

                                            if (selectedPiece.getAttribute('alt').includes("blackRook")) {
                                                foundIdx = blackRookPieces.findIndex((eachRookClass) => {return eachRookClass.position === prevCoordinate});
                                                blackRookPieces[foundIdx].numberOfMoves = blackRookPieces[foundIdx].numberOfMoves - 1; 
                                            }

                                            if (selectedPiece.getAttribute('alt').includes("blackKing")) {
                                                blackKingPiece[0].numberOfMoves = blackKingPiece[0].numberOfMoves - 1; 
                                            }

                                            if (selectedPiece.getAttribute('alt').includes("whiteKing")) {
                                                whiteKingPiece[0].numberOfMoves = whiteKingPiece[0].numberOfMoves - 1; 
                                            }

                                        } else {
                                            // pawn check
                                            defendTheKingMessage = true;
                                            if (selectedPiece.getAttribute('alt').includes("whitePawn")){
                                                let previous_xAxisValue = parseInt(prevCoordinate.substr(6, 1));
                                                let previous_yAxisValue = parseInt(prevCoordinate.substr(prevCoordinate.length -1, 1));
                                                let updated_xAxisValue = parseInt(`${coordinateValue}`.substr(6, 1));
                                                let updated_yAxisValue = parseInt(`${coordinateValue}`.substr(`${coordinateValue}`.length -1, 1));
                                                let upperPiece;
                                                let upperImagePiece;
                                                let downardPiece;
                                                let downardImagePiece;

                                                pawnMatch = true;

                                                foundIdx = whitePawnPieces.findIndex(function(cellNumber){return cellNumber.position === `.cell_${updated_xAxisValue}_${updated_yAxisValue}`});

                                                switch (foundIdx) {
                                                    case -1:
                                                        // pawn is promoted
                                                        break;
                                                    default:
                                                        // white Pawn is in downward position
                                                        if (whitePawnPieces[foundIdx].blackUp && (updated_xAxisValue === 3) && (updated_yAxisValue !== previous_yAxisValue)) {
                                                            // white is in down position
                                                            downardPiece = document.querySelector(`.cell_${updated_xAxisValue+1}_${updated_yAxisValue}`);
                                                            if (downardPiece.querySelector("img")) {
                                                                downardImagePiece = downardPiece.querySelector("img");
                                                                if(downardImagePiece.getAttribute('alt').includes("blackPawn")) {
                                                                    foundIdx = blackPawnPieces.findIndex(function(cellNumber){return cellNumber.position === `.cell_${updated_xAxisValue+1}_${updated_yAxisValue}`});
                                                                    blackPawnPieces.splice(foundIdx, 1);
                                                                    downardPiece.innerHTML = "";
                                                                } // if down image contains blackPawn
                                                            } // if downward piece has a piece
                                                        } // if white pawn pieces is in downard position

                                                        // white Pawn is in upward position
                                                        if ((!whitePawnPieces[foundIdx].blackUp) && (updated_xAxisValue === 6) && (updated_yAxisValue !== previous_yAxisValue)) {
                                                            // white is in down position
                                                            upperPiece = document.querySelector(`.cell_${updated_xAxisValue-1}_${updated_yAxisValue}`);
                                                            if (upperPiece.querySelector("img")) {
                                                                upperImagePiece = upperPiece.querySelector("img");
                                                                if(upperImagePiece.getAttribute('alt').includes("blackPawn")) {
                                                                    foundIdx = blackPawnPieces.findIndex(function(cellNumber){return cellNumber.position === `.cell_${updated_xAxisValue-1}_${updated_yAxisValue}`});
                                                                    blackPawnPieces.splice(foundIdx, 1);
                                                                    upperPiece.innerHTML = "";
                                                                } // if up image contains blackPawn
                                                            } // if upward piece has a piece
                                                        } // if white pawn pieces is in upward position
                                                        break;
                                                } // end of switch case

                                            } // if selected piece is white pawn

                                            if (selectedPiece.getAttribute('alt').includes("blackPawn")){
                                                let previous_xAxisValue = parseInt(prevCoordinate.substr(6, 1));
                                                let previous_yAxisValue = parseInt(prevCoordinate.substr(prevCoordinate.length -1, 1));
                                                let updated_xAxisValue = parseInt(`${coordinateValue}`.substr(6, 1));
                                                let updated_yAxisValue = parseInt(`${coordinateValue}`.substr(`${coordinateValue}`.length -1, 1));
                                                let upperPiece;
                                                let upperImagePiece;
                                                let downardPiece;
                                                let downardImagePiece;

                                                pawnMatch = true;

                                                foundIdx = blackPawnPieces.findIndex(function(cellNumber){return cellNumber.position === `.cell_${updated_xAxisValue}_${updated_yAxisValue}`});

                                                switch (foundIdx) {
                                                    case -1:
                                                        // pawn is promoted
                                                        break;
                                                    default:
                                                        // black Pawn is in upper position
                                                        if (blackPawnPieces[foundIdx].blackUp && (updated_xAxisValue === 6) && (updated_yAxisValue !== previous_yAxisValue)) {
                                                            // white is in down position
                                                            upperPiece = document.querySelector(`.cell_${updated_xAxisValue-1}_${updated_yAxisValue}`);
                                                            if (upperPiece.querySelector("img")) {
                                                                upperImagePiece = upperPiece.querySelector("img");
                                                                if(upperImagePiece.getAttribute('alt').includes("whitePawn")) {
                                                                    foundIdx = whitePawnPieces.findIndex(function(cellNumber){return cellNumber.position === `.cell_${updated_xAxisValue-1}_${updated_yAxisValue}`});
                                                                    whitePawnPieces.splice(foundIdx, 1);
                                                                    upperPiece.innerHTML = "";
                                                                } // if down image contains whitekPawn
                                                            } // if downward piece has a piece
                                                        } // if black pawn pieces is in downard position

                                                        // black Pawn is in downward position
                                                        if ((!blackPawnPieces[foundIdx].blackUp) && (updated_xAxisValue === 3) && (updated_yAxisValue !== previous_yAxisValue)) {
                                                            // white is in down position
                                                            downardPiece = document.querySelector(`.cell_${updated_xAxisValue+1}_${updated_yAxisValue}`);
                                                            if (downardPiece.querySelector("img")) {
                                                                downardImagePiece = downardPiece.querySelector("img");
                                                                if(downardImagePiece.getAttribute('alt').includes("whitePawn")) {
                                                                    foundIdx = whitePawnPieces.findIndex(function(cellNumber){return cellNumber.position === `.cell_${updated_xAxisValue+1}_${updated_yAxisValue}`});
                                                                    whitePawnPieces.splice(foundIdx, 1);
                                                                    downardPiece.innerHTML = "";
                                                                } // if up image contains blackPawn
                                                            } // if upward piece has a piece
                                                        } // if white pawn pieces is in upward position
                                                        break;
                                                } // end of switch case

                                                    
                                            } // if selected piece is black pawn

                                            // if selected is king (to check castle movement)
                                            if (selectedPiece.getAttribute('alt').includes("King")){
                                                let previous_xAxisValue = parseInt(prevCoordinate.substr(6, 1));
                                                let previous_yAxisValue = parseInt(prevCoordinate.substr(prevCoordinate.length -1, 1));
                                                let updated_xAxisValue = parseInt(`${coordinateValue}`.substr(6, 1));
                                                let updated_yAxisValue = parseInt(`${coordinateValue}`.substr(`${coordinateValue}`.length -1, 1));
                                                let diff_yAxisValue = updated_yAxisValue - previous_yAxisValue;
                                                let rookSelectedPiece;
                                                let rookImagePiece;
                                                let anotherSelectedPart;

                                                // moved right two times upper part
                                                if (diff_yAxisValue === 2 && updated_xAxisValue === 1) {
                                                    rookSelectedPiece = document.querySelector(`.cell_1_8`);
                                                    rookImagePiece = rookSelectedPiece.querySelector("img");
                                                    updateCoordinate(rookImagePiece, `.cell_1_8`, `.cell_${updated_xAxisValue}_${updated_yAxisValue-1}`, false, "", false, blackUp);
                                                    anotherSelectedPart = document.querySelector(`.cell_${updated_xAxisValue}_${updated_yAxisValue-1}`);
                                                    anotherSelectedPart.appendChild(rookImagePiece);
                                                    rookSelectedPiece.innerHTML = "";
                                                    if (rookImagePiece.getAttribute("alt").includes("black")){
                                                        foundIdx = blackRookPieces.findIndex((rookClass) => {return rookClass.position === `.cell_${updated_xAxisValue}_${updated_yAxisValue-1}`});
                                                        blackRookPieces[foundIdx].numberOfMoves = blackRookPieces[foundIdx].numberOfMoves + 1;
                                                    } else {
                                                        foundIdx = whiteRookPieces.findIndex((rookClass) => {return rookClass.position === `.cell_${updated_xAxisValue}_${updated_yAxisValue-1}`});
                                                        whiteRookPieces[foundIdx].numberOfMoves = whiteRookPieces[foundIdx].numberOfMoves + 1;
                                                    }
                                                }

                                                // moved right two times down part
                                                if (diff_yAxisValue === 2 && updated_xAxisValue === 8) {
                                                    rookSelectedPiece = document.querySelector(`.cell_8_8`);
                                                    rookImagePiece = rookSelectedPiece.querySelector("img");
                                                    updateCoordinate(rookImagePiece, `.cell_8_8`, `.cell_${updated_xAxisValue}_${updated_yAxisValue-1}`, false, "", false, blackUp);
                                                    anotherSelectedPart = document.querySelector(`.cell_${updated_xAxisValue}_${updated_yAxisValue-1}`);
                                                    anotherSelectedPart.appendChild(rookImagePiece);
                                                    rookSelectedPiece.innerHTML = "";
                                                    if (rookImagePiece.getAttribute("alt").includes("black")){
                                                        foundIdx = blackRookPieces.findIndex((rookClass) => {return rookClass.position === `.cell_${updated_xAxisValue}_${updated_yAxisValue-1}`});
                                                        blackRookPieces[foundIdx].numberOfMoves = blackRookPieces[foundIdx].numberOfMoves + 1;
                                                    } else {
                                                        foundIdx = whiteRookPieces.findIndex((rookClass) => {return rookClass.position === `.cell_${updated_xAxisValue}_${updated_yAxisValue-1}`});
                                                        whiteRookPieces[foundIdx].numberOfMoves = whiteRookPieces[foundIdx].numberOfMoves + 1;
                                                    }
                                                }

                                                // moved left two times upper part
                                                if (diff_yAxisValue === -2 && updated_xAxisValue === 1) {
                                                    rookSelectedPiece = document.querySelector(`.cell_1_1`);
                                                    rookImagePiece = rookSelectedPiece.querySelector("img");
                                                    updateCoordinate(rookImagePiece, `.cell_1_1`, `.cell_${updated_xAxisValue}_${updated_yAxisValue+1}`, false, "", false, blackUp);
                                                    anotherSelectedPart = document.querySelector(`.cell_${updated_xAxisValue}_${updated_yAxisValue+1}`);
                                                    anotherSelectedPart.appendChild(rookImagePiece);
                                                    rookSelectedPiece.innerHTML = "";
                                                    if (rookImagePiece.getAttribute("alt").includes("black")){
                                                        foundIdx = blackRookPieces.findIndex((rookClass) => {return rookClass.position === `.cell_${updated_xAxisValue}_${updated_yAxisValue-1}`});
                                                        blackRookPieces[foundIdx].numberOfMoves = blackRookPieces[foundIdx].numberOfMoves + 1;
                                                    } else {
                                                        foundIdx = whiteRookPieces.findIndex((rookClass) => {return rookClass.position === `.cell_${updated_xAxisValue}_${updated_yAxisValue-1}`});
                                                        whiteRookPieces[foundIdx].numberOfMoves = whiteRookPieces[foundIdx].numberOfMoves + 1;
                                                    }
                                                }
                                                
                                                // moved left two times down part
                                                if (diff_yAxisValue === -2 && updated_xAxisValue === 8) {
                                                    rookSelectedPiece = document.querySelector(`.cell_8_1`);
                                                    rookImagePiece = rookSelectedPiece.querySelector("img");
                                                    updateCoordinate(rookImagePiece, `.cell_8_1`, `.cell_${updated_xAxisValue}_${updated_yAxisValue+1}`, false, "", false, blackUp);
                                                    anotherSelectedPart = document.querySelector(`.cell_${updated_xAxisValue}_${updated_yAxisValue+1}`);
                                                    anotherSelectedPart.appendChild(rookImagePiece);
                                                    rookSelectedPiece.innerHTML = "";
                                                    if (rookImagePiece.getAttribute("alt").includes("black")){
                                                        foundIdx = blackRookPieces.findIndex((rookClass) => {return rookClass.position === `.cell_${updated_xAxisValue}_${updated_yAxisValue-1}`});
                                                        blackRookPieces[foundIdx].numberOfMoves = blackRookPieces[foundIdx].numberOfMoves + 1;
                                                    } else {
                                                        foundIdx = whiteRookPieces.findIndex((rookClass) => {return rookClass.position === `.cell_${updated_xAxisValue}_${updated_yAxisValue-1}`});
                                                        whiteRookPieces[foundIdx].numberOfMoves = whiteRookPieces[foundIdx].numberOfMoves + 1;
                                                    }
                                                }
                                                    
                                            } // if selected piece is black king for castling
                                            


                                            switch (turn) {
                                                case "white":
                                                    isCheckBlack = blackKingPiece[0].checked(selectedPiece, `${coordinateValue}`, turn, prevCoordinate);
                                                    attackerPiece = selectedPiece;
                                                    attackerCoordination = `${coordinateValue}`;
                                                    if (isCheckBlack) {
                                                        checkedWord = document.querySelector('h1');
                                                        checkedWord.style.opacity = 1;
                                                    }
                                                    
                                                    turn = "black";
                                                    break;
                                                case "black":
                                                    isCheckWhite = whiteKingPiece[0].checked(selectedPiece, `${coordinateValue}`, turn, prevCoordinate);
                                                    attackerPiece = selectedPiece;
                                                    attackerCoordination = `${coordinateValue}`;
                                                    if (isCheckWhite) {
                                                        checkedWord = document.querySelector('h1');
                                                        checkedWord.style.opacity = 1;
                                                    }
                                                    
                                                    turn = "white";
                                                    break;
                                            } // end of switch case statement
                                        } // if king is in danger or not in danger

                                        
                                        break;
                                    } // end of if it matches possible movements
                                            
                                        
                                    counter = counter + 1;
                                } // for loop for the possible moves length not checked

                                // if there is no match
                                if (counter === possibleMoves.length || possibleMoves.length === 0) {
                                    if (selectedPiece.getAttribute('alt').includes("blackKing")){
                                        blackKingPiece[0].numberOfMoves = blackKingPiece[0].numberOfMoves - 1; 
                                    }

                                    if (selectedPiece.getAttribute('alt').includes("whiteKing")){
                                        whiteKingPiece[0].numberOfMoves = whiteKingPiece[0].numberOfMoves - 1; 
                                    }

                                    if (selectedPiece.getAttribute('alt').includes("blackRook")){
                                        foundIdx = blackRookPieces.findIndex((rookClass) => {return rookClass.position === prevCoordinate});
                                        blackRookPieces[foundIdx].numberOfMoves = blackRookPieces[foundIdx].numberOfMoves - 1; 
                                    }

                                    if (selectedPiece.getAttribute('alt').includes("whiteRook")){
                                        foundIdx = whiteRookPieces.findIndex((rookClass) => {return rookClass.position === prevCoordinate});
                                        whiteRookPieces[foundIdx].numberOfMoves = whiteRookPieces[foundIdx].numberOfMoves - 1; 
                                    }
                                }
                           } /////// if else isCheckBlack isCheckWhite finished else not check
                            
                        } // possible Moves length is bigger than 0

                        selectedPiece = null;
                        
                    // if there is an enemy or other piece
                    } else {
                        let otherPiece = coordinate.querySelector("img");
                        let eatingPossibilities = [];

                        if (isCheckBlack) {
                            // Black is checked so you have to block the attacker by moving, or King has to evade
                            if (selectedPiece.getAttribute('alt').includes("King")) {
                                defendingMoves = blackKingPiece[0].defendingMoves(selectedPiece, prevCoordinate, attackerPiece, attackerCoordination, "block");
                            } else {
                                defendingMoves = blackKingPiece[0].defendingMoves(selectedPiece, prevCoordinate, attackerPiece, attackerCoordination, "eat");
                            }
                            
                        } else if (isCheckWhite) {
                            if (selectedPiece.getAttribute('alt').includes("King")) {
                                defendingMoves = whiteKingPiece[0].defendingMoves(selectedPiece, prevCoordinate, attackerPiece, attackerCoordination, "block");
                            } else {
                                defendingMoves = whiteKingPiece[0].defendingMoves(selectedPiece, prevCoordinate, attackerPiece, attackerCoordination, "eat");
                            }
                        } else {
                            defendTheKingMessage = true;
                        }


                        if (otherPiece.getAttribute('alt').includes("white") && turn === "black" || otherPiece.getAttribute('alt').includes("black") && turn === "white"){
                            eatingPossibilities = eatingPossibility(selectedPiece, prevCoordinate, `${coordinateValue}`);

                            if (eatingPossibilities.length > 0) {

                                if (isCheckBlack || isCheckWhite) {
                                     // if you are in a defending position and you have to eat the enemy
                                    
                                    for(let n = 0; n < defendingMoves.length; n++) {
                                        if(defendingMoves[n] === `${coordinateValue}`) {
                                            defendTheKingMessage = true;
                                            eatenPiece = coordinate.innerHTML;
                                            coordinate.innerHTML = "";
                                            coordinate.appendChild(selectedPiece);
                                            updateCoordinate(selectedPiece, prevCoordinate, `${coordinateValue}`, true, otherPiece, false, blackUp);


                                            if (isCheckBlack) {
                                                isCheckBlack = false;
                                            } else if (isCheckWhite) {
                                                isCheckWhite = false;
                                            }

                                            // pawn check
                                            if (selectedPiece.getAttribute('alt').includes("Pawn")){
                                                pawnMatch = true;
                                            }


                                            switch (turn) {
                                                case "white":
                                                    isCheckBlack = blackKingPiece[0].checked(selectedPiece, `${coordinateValue}`, turn, prevCoordinate);
                                                    attackerPiece = selectedPiece;
                                                    attackerCoordination = `${coordinateValue}`;
                                                    if (isCheckBlack) {
                                                        checkedWord = document.querySelector('h1');
                                                        checkedWord.style.opacity = 1;
                                                    }
                                                    turn = "black";
                                                    
                                                    break;
                                                case "black":
                                                    isCheckWhite = whiteKingPiece[0].checked(selectedPiece, `${coordinateValue}`, turn, prevCoordinate);
                                                    attackerPiece = selectedPiece;
                                                    attackerCoordination = `${coordinateValue}`;
                                                    if (isCheckWhite) {
                                                        checkedWord = document.querySelector('h1');
                                                        checkedWord.style.opacity = 1;
                                                    }
                                                    turn = "white";
                                                    
                                                    break;
                                            } // end of switch case statement
                                            selectedPiece = null;
                                            break;

                                        } // end of if it matches possible movements       
                                    } // for loop for defending moves length
                                        
                                    

                                    if (!defendTheKingMessage) {
                                        if (selectedPiece.getAttribute('alt').includes("blackKing")){
                                            blackKingPiece[0].numberOfMoves = blackKingPiece[0].numberOfMoves - 1; 
                                        }

                                        if (selectedPiece.getAttribute('alt').includes("whiteKing")){
                                            whiteKingPiece[0].numberOfMoves = whiteKingPiece[0].numberOfMoves - 1; 
                                        }

                                        if (selectedPiece.getAttribute('alt').includes("blackRook")){
                                            foundIdx = blackRookPieces.findIndex((rookClass) => {return rookClass.position === prevCoordinate});
                                            blackRookPieces[foundIdx].numberOfMoves = blackRookPieces[foundIdx].numberOfMoves - 1; 
                                        }

                                        if (selectedPiece.getAttribute('alt').includes("whiteRook")){
                                            foundIdx = whiteRookPieces.findIndex((rookClass) => {return rookClass.position === prevCoordinate});
                                            whiteRookPieces[foundIdx].numberOfMoves = whiteRookPieces[foundIdx].numberOfMoves - 1; 
                                        }
                                    }


                                } else {
                                    // you are not in a dangerous situation
                                    defendTheKingMessage = true;
                                    counter = 0;
                                    for (let q = 0; q < eatingPossibilities.length; q++) {
                                        if(eatingPossibilities[q] === `${coordinateValue}`) {
                                            eatenPiece = coordinate.innerHTML;
                                            coordinate.innerHTML = "";
                                            coordinate.appendChild(selectedPiece);
                                            updateCoordinate(selectedPiece, prevCoordinate, `${coordinateValue}`, true, otherPiece, false, blackUp);

                                            if (turn === "white") {
                                                kingInDanger = whiteKingPiece[0].isInDanger();
                                            } else {
                                                kingInDanger = blackKingPiece[0].isInDanger();
                                            }

                                            if (kingInDanger) {
                                                // king is in danger, reverse the update
                                                coordinate.innerHTML = eatenPiece;
                                                prevCoordinateDIV.appendChild(selectedPiece);
                                                updateCoordinate(selectedPiece, `${coordinateValue}`, prevCoordinate, false, otherPiece, true, blackUp);
                                                // pawn check
                                                if (selectedPiece.getAttribute('alt').includes("Pawn")){
                                                    pawnMatch = true;
                                                }

                                                defendTheKingMessage = false;
                                                break;
                                            } else {
                                                defendTheKingMessage = true;
                                                // pawn check
                                                if (selectedPiece.getAttribute('alt').includes("Pawn")){
                                                    pawnMatch = true;
                                                }

                                                switch (turn) {
                                                    case "white":
                                                        isCheckBlack = blackKingPiece[0].checked(selectedPiece, `${coordinateValue}`, turn, prevCoordinate);
                                                        attackerPiece = selectedPiece;
                                                        attackerCoordination = `${coordinateValue}`;
                                                        if (isCheckBlack) {
                                                            checkedWord = document.querySelector('h1');
                                                            checkedWord.style.opacity = 1;
                                                        }
                                                        turn = "black";
                                                        
                                                        break;
                                                    case "black":
                                                        isCheckWhite = whiteKingPiece[0].checked(selectedPiece, `${coordinateValue}`, turn, prevCoordinate);
                                                        attackerPiece = selectedPiece;
                                                        attackerCoordination = `${coordinateValue}`;
                                                        if (isCheckWhite) {
                                                            checkedWord = document.querySelector('h1');
                                                            checkedWord.style.opacity = 1;
                                                        }
                                                        turn = "white";
                                                        
                                                        break;
                                                } // end of switch case statement
                                                selectedPiece = null;
                                                break;
                                            }

                                                

                                        } // end of if it matches possible movements
                                        counter = counter + 1;

                                    } // eating possibilities length    
                                    
                                    
                                    // rook check
                                    if (!defendTheKingMessage || counter === eatingPossibilities.length) {
                                        if (selectedPiece.getAttribute('alt').includes("whiteRook")) {
                                            foundIdx = whiteRookPieces.findIndex((eachRookClass) => {return eachRookClass.position === prevCoordinate});
                                            whiteRookPieces[foundIdx].numberOfMoves = whiteRookPieces[foundIdx].numberOfMoves - 1; 
                                        }

                                        if (selectedPiece.getAttribute('alt').includes("blackRook")) {
                                            foundIdx = blackRookPieces.findIndex((eachRookClass) => {return eachRookClass.position === prevCoordinate});
                                            blackRookPieces[foundIdx].numberOfMoves = blackRookPieces[foundIdx].numberOfMoves - 1; 
                                        }

                                        if (selectedPiece.getAttribute('alt').includes("blackKing")) {
                                            blackKingPiece[0].numberOfMoves = blackKingPiece[0].numberOfMoves - 1; 
                                        }

                                        if (selectedPiece.getAttribute('alt').includes("whiteKing")) {
                                            whiteKingPiece[0].numberOfMoves = whiteKingPiece[0].numberOfMoves - 1; 
                                        }

                                        if (selectedPiece.getAttribute('alt').includes("Pawn") && !defendTheKingMessage){
                                           pawnMatch = true;
                                        }
                                        
                                    } 
                                }
                            }
                        } else {// if you are trying to eat something end
                            if (selectedPiece.getAttribute('alt').includes("Pawn")){
                                pawnMatch = true;
                            }
                        }
   
                    }

                    selectedPiece = null;

                    if (!defendTheKingMessage){
                        let pieceName = tempSelectedPiece.getAttribute('alt');

                        if(pieceName.includes("Pawn")) {
                            let pawn_xAxisValue = prevCoordinate.substr(6, 1);
                            let pawn_yAxisValue = prevCoordinate.substr(prevCoordinate.length - 1, 1);
                            switch(pieceName) {
                                case "whitePawn":
                                    foundIdx = whitePawnPieces.findIndex(function(cellNumber){return cellNumber.position === `.cell_${pawn_xAxisValue}_${pawn_yAxisValue}`});
                                    whitePawnPieces[foundIdx].numberOfMoves = whitePawnPieces[foundIdx].numberOfMoves -1;
                                    if (whitePawnPieces[foundIdx].numberOfMoves === 0 || whitePawnPieces[foundIdx].numberOfMoves < 0){
                                        whitePawnPieces[foundIdx].firstMove = true;
                                        whitePawnPieces[foundIdx].numberOfMoves = 0;
                                    }      
                                    break;
                                case "blackPawn":
                                    foundIdx = blackPawnPieces.findIndex(function(cellNumber){return cellNumber.position === `.cell_${pawn_xAxisValue}_${pawn_yAxisValue}`});
                                    blackPawnPieces[foundIdx].numberOfMoves = blackPawnPieces[foundIdx].numberOfMoves -1;
                                    if (blackPawnPieces[foundIdx].numberOfMoves === 0 || blackPawnPieces[foundIdx].numberOfMoves < 0){
                                        blackPawnPieces[foundIdx].firstMove = true;
                                        blackPawnPieces[foundIdx].numberOfMoves = 0;
                                    }
                                    break;
                            } // end of switch case
                        }

                        alert("You have to defend the king!")
                    }

                    // if pawn match is not true then, go to original
                    if (!pawnMatch) {
                        let pieceName = tempSelectedPiece.getAttribute('alt');

                        if(pieceName.includes("Pawn")) {
                            let pawn_xAxisValue = prevCoordinate.substr(6, 1);
                            let pawn_yAxisValue = prevCoordinate.substr(`${coordinateValue}`.length - 1, 1);
                            switch(pieceName) {
                                case "whitePawn":
                                    foundIdx = whitePawnPieces.findIndex(function(cellNumber){return cellNumber.position === `.cell_${pawn_xAxisValue}_${pawn_yAxisValue}`});
                                    whitePawnPieces[foundIdx].numberOfMoves = whitePawnPieces[foundIdx].numberOfMoves -1;
                                    if (whitePawnPieces[foundIdx].numberOfMoves === 0 || whitePawnPieces[foundIdx].numberOfMoves < 0){
                                        whitePawnPieces[foundIdx].firstMove = true;
                                        whitePawnPieces[foundIdx].numberOfMoves = 0;
                                    }      
                                    break;
                                case "blackPawn":
                                    foundIdx = blackPawnPieces.findIndex(function(cellNumber){return cellNumber.position === `.cell_${pawn_xAxisValue}_${pawn_yAxisValue}`});
                                    blackPawnPieces[foundIdx].numberOfMoves = blackPawnPieces[foundIdx].numberOfMoves -1;
                                    if (blackPawnPieces[foundIdx].numberOfMoves === 0 || blackPawnPieces[foundIdx].numberOfMoves < 0){
                                        blackPawnPieces[foundIdx].firstMove = true;
                                        blackPawnPieces[foundIdx].numberOfMoves = 0;
                                    }
                                    break;
                            } // end of switch case
                        }
                    }

                    // pawnMatch and defendTheKingMessage default
                    pawnMatch = false;
                    defendTheKingMessage = false;
                    kingInDanger = false;


                } else {
                    if(coordinate.querySelector("img")){
                        checkedWord.style.opacity = 0;
                        // if it is not selectedPiece, then selection 
                        selectedPiece = coordinate.querySelector("img");

                        if(!selectedPiece.getAttribute('alt').includes(turn)) {
                            selectedPiece = null;
                        } else {
                            prevCoordinate = `${coordinateValue}`;
                            prevCoordinateDIV = coordinate;
                        }
                        
                    } // inner if image if statement
                } // outer else statement
            }
        });
        
    </script>
    <!--JavaScript Part End-->
<body>
    <div class="chess_board">

    </div>
    <p></p>
    <div class="checked">
        <h1>CHECK</h1>
    </div>
    
</body>
</html>